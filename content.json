{"meta":{"title":"YiDan の dada","subtitle":"","description":"","author":"wuxuan.chai","url":"https://cha1yi.github.io/dist","root":"/dist/"},"pages":[{"title":"关于","date":"2021-01-16T17:37:28.597Z","updated":"2021-01-16T17:37:28.597Z","comments":true,"path":"about/index.html","permalink":"https://cha1yi.github.io/dist/about/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2021-01-16T17:37:28.598Z","updated":"2021-01-16T17:37:28.598Z","comments":true,"path":"categories/index.html","permalink":"https://cha1yi.github.io/dist/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-01-16T17:37:28.599Z","updated":"2021-01-16T17:37:28.599Z","comments":true,"path":"tags/index.html","permalink":"https://cha1yi.github.io/dist/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式之----工厂模式","slug":"设计模式之----工厂模式","date":"2021-01-17T15:37:18.288Z","updated":"2021-01-17T15:38:56.951Z","comments":true,"path":"2021/01/17/设计模式之----工厂模式/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B----%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式之—-工厂模式工厂模式（Factory Pattern）是java中最常用的设计模式之一，这种类型设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象是不会对客户暴露创建逻辑，并且是通过使用一个共同的接口，以此来达到解耦的目的。 下面的例子以造车为例来说明三种模式。 分类1、简单工厂模式 (Simple Factory)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class Car &#123;&#125;public enum CarType &#123; BMW, AUDI, DAZHONG;&#125;public class BmwCar extends Car&#123; public BmwCar()&#123; System.out.println(&quot;这是宝马车&quot;); &#125;&#125;public class AudiCar extends Car&#123; public AudiCar()&#123; System.out.println(&quot;这是奥迪车&quot;); &#125;&#125;public class DaZhongCar extends Car &#123; public DaZhongCar() &#123; System.out.println(&quot;这是大众车&quot;); &#125;&#125;public class CarFactory &#123; /** * 静态工厂方法 * * @param carType 车的类型 * @return 车的对象 */ public static Car createCar(CarType carType) &#123; switch (carType) &#123; case BMW: return new BmwCar(); case AUDI: return new AudiCar(); case DAZHONG: return new DaZhongCar(); default: return null; &#125; &#125; public static void main(String[] args) &#123; CarFactory.createCar(CarType.AUDI); &#125;&#125; 输出： 123这是奥迪车Process finished with exit code 0 这种工厂模式，已经完成了我们工厂模式的基本的需求，创建对象和解耦缺点：1、用户调用需要知道自己要创建的对象在工厂中的类型2、拓展很麻烦，如果新增一个产品，需要在产品的具体创建对象的实现，还需使工厂支持创建这种产品，这显然是违背开闭原则的 2、工厂方法模式（Factory Method）123456789101112131415161718192021222324252627282930313233public interface Factory &#123; /** * 生产车的方法 * @return 车的对象 */ Car createCar();&#125;public class AudiFactory implements Factory&#123; @Override public Car createCar() &#123; return new AudiCar(); &#125;&#125;public class BmwFactory implements Factory&#123; @Override public Car createCar() &#123; return new BmwCar(); &#125;&#125;public class DaZhongFactory implements Factory&#123; @Override public Car createCar() &#123; return new DaZhongCar(); &#125;&#125;//客户使用public class ConsumerTest &#123; public static void main(String[] args) &#123; final BmwFactory bmwFactory = new BmwFactory(); bmwFactory.createCar(); &#125;&#125; 输出： 123这是宝马车Process finished with exit code 0 工厂方法模式组成： 1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 方法工厂模式和简单工厂模式最大的不同，就是将实现交给了具体的工厂，核心工厂只提供产品线，具体的实现工厂只需要去实现对应的需求即可。如果新增产，只需要去实现对应的产品工厂即可，显然这种方式是符合开闭原则的 3、抽象工厂模式 (Abstract Factory)个人觉得抽象工厂模式和工厂方法模式区别不是很大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface Factory &#123; /** * 生产车的方法 * * @return 车的对象 */ Car createCar(); /** * 获取价钱 * * @return 价钱 */ double pricing();&#125;public class AudiFactory implements Factory &#123; @Override public Car createCar() &#123; return new AudiCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：20_0000&quot;); return 20_0000; &#125;&#125;public class BmwFactory implements Factory &#123; @Override public Car createCar() &#123; return new BmwCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：25_0000&quot;); return 25_0000; &#125;&#125;public class DaZhongFactory implements Factory &#123; @Override public Car createCar() &#123; return new DaZhongCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：18_0000&quot;); return 18_0000; &#125;&#125;//客户使用public class ConsumerTest &#123; public static void main(String[] args) &#123; final BmwFactory bmwFactory = new BmwFactory(); bmwFactory.createCar(); bmwFactory.pricing(); &#125;&#125; 总结：无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"DO、DTO、BO、VO、POJO的定义","slug":"DO、DTO、BO、VO、POJO的定义","date":"2021-01-17T15:33:00.411Z","updated":"2021-01-17T15:38:45.998Z","comments":true,"path":"2021/01/17/DO、DTO、BO、VO、POJO的定义/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/DO%E3%80%81DTO%E3%80%81BO%E3%80%81VO%E3%80%81POJO%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"DO、DTO、BO、VO、POJO的定义分层领域模型规约DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。AO（ Application Object）：应用对象。 在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。POJO（ Plain Ordinary Java Object）：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。Query：数据查询对象，各层接收上层的查询请求。 注意超过2个参数的查询封装，禁止使用Map类来传输。 领域模型命名规约数据对象：xxxDO，xxx即为数据表名。数据传输对象：xxxDTO，xxx为业务领域相关的名称。展示对象：xxxVO，xxx一般为网页名称。POJO: 专指只有 setter / getter / toString的简单类，包括DO/DTO/BO/VO等,禁止命名成 xxxPOJO","categories":[{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[],"author":"wuxuan.chai"}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}