{"meta":{"title":"YiDan の dada","subtitle":"","description":"","author":"wuxuan.chai","url":"https://cha1yi.github.io/dist","root":"/dist/"},"pages":[{"title":"关于","date":"2021-01-16T17:37:28.597Z","updated":"2021-01-16T17:37:28.597Z","comments":true,"path":"about/index.html","permalink":"https://cha1yi.github.io/dist/about/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2021-01-16T17:37:28.598Z","updated":"2021-01-16T17:37:28.598Z","comments":true,"path":"categories/index.html","permalink":"https://cha1yi.github.io/dist/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-01-16T17:37:28.599Z","updated":"2021-01-16T17:37:28.599Z","comments":true,"path":"tags/index.html","permalink":"https://cha1yi.github.io/dist/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"架构思维","date":"2021-03-19T09:19:03.896Z","updated":"2021-03-19T09:19:50.816Z","comments":true,"path":"2021/03/19/架构思维/","link":"","permalink":"https://cha1yi.github.io/dist/2021/03/19/%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/","excerpt":"","text":"dolphinschedule 调度中的依赖问题是个难题、你要是能理解深刻也要好好说一下 newbi血缘分析的思路 整体设计思想、组件设计思想、资源隔离、内部的流式设计思想、mapreduce思想 etl中中的执行引擎思想也要能吹 流式思想 db查询，csv下载、excel下载 olap里面的整体设计思想要能说明白，流式计算、缓存思想、spi思想等要能随手撵来","categories":[],"tags":[]},{"title":"","slug":"xx","date":"2021-03-15T14:20:42.353Z","updated":"2021-03-19T09:19:16.611Z","comments":true,"path":"2021/03/15/xx/","link":"","permalink":"https://cha1yi.github.io/dist/2021/03/15/xx/","excerpt":"","text":"联系方式（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便） 手机：135…. （如果是外地手机，可注明。如经常关机，要写上最优联系时间） Email：&#x67;&#111;&#x6f;&#x64;&#x6d;&#97;&#x6e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d; （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G，非要用的话，不要用数字邮箱名） QQ/微信号：6…（提供一个通过网络可以联系到你的方式） 个人信息 冷熊/男/1990 本科/北极大学计算机系 工作年限：3年 微博：@Easy （如果没有技术相关内容，也可以不放） 技术博客：http://old.ftqq.com ( 使用GitHub Host的Big较高 ) Github：http://github.com/easychen ( 有原创repo的Github帐号会极大的提升你的个人品牌 ) 期望职位：PHP高级程序员，应用架构师 期望薪资：税前月薪15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC公司 （ 2012年9月 ~ 2014年9月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL公司 （ 2010年3月 ~ 2012年8月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发","categories":[],"tags":[]},{"title":"","slug":"简历","date":"2021-03-15T14:04:54.556Z","updated":"2021-03-18T15:43:51.343Z","comments":true,"path":"2021/03/15/简历/","link":"","permalink":"https://cha1yi.github.io/dist/2021/03/15/%E7%AE%80%E5%8E%86/","excerpt":"","text":"个人信息姓 名：柴梧炫 出生年月：1994年9月15日 籍 贯：河南 信阳 个人爱好：听歌、Moba游戏、狼人杀 个人优点：做事沉稳、学习能力强、有一定的逻辑思维能力、善于梳理总结和分析、喜欢有挑战性的事物、谦虚善于聆听、对待工作认真细心持之以恒。 联系方式 电话：13361900933 Email：&#x77;&#117;&#120;&#x75;&#97;&#x6e;&#46;&#x63;&#104;&#x61;&#105;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d; QQ：1045005462 Wechat：chaiwuxuan 教育背景河南理工大学 网络工程 本科 求职意向职 位： Java开发工程师 工作城市：武汉 工作性质：全职 薪资要求：面谈 工作经历2018.01.15～至今 杭州数云信息技术有限公司(上海企业级研发部) JAVA开发工程师 职责描述 参与项目的需求评审，技术选型 负责项目的迭代开发，相关功能的重构 负责公司内部相关服务间的API设计以及开发 负责组内项目代码的Code Review 负责项目的版本发布以及与运维同学的实施协助 专业技能 熟练使用Java core、IO、多线程、集合等基础 熟练使用Spring、Springboot及相关的全家桶。 熟练使用JPA、Mybatis、JOOQ等持久层框架 熟练使用SQL，熟练使用常见的数据库，如Mysql、PostgreSQL等，以及分布式列式数据库，如ClickHouse、GreenPlum等。 熟练使用Redis、Kafka、Zookeeper、ElaticSearch 熟悉JVM的内存结构，并有一定排查问题的经验 熟练使用Maven、IDEA、GIT、Jenkins等快速构建并开发项目 熟练使用Docker，编写DockerFile进行项目镜像化打包部署 熟练使用Linux命令及环境搭建 熟悉OLAP、ETL等业务，对业内开源项目有一定的了解 了解Hadoop、hive、hbase 项目经历NewBI项目周期：2018年至今 项目技术：Spring、Spring MVC、Mybatis、AntLr4、Redis、Mysql、Guava 项目介绍：NewBI是一款自助式 BI 工具，提供完整的数据分析能力，以及丰富的报表图标能力，用户可以自己通过已有的报表制作可视化大屏、移动端的仪表盘等。我们可以通过它进行丰富的数据分析，从而发现数据背后的商业机会，为企业决策提供数据基础。支持了大部分市面上的常用数据库引擎，可以通过已有的模型进行快速部署，一键式发布使用。除此之外，提供了非常强大的自定义功能，如逻辑建模、表达式字段、自定义维度排序、小计合计等功能，能够满足用户绝大多数的报表需求。 负责模块： 数据源管理 文件数据源 Mysql、Oracle、SQL-Server、Impala、Clickhouse、Greenplumn、hive、Apache Kylin等数据源的适配 数据源连接池管理 OLAP（核心模块） 逻辑建模 数据主题管理、导入、导出 表达式字段定义 维度、度量的管理 报表、KPI等查询场景设计 项目管理 项目权限管理，包含用户角色授权、数据主题授权 仪表盘/报表管理 项目导入、导出 用户模块管理 本地用户管理 作为SP接入第三方的IDP，同步用户（数据权限和基本信息） 数据权限 动态数据权限（Tree类型的数据权限） 静态数据权限（固定值） 系统监控 用户操作监控 系统异常错误监控 OLAP查询的SQL监控 BI系统和运维健康接口 系统配置 支持多租户场景下的定制化配置独立 后端服务国际化 SAAS化改造（伪SAAS） 导出管理 数据准备（Data Prepare）项目周期：2019年7月至今 项目技术：SpringBoot、Mybatis-plus、Redis、Antlr4、Mysql、Kafka、Redision、 项目描述：借助直观简洁的可视化流程工具，轻松连接多个数据源、合并数据、清洗数据。完成数据准备工作。可以与公司的数据服务无缝衔接，输出的结果可以直接对接至NewBI的逻辑建模中，可以和NewBI相辅相成，快速帮助用户实现数据价值分析。 负责模块： 后端服务国际化 基础架构搭建（基础代码封装） 对接公司服务（Epassport、数据服务、数据模型、规则解析模块） 接口权限设计注册 ETL组件模块 SQL解析引擎 数据源管理模块 数据流管理 用户行为监控 Epassport项目周期：2018年10月至今 项目技术：SpringBoot、JOOQ、Redis、Mysql 项目描述：Epassport是公司的负责提供与公司内部其他微服务的权限注册、认证、用户管理（角色、权限）的一个基础服务。IAM模块是将客户的用户体系作为IDP接入到Epassport，实现SSO的功能。双因素认证是对各个服务的敏感操作，做统一的校验以及授权的功能。 负责模块： IAM SAML 钉钉 企业微信 双因素认证 用户角色和权限管理","categories":[],"tags":[]},{"title":"Dubbo架构入门","slug":"Dubbo-架构入门","date":"2021-03-01T10:04:19.949Z","updated":"2021-03-01T10:06:49.236Z","comments":true,"path":"2021/03/01/Dubbo-架构入门/","link":"","permalink":"https://cha1yi.github.io/dist/2021/03/01/Dubbo-%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8/","excerpt":"","text":"Dubbo架构Dubbo 架构 节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。 连通性 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 健壮性 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 伸缩性 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者 升级性当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构： 节点角色说明 节点 角色说明 Deployer 自动部署服务的本地代理 Repository 仓库用于存储服务应用发布包 Scheduler 调度中心基于访问压力自动增减服务提供者 Admin 统一管理控制台 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心","categories":[{"name":"微服务","slug":"微服务","permalink":"https://cha1yi.github.io/dist/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://cha1yi.github.io/dist/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"author":"wuxuan.chai"},{"title":"Mac常用的命令","slug":"Mac常用的命令","date":"2021-02-05T02:48:25.783Z","updated":"2021-02-22T01:43:39.786Z","comments":true,"path":"2021/02/05/Mac常用的命令/","link":"","permalink":"https://cha1yi.github.io/dist/2021/02/05/Mac%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Mac常用的命令查看端口占用： 12$ lsof -i tcp:8080","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://cha1yi.github.io/dist/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://cha1yi.github.io/dist/tags/Mac/"}],"author":"wuxuan.chai"},{"title":"Java SPI机制","slug":"Java SPI机制","date":"2021-02-03T02:14:44.580Z","updated":"2021-02-03T07:28:27.410Z","comments":true,"path":"2021/02/03/Java SPI机制/","link":"","permalink":"https://cha1yi.github.io/dist/2021/02/03/Java%20SPI%E6%9C%BA%E5%88%B6/","excerpt":"","text":"什么是Java SPI参照百度百科的SPI的解释：百度百科 定义 SPI(Service Provider Interface)：是一个内置的java标准，允许不同的开发去实现某个特定的服务，服务提供一个标准的接口及用于提供某种特定的服务的接口 性质 SPI是Java 1.5新添加的一个内置标准，允许不同的开发者去实现某个特定的服务。一个Service就是一个接口或抽象类，而Service Provider是这个Service的一个特定实现类 。 Java SPI的应用一个简单的场景，通过定一个FactoryBean的标准接口，用于生成不同的bean的逻辑。 第一步：定义一个标准的接口 12345678910111213141516171819202122package com.yidan.spi;/** * @author wuxuan.chai * @date 2021/2/2 6:19 下午 */public interface FactoryBeanSpi &#123; /** * 服务实现类单利 * @param tClass 实现类 * @param &lt;T&gt; 类型枚举 * @return 服务实现类单利 */ &lt;T&gt; T getInstance(Class&lt;T&gt; tClass) throws IllegalAccessException, InstantiationException; /** * 服务 * @return 服务 */ String getService();&#125; 第二步：写一个实现类 123456789101112131415161718192021package com.yidan.spi.services;import com.yidan.spi.FactoryBeanSpi;/** * @author wuxuan.chai * @date 2021/2/2 6:24 下午 */public class MySpiFactoryBean implements FactoryBeanSpi &#123; @Override public &lt;T&gt; T getInstance(Class&lt;T&gt; tClass) throws IllegalAccessException, InstantiationException &#123; System.out.println(&quot;MySpiFactoryBean在构建：&quot; + tClass.getName()); return tClass.newInstance(); &#125; @Override public String getService() &#123; return &quot;MySpiFactoryBean&quot;; &#125;&#125; 第三步：创建SPI的配置文件 在resources目录下创建META-INF/services文件目录，然后根据第一步的接口类全限定名称，创建一个文件，如：com.yidan.spi.FactoryBeanSpi，内容为： 1com.yidan.spi.services.MySpiFactoryBean 这个文件中指定的是我们所描述的实现类的类全限定名，可以有多个实现 第四步：使用SPI去加载我们的实现 12345678910111213141516171819202122232425262728package com.yidan.spi.services;import com.yidan.spi.FactoryBeanSpi;import java.util.Optional;import java.util.ServiceLoader;import java.util.stream.StreamSupport;/** * @author wuxuan.chai * @date 2021/2/2 6:27 下午 */public class MyBeanManager &#123; public static FactoryBeanSpi fetchFactoryBean() &#123; final ServiceLoader&lt;FactoryBeanSpi&gt; mySpiFactoryBeans = ServiceLoader.load(FactoryBeanSpi.class); final Optional&lt;FactoryBeanSpi&gt; factoryBeanOptional = StreamSupport.stream(mySpiFactoryBeans.spliterator(), false).findFirst(); final FactoryBeanSpi factoryBean = factoryBeanOptional.orElseThrow(() -&gt; new RuntimeException(&quot;SPI 加载失败，未找到：&quot; + FactoryBeanSpi.class.getName() + &quot;的实现&quot;)); return factoryBean; &#125; public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; final FactoryBeanSpi mySpiFactoryBean = fetchFactoryBean(); mySpiFactoryBean.getInstance(MyBean.class); final String service = mySpiFactoryBean.getService(); System.out.println(service); &#125;&#125; 在这里面定义了一个MyBean，通过刚才实现的MySpiFactoryBean去构建这个MyBean实例，然后去做个简单的例子。 12345678910111213package com.yidan.spi.services;/** * @author wuxuan.chai * @date 2021/2/2 6:27 下午 */public class MyBean &#123; public MyBean()&#123; System.out.println(&quot;MyBean构造方法&quot;); &#125;&#125; 在MyBeanManager中，fetchFactoryBean的方法中通过调用ServiceLoader.load(FactoryBeanSpi.class);找到所有的在com.yidan.spi.FactoryBeanSpi文件中注册的实现类的对应实例，然后加载到JVM中，然后就能够去使用我们的实现了。 执行结果： 1234MySpiFactoryBean在构建：com.yidan.spi.services.MyBeanMyBean构造方法MySpiFactoryBean 通过这个简单的例子，可以简单阐述了SPI机制的原理以及使用 除此之外，SPI的加载机制还可以支持自定义类加载器，调用如：ServiceLoader.load(Class class,ClassLoader classLoader);这么久意味着，这个SPI是可以动态加载的，如一些应用的插件开发，在设计的时候可以使用SPI机制，设计好插件的接口标准，通过SPI动态加载插件，实现不重启应用并且功能拓展。 Java SPI的用途目前，在我们的日常开发中，接触到的比较多的SPI加载机制应该就是java的java.sql.Driver,本次主要探索下java的驱动标准接口下，各个数据库厂商的驱动实现，以及DriverManager的SPI加载。 在创建数据库连接做查询的时候，我们一般步骤为，加载驱动-&gt;创建连接-&gt;创建预执行查询-&gt;执行查询-&gt;释放连接资源。在JDBC 4.0之前的代码一般都是这么写： 123456789101112131415//加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //创建连接 final Connection connection = DriverManager.getConnection(&quot;数据库jdbcURL&quot;, &quot;数据库username&quot;, &quot;数据库password&quot;); //预执行 final PreparedStatement preparedStatement = connection.prepareStatement(&quot;select 1&quot;); //执行 final ResultSet resultSet = preparedStatement.executeQuery(); while (resultSet.next())&#123; //TODO 获取结果 &#125; //释放资源 preparedStatement.close(); connection.close(); 在这里面我们需要Class.forName将driverClass加载到jvm中，让DriverManager通过发现Driver的实现类，反射获取driver的实例，通过调用driver.acceptUrl,去根据jdbcurl去获取驱动类型匹配driver。 而在JDBC4.0之后不需要这么做了，因为DriverManager默认初始化的时候通过SPI加载了所有的驱动实现类，所以不需要再继续做Class.forName了。下面摘了java.sql.DriverManager的部分代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class DriverManager &#123; /** * 通过检查系统属性JDBC来加载初始的JDBC驱动程序，然后使用&#123;@code ServiceLoader&#125;（SPI）机制 */ static &#123; loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;); &#125; //在加载初始化的驱动中，首先根据环境变量jdbc.drivers去加载驱动，再根据SPI获取驱动实现类，SPI的驱动实现类直接通过AccessController.doPrivileged直接加载到了JVM中，环境变量加载的通过Class.forName加载JVM中，所以我们在调用Driver.getConnection不需要在之前调用Class.forName了 private static void loadInitialDrivers() &#123; String drivers; try &#123; drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty(&quot;jdbc.drivers&quot;); &#125; &#125;); &#125; catch (Exception ex) &#123; drivers = null; &#125; // If the driver is packaged as a Service Provider, load it. // Get all the drivers through the classloader // exposed as a java.sql.Driver.class service. // ServiceLoader.load() replaces the sun.misc.Providers() AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); /* Load these drivers, so that they can be instantiated. * It may be the case that the driver class may not be there * i.e. there may be a packaged driver with the service class * as implementation of java.sql.Driver but the actual class * may be missing. In that case a java.util.ServiceConfigurationError * will be thrown at runtime by the VM trying to locate * and load the service. * * Adding a try catch block to catch those runtime errors * if driver not available in classpath but it&#x27;s * packaged as service and that service is there in classpath. */ try&#123; while(driversIterator.hasNext()) &#123; driversIterator.next(); &#125; &#125; catch(Throwable t) &#123; // Do nothing &#125; return null; &#125; &#125;); println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers); if (drivers == null || drivers.equals(&quot;&quot;)) &#123; return; &#125; String[] driversList = drivers.split(&quot;:&quot;); println(&quot;number of Drivers:&quot; + driversList.length); for (String aDriver : driversList) &#123; try &#123; println(&quot;DriverManager.Initialize: loading &quot; + aDriver); Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); &#125; catch (Exception ex) &#123; println(&quot;DriverManager.Initialize: load failed: &quot; + ex); &#125; &#125; &#125; &#125; 除了java.sql.Driver使用了SPI机制外，Spring中也使用了SPI，后续感兴趣去学习学习，加深对Spring的理解。","categories":[{"name":"Java","slug":"Java","permalink":"https://cha1yi.github.io/dist/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"wuxuan.chai"},{"title":"Spring的事务方式","slug":"Spring的事务方式","date":"2021-02-02T03:30:28.824Z","updated":"2021-02-02T09:02:53.609Z","comments":true,"path":"2021/02/02/Spring的事务方式/","link":"","permalink":"https://cha1yi.github.io/dist/2021/02/02/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Spring的事务管理方式1、编程式事务，在代码中硬编码。（不推荐使用） 2、声明式事务，在配置文件中配置。（推荐使用） 声明式事务的种类：1、基于xml的声明式的事务 12345&lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 2、基于注解的声明式的事务 12345@Transactionalpublic Tag add(Tag tag) &#123; //TODO 数据库持久化操作&#125; Spring事务的隔离级别查看了下，org.springframework.transaction.TransactionDefinition接口，这个接口定义了spring的事务的隔离属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package org.springframework.transaction;import org.springframework.lang.Nullable;/** * 定义与Spring兼容的事务属性的接口。基于类似于EJB CMT属性的传播行为定义。 * &lt;p&gt; * 请注意，除非启动实际的新事务，否则不会应用隔离级别和超时设置。由于只有PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED会导致这种情况， * 因此在其他情况下通常不需要指定这些设置。此外，请注意，并非所有事务管理器都支持这些高级特性，因此在给出非默认值时可能抛出相应的异常。 * &lt;p&gt; * read-only标志适用于任何事务上下文，无论是由实际资源事务支持的事务还是在资源级别上进行非事务操作的事务。在后一种情况下，该标志将只应用于应用程序中的托管资源，例如Hibernate会话。 * * @author Juergen Hoeller * @see PlatformTransactionManager#getTransaction(TransactionDefinition) * @see org.springframework.transaction.support.DefaultTransactionDefinition * @see org.springframework.transaction.interceptor.TransactionAttribute * @since 08.05.2003 */public interface TransactionDefinition &#123; /** * 支持当前事务;如果不存在，则创建一个新的。类似于同名的EJB事务属性。 * 这通常是事务定义的默认设置，通常定义事务同步范围。 */ int PROPAGATION_REQUIRED = 0; /** * 支持当前事务;如果不存在，则以非事务方式执行。类似于同名的EJB事务属性。 * 注意:对于具有事务同步的事务管理器，PROPAGATION_SUPPORTS与完全没有事务略有不同，因为它定义了同步可能适用的事务范围。 * 因此，相同的资源(JDBC连接、Hibernate会话等)将在整个指定范围内共享。请注意，确切的行为取决于事务管理器的实际同步配置! * 一般情况下，请小心使用PROPAGATION_SUPPORTS!特别地，不要依赖于PROPAGATION_REQUIRED或PROPAGATION_REQUIRES_NEW在PROPAGATION_SUPPORTS范围内(这可能会导致运行时的同步冲突)。 * 如果这种嵌套是不可避免的，请确保适当地配置事务管理器(通常切换到“在实际事务上同步”)。 * * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#SYNCHRONIZATION_ON_ACTUAL_TRANSACTION */ int PROPAGATION_SUPPORTS = 1; /** * 支持当前事务;如果当前没有事务存在，则抛出异常。类似于同名的EJB事务属性。 * 注意，PROPAGATION_MANDATORY范围内的事务同步将始终由周围的事务驱动。 */ int PROPAGATION_MANDATORY = 2; /** * 创建一个新事务，挂起当前事务(如果存在的话)。类似于同名的EJB事务属性。 * 注意:实际的事务挂起并不会在所有事务管理器上开箱即用。这尤其适用于org.springframework.transaction.jta.JtaTransactionManager， * 它需要javax.transaction.TransactionManager可用(在标准Java EE中是特定于服务器的)。 * PROPAGATION_REQUIRES_NEW作用域总是定义自己的事务同步。现有的同步将被挂起并适当恢复。 * * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */ int PROPAGATION_REQUIRES_NEW = 3; /** * 不支持当前事务;而是总是以非事务的方式执行。类似于同名的EJB事务属性。 * 注意:实际的事务挂起并不会在所有事务管理器上开箱即用。这尤其适用于org.springframework.transaction.jta.JtaTransactionManager， * 它需要javax.transaction.TransactionManager可用(在标准Java EE中是特定于服务器的)。 * 注意，事务同步在PROPAGATION_NOT_SUPPORTED范围内不可用。现有的同步将被挂起并适当恢复。 * * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */ int PROPAGATION_NOT_SUPPORTED = 4; /** * 不支持当前事务;如果当前事务存在，则抛出异常。类似于同名的EJB事务属性。 * 注意，事务同步在PROPAGATION_NEVER范围内不可用。 */ int PROPAGATION_NEVER = 5; /** * 如果当前事务存在，则在嵌套事务中执行，否则行为类似于PROPAGATION_REQUIRED。EJB中没有类似的特性。 * 注意:嵌套事务的实际创建只能在特定的事务管理器上工作。开箱即用，这只适用于JDBC org.springframework.jdbc.datasource。 * 使用JDBC 3.0驱动程序时使用DataSourceTransactionManager。一些JTA提供者可能也支持嵌套事务。 * * @see org.springframework.jdbc.datasource.DataSourceTransactionManager */ int PROPAGATION_NESTED = 6; /** * 使用基础数据存储的默认隔离级别。 * 所有其他级别都对应JDBC隔离级别。 * * @see java.sql.Connection */ int ISOLATION_DEFAULT = -1; /** * 指示可能发生脏读、不可重复读和幻像读。 * 该级别允许一个事务修改的行在该行的任何更改提交之前被另一个事务读取(“脏读”)。 * 如果任何更改被回滚，则第二个事务将检索无效的行。 * * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED */ int ISOLATION_READ_UNCOMMITTED = 1; // same as java.sql.Connection.TRANSACTION_READ_UNCOMMITTED; /** * 指示阻止脏读;不可重复读取和幻像读取可能会发生。 * 该级别仅禁止事务读取一行中未提交的更改。 * * @see java.sql.Connection#TRANSACTION_READ_COMMITTED */ int ISOLATION_READ_COMMITTED = 2; // same as java.sql.Connection.TRANSACTION_READ_COMMITTED; /** * 指示防止脏读和不可重复读;幻读可能会发生。 * 该级别禁止事务读取未提交更改的行，也禁止这样的情况:一个事务读取一行，第二个事务修改该行，第一个事务重新读取该行，第二次获取不同的值(“不可重复读取”)。 * * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ */ int ISOLATION_REPEATABLE_READ = 4; // same as java.sql.Connection.TRANSACTION_REPEATABLE_READ; /** * 指示防止脏读、不可重复读和幻像读。 * 这个水平进一步包括ISOLATION_REPEATABLE_READ的禁令,禁止在一个事务中读取所有行,满足条件,第二个事务插入一行,满足条件,和第一个事务重新读取相同的条件下,获取额外的“幽灵”在第二行阅读。 * * @see java.sql.Connection#TRANSACTION_SERIALIZABLE */ int ISOLATION_SERIALIZABLE = 8; // same as java.sql.Connection.TRANSACTION_SERIALIZABLE; /** * 使用基础事务系统的默认超时，如果不支持超时，则为none。 * or none if timeouts are not supported. */ int TIMEOUT_DEFAULT = -1; /** * 返回传播行为。 * 必须返回该接口上定义的PROPAGATION_XXX常量之一。默认值是PROPAGATION_REQUIRED。 * * @return the propagation behavior * @see #PROPAGATION_REQUIRED * @see org.springframework.transaction.support.TransactionSynchronizationManager#isActualTransactionActive() */ default int getPropagationBehavior() &#123; return PROPAGATION_REQUIRED; &#125; /** * 返回隔离级别。 * 必须返回该接口中定义的ISOLATION_XXX常量之一。这些常量被设计为匹配java.sql.Connection上相同常量的值。 * 专门设计用于与PROPAGATION_REQUIRED或PROPAGATION_REQUIRES_NEW一起使用，因为它只适用于新启动的事务。 * 如果您希望在参与具有不同隔离级别的现有事务时拒绝隔离级别声明，请考虑将事务管理器上的“validateExistingTransactions”标志切换为“true”。 * 默认值为ISOLATION_DEFAULT。请注意，不支持自定义隔离级别的事务管理器在给出ISOLATION_DEFAULT以外的任何其他级别时将抛出异常。 * * @return the isolation level * @see #ISOLATION_DEFAULT * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setValidateExistingTransaction */ default int getIsolationLevel() &#123; return ISOLATION_DEFAULT; &#125; /** * 返回事务超时。 * 必须返回秒数，或TIMEOUT_DEFAULT。 * 专门设计用于与PROPAGATION_REQUIRED或PROPAGATION_REQUIRES_NEW一起使用，因为它只适用于新启动的事务。 * 请注意，不支持超时的事务管理器在给出TIMEOUT_DEFAULT以外的任何超时时将抛出异常。 * * @return the transaction timeout */ default int getTimeout() &#123; return TIMEOUT_DEFAULT; &#125; /** * 返回是否优化为只读事务。 * 只读标志适用于任何事务上下文，无论是由实际的资源事务(PROPAGATION_REQUIRED/ PROPAGATION_REQUIRES_NEW)支持，还是在资源级别上进行非事务操作(PROPAGATION_SUPPORTS)。 * 在后一种情况下，该标志将只应用于应用程序中的托管资源，例如Hibernate会话。 * 这只是作为实际事务子系统的提示;它不一定会导致写访问尝试失败。不能解释只读提示的事务管理器在请求只读事务时不会抛出异常。 * * @see org.springframework.transaction.support.TransactionSynchronization#beforeCommit(boolean) * @see org.springframework.transaction.support.TransactionSynchronizationManager#isCurrentTransactionReadOnly() */ default boolean isReadOnly() &#123; return false; &#125; /** * 返回此事务的名称。可以为空。 * 这将被用作事务监视器中显示的事务名称(如果适用的话，例如WebLogic的)。 * 在Spring的声明性事务中，公开的名称将是完全限定的类名+ &quot;。+方法名(默认)。 * * @return the name of this transaction (&#123;@code null&#125; by default&#125; * @see org.springframework.transaction.interceptor.TransactionAspectSupport * @see org.springframework.transaction.support.TransactionSynchronizationManager#getCurrentTransactionName() */ @Nullable default String getName() &#123; return null; &#125; // Static builder methods /** * 返回一个不可修改的TransactionDefinition和默认值。 * 出于定制的目的，可以使用可修改的org.springframework.transaction.support。DefaultTransactionDefinition代替。 * * @since 5.2 */ static TransactionDefinition withDefaults() &#123; return StaticTransactionDefinition.INSTANCE; &#125;&#125; 总结： 先简单的回顾下，脏读、幻读与不可重复读的基本概念 脏读、幻读与不可重复读脏读：指一个事务中访问到了另外一个事务未提交的数据 会话1 会话2 begin begin update table set age = 10 where id = 1 select age from table where Id = 1 commit commit 会话1和会话2，同时开启事务，在会话1执行查询之前，会话2对id为1的年龄做了修改，导致会话1在查询id为1的年龄为10，其实会话1期望拿到的是会话2更新前的值，如果会话2回滚事务，则会话1拿到的仍是10，这就是脏读 幻读：一个事务读取2次，得到的记录条数不一致 会话1 会话2 begin begin select age from table where Id &gt; 2 insert into table(id,age)values(5,10) Commit select age from table where Id &gt; 2 commit 会话1事务过程中，会话2插入了一个值，导致两次查询的数据不一致 不可重复读：一个事务读取同一条记录2次，得到的结果不一致 会话1 会话2 begin begin select age from table where Id = 1 update table set age = 10 where id = 1 commit select age from table where Id = 1 commit 会话1事务过程中，会话2更新了一个值，导致两次查询的数据不一致 回到事务的总结： 隔离级别 描述 ISOLATION_DEFAULT 使用基础数据存储的默认隔离级别。所有其他级别都对应JDBC隔离级别。Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别. ISOLATION_READ_UNCOMMITTED 指示可能发生脏读、不可重复读和幻像读。该级别允许一个事务修改的行在该行的任何更改提交之前被另一个事务读取(“脏读”)。如果任何更改被回滚，则第二个事务将检索无效的行。 ISOLATION_READ_COMMITTED 指示阻止脏读;不可重复读取和幻像读取可能会发生。该级别仅禁止事务读取一行中未提交的更改。 ISOLATION_REPEATABLE_READ 指示防止脏读和不可重复读;幻读可能会发生。该级别禁止事务读取未提交更改的行，也禁止这样的情况:一个事务读取一行，第二个事务修改该行，第一个事务重新读取该行，第二次获取不同的值(“不可重复读取”)。 ISOLATION_SERIALIZABLE 指示防止脏读、不可重复读和幻像读。这个水平进一步包括ISOLATION_REPEATABLE_READ的禁令,禁止在一个事务中读取所有行,满足条件,第二个事务插入一行,满足条件,和第一个事务重新读取相同的条件下,获取额外的“幽灵”在第二行阅读。 事务传播行为 描述 PROPAGATION_REQUIRED 支持当前事务;如果不存在，则创建一个新的。类似于同名的EJB事务属性。这通常是事务定义的默认设置，通常定义事务同步范围。 PROPAGATION_SUPPORTS 支持当前事务;如果不存在，则以非事务方式执行。类似于同名的EJB事务属性。 注意:对于具有事务同步的事务管理器，PROPAGATION_SUPPORTS与完全没有事务略有不同，因为它定义了同步可能适用的事务范围。 因此，相同的资源(JDBC连接、Hibernate会话等)将在整个指定范围内共享。请注意，确切的行为取决于事务管理器的实际同步配置! 一般情况下，请小心使用PROPAGATION_SUPPORTS!特别地，不要依赖于PROPAGATION_REQUIRED或PROPAGATION_REQUIRES_NEW在PROPAGATION_SUPPORTS范围内(这可能会导致运行时的同步冲突)。 如果这种嵌套是不可避免的，请确保适当地配置事务管理器(通常切换到“在实际事务上同步”)。 PROPAGATION_MANDATORY 支持当前事务;如果当前没有事务存在，则抛出异常。类似于同名的EJB事务属性。 注意，PROPAGATION_MANDATORY范围内的事务同步将始终由周围的事务驱动。 PROPAGATION_REQUIRES_NEW 不支持当前事务;创建一个新事务，挂起当前事务(如果存在的话)。类似于同名的EJB事务属性。 注意:实际的事务挂起并不会在所有事务管理器上开箱即用。这尤其适用于org.springframework.transaction.jta.JtaTransactionManager， 它需要javax.transaction.TransactionManager可用(在标准Java EE中是特定于服务器的)。 PROPAGATION_REQUIRES_NEW作用域总是定义自己的事务同步。现有的同步将被挂起并适当恢复 PROPAGATION_NOT_SUPPORTED 不支持当前事务;而是总是以非事务的方式执行。类似于同名的EJB事务属性。 注意:实际的事务挂起并不会在所有事务管理器上开箱即用。这尤其适用于org.springframework.transaction.jta.JtaTransactionManager， 它需要javax.transaction.TransactionManager可用(在标准Java EE中是特定于服务器的)。 注意，事务同步在PROPAGATION_NOT_SUPPORTED范围内不可用。现有的同步将被挂起并适当恢复。 PROPAGATION_NEVER 不支持当前事务;如果当前事务存在，则抛出异常。类似于同名的EJB事务属性。 注意，事务同步在PROPAGATION_NEVER范围内不可用 PROPAGATION_NESTED 如果当前事务存在，则在嵌套事务中执行，否则行为类似于PROPAGATION_REQUIRED。EJB中没有类似的特性。 注意:嵌套事务的实际创建只能在特定的事务管理器上工作。开箱即用，这只适用于JDBC org.springframework.jdbc.datasource。 使用JDBC 3.0驱动程序时使用DataSourceTransactionManager。一些JTA提供者可能也支持嵌套事务。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"}],"author":"wuxuan.chai"},{"title":"Spring的Bean的生命周期","slug":"Spring的Bean的生命周期","date":"2021-02-01T07:13:00.918Z","updated":"2021-02-02T03:22:57.647Z","comments":true,"path":"2021/02/01/Spring的Bean的生命周期/","link":"","permalink":"https://cha1yi.github.io/dist/2021/02/01/Spring%E7%9A%84Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"Spring的Bean的生命周期一、生命周期流程图Spring bean 的完整生命周期从创建Spring容器开始，直到最终Spring 容器销毁Bean，这其中包含的一些了的关键点（Spring Bean 的生命周期） 在Spring的5.x版本中，通过BeanFactory的类注释，发现他对Spring Bean生命周期做了详细的描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359package org.springframework.beans.factory;import org.springframework.beans.BeansException;import org.springframework.core.ResolvableType;import org.springframework.lang.Nullable;/** * The root interface for accessing a Spring bean container. * * &lt;p&gt;This is the basic client view of a bean container; * further interfaces such as &#123;@link ListableBeanFactory&#125; and * &#123;@link org.springframework.beans.factory.config.ConfigurableBeanFactory&#125; * are available for specific purposes. * * &lt;p&gt;This interface is implemented by objects that hold a number of bean definitions, * each uniquely identified by a String name. Depending on the bean definition, * the factory will return either an independent instance of a contained object * (the Prototype design pattern), or a single shared instance (a superior * alternative to the Singleton design pattern, in which the instance is a * singleton in the scope of the factory). Which type of instance will be returned * depends on the bean factory configuration: the API is the same. Since Spring * 2.0, further scopes are available depending on the concrete application * context (e.g. &quot;request&quot; and &quot;session&quot; scopes in a web environment). * * &lt;p&gt;The point of this approach is that the BeanFactory is a central registry * of application components, and centralizes configuration of application * components (no more do individual objects need to read properties files, * for example). See chapters 4 and 11 of &quot;Expert One-on-One J2EE Design and * Development&quot; for a discussion of the benefits of this approach. * * &lt;p&gt;Note that it is generally better to rely on Dependency Injection * (&quot;push&quot; configuration) to configure application objects through setters * or constructors, rather than use any form of &quot;pull&quot; configuration like a * BeanFactory lookup. Spring&#x27;s Dependency Injection functionality is * implemented using this BeanFactory interface and its subinterfaces. * * &lt;p&gt;Normally a BeanFactory will load bean definitions stored in a configuration * source (such as an XML document), and use the &#123;@code org.springframework.beans&#125; * package to configure the beans. However, an implementation could simply return * Java objects it creates as necessary directly in Java code. There are no * constraints on how the definitions could be stored: LDAP, RDBMS, XML, * properties file, etc. Implementations are encouraged to support references * amongst beans (Dependency Injection). * * &lt;p&gt;In contrast to the methods in &#123;@link ListableBeanFactory&#125;, all of the * operations in this interface will also check parent factories if this is a * &#123;@link HierarchicalBeanFactory&#125;. If a bean is not found in this factory instance, * the immediate parent factory will be asked. Beans in this factory instance * are supposed to override beans of the same name in any parent factory. * * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces * as far as possible. The full set of initialization methods and their standard order is: * &lt;ol&gt; * &lt;li&gt;BeanNameAware&#x27;s &#123;@code setBeanName&#125; * &lt;li&gt;BeanClassLoaderAware&#x27;s &#123;@code setBeanClassLoader&#125; * &lt;li&gt;BeanFactoryAware&#x27;s &#123;@code setBeanFactory&#125; * &lt;li&gt;EnvironmentAware&#x27;s &#123;@code setEnvironment&#125; * &lt;li&gt;EmbeddedValueResolverAware&#x27;s &#123;@code setEmbeddedValueResolver&#125; * &lt;li&gt;ResourceLoaderAware&#x27;s &#123;@code setResourceLoader&#125; * (only applicable when running in an application context) * &lt;li&gt;ApplicationEventPublisherAware&#x27;s &#123;@code setApplicationEventPublisher&#125; * (only applicable when running in an application context) * &lt;li&gt;MessageSourceAware&#x27;s &#123;@code setMessageSource&#125; * (only applicable when running in an application context) * &lt;li&gt;ApplicationContextAware&#x27;s &#123;@code setApplicationContext&#125; * (only applicable when running in an application context) * &lt;li&gt;ServletContextAware&#x27;s &#123;@code setServletContext&#125; * (only applicable when running in a web application context) * &lt;li&gt;&#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors * &lt;li&gt;InitializingBean&#x27;s &#123;@code afterPropertiesSet&#125; * &lt;li&gt;a custom init-method definition * &lt;li&gt;&#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors * &lt;/ol&gt; * * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply: * &lt;ol&gt; * &lt;li&gt;&#123;@code postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors * &lt;li&gt;DisposableBean&#x27;s &#123;@code destroy&#125; * &lt;li&gt;a custom destroy-method definition * &lt;/ol&gt; * * @author Rod Johnson * @author Juergen Hoeller * @author Chris Beams * @since 13 April 2001 * @see BeanNameAware#setBeanName * @see BeanClassLoaderAware#setBeanClassLoader * @see BeanFactoryAware#setBeanFactory * @see org.springframework.context.ResourceLoaderAware#setResourceLoader * @see org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher * @see org.springframework.context.MessageSourceAware#setMessageSource * @see org.springframework.context.ApplicationContextAware#setApplicationContext * @see org.springframework.web.context.ServletContextAware#setServletContext * @see org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization * @see InitializingBean#afterPropertiesSet * @see org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName * @see org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization * @see DisposableBean#destroy * @see org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName */public interface BeanFactory &#123; /** * Used to dereference a &#123;@link FactoryBean&#125; instance and distinguish it from * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named * &#123;@code myJndiObject&#125; is a FactoryBean, getting &#123;@code &amp;myJndiObject&#125; * will return the factory, not the instance returned by the factory. */ String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; /** * Return an instance, which may be shared or independent, of the specified bean. * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the * Singleton or Prototype design pattern. Callers may retain references to * returned objects in the case of Singleton beans. * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to retrieve * @return an instance of the bean * @throws NoSuchBeanDefinitionException if there is no bean with the specified name * @throws BeansException if the bean could not be obtained */ Object getBean(String name) throws BeansException; /** * Return an instance, which may be shared or independent, of the specified bean. * &lt;p&gt;Behaves the same as &#123;@link #getBean(String)&#125;, but provides a measure of type * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the * required type. This means that ClassCastException can&#x27;t be thrown on casting * the result correctly, as can happen with &#123;@link #getBean(String)&#125;. * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to retrieve * @param requiredType type the bean must match; can be an interface or superclass * @return an instance of the bean * @throws NoSuchBeanDefinitionException if there is no such bean definition * @throws BeanNotOfRequiredTypeException if the bean is not of the required type * @throws BeansException if the bean could not be created */ &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; /** * Return an instance, which may be shared or independent, of the specified bean. * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments, * overriding the specified default arguments (if any) in the bean definition. * @param name the name of the bean to retrieve * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @return an instance of the bean * @throws NoSuchBeanDefinitionException if there is no such bean definition * @throws BeanDefinitionStoreException if arguments have been given but * the affected bean isn&#x27;t a prototype * @throws BeansException if the bean could not be created * @since 2.5 */ Object getBean(String name, Object... args) throws BeansException; /** * Return the bean instance that uniquely matches the given object type, if any. * &lt;p&gt;This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory * but may also be translated into a conventional by-name lookup based on the name * of the given type. For more extensive retrieval operations across sets of beans, * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;. * @param requiredType type the bean must match; can be an interface or superclass * @return an instance of the single bean matching the required type * @throws NoSuchBeanDefinitionException if no bean of the given type was found * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found * @throws BeansException if the bean could not be created * @since 3.0 * @see ListableBeanFactory */ &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; /** * Return an instance, which may be shared or independent, of the specified bean. * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments, * overriding the specified default arguments (if any) in the bean definition. * &lt;p&gt;This method goes into &#123;@link ListableBeanFactory&#125; by-type lookup territory * but may also be translated into a conventional by-name lookup based on the name * of the given type. For more extensive retrieval operations across sets of beans, * use &#123;@link ListableBeanFactory&#125; and/or &#123;@link BeanFactoryUtils&#125;. * @param requiredType type the bean must match; can be an interface or superclass * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @return an instance of the bean * @throws NoSuchBeanDefinitionException if there is no such bean definition * @throws BeanDefinitionStoreException if arguments have been given but * the affected bean isn&#x27;t a prototype * @throws BeansException if the bean could not be created * @since 4.1 */ &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; /** * Return a provider for the specified bean, allowing for lazy on-demand retrieval * of instances, including availability and uniqueness options. * @param requiredType type the bean must match; can be an interface or superclass * @return a corresponding provider handle * @since 5.1 * @see #getBeanProvider(ResolvableType) */ &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType); /** * Return a provider for the specified bean, allowing for lazy on-demand retrieval * of instances, including availability and uniqueness options. * @param requiredType type the bean must match; can be a generic type declaration. * Note that collection types are not supported here, in contrast to reflective * injection points. For programmatically retrieving a list of beans matching a * specific type, specify the actual bean type as an argument here and subsequently * use &#123;@link ObjectProvider#orderedStream()&#125; or its lazy streaming/iteration options. * @return a corresponding provider handle * @since 5.1 * @see ObjectProvider#iterator() * @see ObjectProvider#stream() * @see ObjectProvider#orderedStream() */ &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType); /** * Does this bean factory contain a bean definition or externally registered singleton * instance with the given name? * &lt;p&gt;If the given name is an alias, it will be translated back to the corresponding * canonical bean name. * &lt;p&gt;If this factory is hierarchical, will ask any parent factory if the bean cannot * be found in this factory instance. * &lt;p&gt;If a bean definition or singleton instance matching the given name is found, * this method will return &#123;@code true&#125; whether the named bean definition is concrete * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;@code true&#125; * return value from this method does not necessarily indicate that &#123;@link #getBean&#125; * will be able to obtain an instance for the same name. * @param name the name of the bean to query * @return whether a bean with the given name is present */ boolean containsBean(String name); /** * Is this bean a shared singleton? That is, will &#123;@link #getBean&#125; always * return the same instance? * &lt;p&gt;Note: This method returning &#123;@code false&#125; does not clearly indicate * independent instances. It indicates non-singleton instances, which may correspond * to a scoped bean as well. Use the &#123;@link #isPrototype&#125; operation to explicitly * check for independent instances. * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to query * @return whether this bean corresponds to a singleton instance * @throws NoSuchBeanDefinitionException if there is no bean with the given name * @see #getBean * @see #isPrototype */ boolean isSingleton(String name) throws NoSuchBeanDefinitionException; /** * Is this bean a prototype? That is, will &#123;@link #getBean&#125; always return * independent instances? * &lt;p&gt;Note: This method returning &#123;@code false&#125; does not clearly indicate * a singleton object. It indicates non-independent instances, which may correspond * to a scoped bean as well. Use the &#123;@link #isSingleton&#125; operation to explicitly * check for a shared singleton instance. * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to query * @return whether this bean will always deliver independent instances * @throws NoSuchBeanDefinitionException if there is no bean with the given name * @since 2.0.3 * @see #getBean * @see #isSingleton */ boolean isPrototype(String name) throws NoSuchBeanDefinitionException; /** * Check whether the bean with the given name matches the specified type. * More specifically, check whether a &#123;@link #getBean&#125; call for the given name * would return an object that is assignable to the specified target type. * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to query * @param typeToMatch the type to match against (as a &#123;@code ResolvableType&#125;) * @return &#123;@code true&#125; if the bean type matches, * &#123;@code false&#125; if it doesn&#x27;t match or cannot be determined yet * @throws NoSuchBeanDefinitionException if there is no bean with the given name * @since 4.2 * @see #getBean * @see #getType */ boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; /** * Check whether the bean with the given name matches the specified type. * More specifically, check whether a &#123;@link #getBean&#125; call for the given name * would return an object that is assignable to the specified target type. * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to query * @param typeToMatch the type to match against (as a &#123;@code Class&#125;) * @return &#123;@code true&#125; if the bean type matches, * &#123;@code false&#125; if it doesn&#x27;t match or cannot be determined yet * @throws NoSuchBeanDefinitionException if there is no bean with the given name * @since 2.0.1 * @see #getBean * @see #getType */ boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; /** * Determine the type of the bean with the given name. More specifically, * determine the type of object that &#123;@link #getBean&#125; would return for the given name. * &lt;p&gt;For a &#123;@link FactoryBean&#125;, return the type of object that the FactoryBean creates, * as exposed by &#123;@link FactoryBean#getObjectType()&#125;. This may lead to the initialization * of a previously uninitialized &#123;@code FactoryBean&#125; (see &#123;@link #getType(String, boolean)&#125;). * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to query * @return the type of the bean, or &#123;@code null&#125; if not determinable * @throws NoSuchBeanDefinitionException if there is no bean with the given name * @since 1.1.2 * @see #getBean * @see #isTypeMatch */ @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; /** * Determine the type of the bean with the given name. More specifically, * determine the type of object that &#123;@link #getBean&#125; would return for the given name. * &lt;p&gt;For a &#123;@link FactoryBean&#125;, return the type of object that the FactoryBean creates, * as exposed by &#123;@link FactoryBean#getObjectType()&#125;. Depending on the * &#123;@code allowFactoryBeanInit&#125; flag, this may lead to the initialization of a previously * uninitialized &#123;@code FactoryBean&#125; if no early type information is available. * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to query * @param allowFactoryBeanInit whether a &#123;@code FactoryBean&#125; may get initialized * just for the purpose of determining its object type * @return the type of the bean, or &#123;@code null&#125; if not determinable * @throws NoSuchBeanDefinitionException if there is no bean with the given name * @since 5.2 * @see #getBean * @see #isTypeMatch */ @Nullable Class&lt;?&gt; getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException; /** * Return the aliases for the given bean name, if any. * &lt;p&gt;All of those aliases point to the same bean when used in a &#123;@link #getBean&#125; call. * &lt;p&gt;If the given name is an alias, the corresponding original bean name * and other aliases (if any) will be returned, with the original bean name * being the first element in the array. * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the bean name to check for aliases * @return the aliases, or an empty array if none * @see #getBean */ String[] getAliases(String name);&#125; 对BeanFactory的生命周期的内容如下： BeanFactory是访问SpringBean容器的入口。 这是SpringBean容器的基本客户端视图，其他的接口如ListableBeanFactory和ConfigurableBeanFactory是用于其他的特殊场景 这个接口是由包含许多bean定义的对象实现的，每个bean定义都由一个字符串名称唯一标识。根据bean定义，工厂将返回包含对象的独立实例(原型设计模式)，或者单个共享实例(单例设计模式的优越选择，在单例设计模式中，实例是工厂范围内的单例)。返回哪种类型的实例取决于bean工厂配置:API是相同的。自Spring 2.0以来，进一步的作用域取决于具体的应用程序上下文(例如。web环境中的“请求”和“会话”作用域)。 这种方法的要点是BeanFactory是应用程序组件的中心注册中心，并集中应用程序组件的配置(例如，单个对象不再需要读取属性文件)。有关这种方法的好处的讨论，请参阅“专家一对一J2EE设计和开发”的第4章和第11章。 请注意，依赖依赖注入(“推”配置)通过setter或构造函数来配置应用程序对象通常比使用任何形式的“拉”配置(如BeanFactory查找)更好。Spring的依赖项注入功能是使用这个BeanFactory接口及其子接口来实现的。 通常，BeanFactory将加载存储在配置源(如XML文档)中的bean定义，并使用org.springframework。配置bean的bean包。然而，实现可以直接在Java代码中返回它创建的必要Java对象。对于如何存储定义没有任何限制:LDAP、RDBMS、XML、属性文件等等。鼓励实现支持bean之间的引用(依赖注入)。 与ListableBeanFactory中的方法相比，如果这是一个层次结构的beanfactory，那么这个接口中的所有操作都将检查父工厂。如果在这个工厂实例中找不到bean，将询问直接的父工厂。这个工厂实例中的bean应该覆盖任何父工厂中同名的bean Bean工厂实现应该尽可能支持标准的Bean生命周期接口。完整的初始化方法及其标准顺序是: 1、BeanNameAware的setBeanName2、BeanClassLoaderAware的setBeanClassLoader3、BeanFactoryAware的setBeanFactory4、EnvironmentAware的setEnvironment5、EmbeddedValueResolverAware的setEmbeddedValueResolver6、ResourceLoaderAware的setResourceLoader(仅适用于在应用程序上下文中运行时)7、ApplicationEventPublisherAware的setApplicationEventPublisher(仅适用于在应用程序上下文中运行时)8、MessageSourceAware的setMessageSource(仅适用于在应用程序上下文中运行时)9、ApplicationContextAware的setApplicationContext(仅适用于在应用程序上下文中运行时)10、ServletContextAware的setServletContext(仅适用于运行在web应用程序的上下文)11、BeanPostProcessors的postProcessBeforeInitialization方法12、InitializingBean的afterPropertiesSet13、自定义初始化方法定义14、BeanPostProcessors的postProcessAfterInitialization方法 在关闭bean工厂时，应用以下生命周期方法: 1、DestructionAwareBeanPostProcessors的方法postProcessBeforeDestruction2、DisposableBean的销毁3、自定义的销毁方法定义 通过代码观察bean的初始化流程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.yidan.spring.bean.period;import org.springframework.beans.BeansException;import org.springframework.beans.factory.*;/** * @author wuxuan.chai * @date 2021/2/1 4:34 下午 */public class MyBean implements BeanFactoryAware, BeanNameAware, InitializingBean, DisposableBean &#123; private BeanFactory beanFactory; private String beanName; private String service; private String user; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println(&quot;【BeanFactoryAware接口】 调用setBeanFactory&quot;); this.beanFactory = beanFactory; &#125; public MyBean() &#123; System.out.println(&quot;【构造器】调用bean的构造器实例化&quot;); &#125; @Override public void setBeanName(String name) &#123; System.out.println(&quot;【BeanNameAware接口】调用setBeanName&quot;); this.beanName = name; &#125; @Override public void destroy() throws Exception &#123; System.out.println(&quot;【DisposableBean接口】调用destroy&quot;); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;【InitializingBean接口】调用afterPropertiesSet&quot;); &#125; public BeanFactory getBeanFactory() &#123; return beanFactory; &#125; public String getBeanName() &#123; return beanName; &#125; public String getService() &#123; return service; &#125; public void setService(String service) &#123; System.out.println(&quot;【属性注入】service&quot;); this.service = service; &#125; public String getUser() &#123; return user; &#125; public void setUser(String user) &#123; System.out.println(&quot;【属性注入】user&quot;); this.user = user; &#125; public void myInit() &#123; System.out.println(&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;); &#125; public void myDestory() &#123; System.out.println(&quot;【destory-method】调用&lt;bean&gt;的destory-method属性指定的初始化方法&quot;); &#125;&#125; 配置bean的初始化： 1234567891011121314151617181920package com.yidan.spring.bean.period;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author wuxuan.chai * @date 2021/2/2 10:29 上午 */@Configurationpublic class BeanConfig &#123; @Bean(initMethod = &quot;myInit&quot;, destroyMethod = &quot;myDestory&quot;) public MyBean myBean() &#123; final MyBean myBean = new MyBean(); myBean.setService(&quot;well done&quot;); myBean.setUser(&quot;jack&quot;); return myBean; &#125;&#125; 初始化容器，看打印的日志： 123456789101112131415161718192021222324252627282930 . ____ _ __ _ _ &#x2F;\\\\ &#x2F; ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\&#x2F; _&#96; | \\ \\ \\ \\ \\\\&#x2F; ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | &#x2F; &#x2F; &#x2F; &#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F; :: Spring Boot :: (v2.3.0.RELEASE)2021-02-02 11:20:54.928 INFO 10698 --- [ main] com.yidan.spring.bean.Application : Starting Application on chaiwuxuandeMacBook-Pro.local with PID 10698 (&#x2F;Users&#x2F;wuxuan.chai&#x2F;Documents&#x2F;project&#x2F;springboot-learn&#x2F;Spring-bean&#x2F;target&#x2F;classes started by wuxuan.chai in &#x2F;Users&#x2F;wuxuan.chai&#x2F;Documents&#x2F;project&#x2F;springboot-learn)2021-02-02 11:20:54.932 INFO 10698 --- [ main] com.yidan.spring.bean.Application : No active profile set, falling back to default profiles: default2021-02-02 11:20:56.030 INFO 10698 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 1314 (http)2021-02-02 11:20:56.041 INFO 10698 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]2021-02-02 11:20:56.041 INFO 10698 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat&#x2F;9.0.35]2021-02-02 11:20:56.159 INFO 10698 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;] : Initializing Spring embedded WebApplicationContext2021-02-02 11:20:56.159 INFO 10698 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1181 ms【构造器】调用bean的构造器实例化【属性注入】service【属性注入】user【BeanNameAware接口】调用setBeanName【BeanFactoryAware接口】 调用setBeanFactory【InitializingBean接口】调用afterPropertiesSet【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法2021-02-02 11:20:56.448 INFO 10698 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService &#39;applicationTaskExecutor&#39;2021-02-02 11:20:56.679 INFO 10698 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 1314 (http) with context path &#39;&#39;2021-02-02 11:20:56.690 INFO 10698 --- [ main] com.yidan.spring.bean.Application : Started Application in 2.127 seconds (JVM running for 2.751)Disconnected from the target VM, address: &#39;127.0.0.1:59808&#39;, transport: &#39;socket&#39;2021-02-02 11:20:58.684 INFO 10698 --- [extShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &#39;applicationTaskExecutor&#39;【DisposableBean接口】调用destroy【destory-method】调用&lt;bean&gt;的destory-method属性指定的初始化方法","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"}],"author":"wuxuan.chai"},{"title":"算法的时间与空间复杂度","slug":"算法的时间与空间复杂度","date":"2021-01-22T03:40:06.625Z","updated":"2021-01-27T06:10:03.044Z","comments":true,"path":"2021/01/22/算法的时间与空间复杂度/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/22/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"算法的时间与空间复杂度在日常开发过程中，衡量算法的性能，一般都是通过时间复杂度和空间复杂度两个维度去比较，本文就是梳理一下我们是如何计算时间复杂度和空间复杂度的。 时间复杂度时间复杂度：指运行当前算法所消耗的时间，我们通常用【时间复杂度】来描述。 说到时间复杂度，我们第一时间想到的肯定是，算法从执行开始到执行结束所使用的时间。这么想固然是对的，但是仔细品，还是有弊端的。不同的机器运行相同的代码，时间会大不一样，取决于机器的CPU的执行运算的效率。如果机器相同，资源对等的情况下，我们考虑的可能就是代码层面的一些问题就会多一些，此时时间复杂度就是一个重要的评判标准。 一般时间复杂度分为：O(1)、O(n)、O(mlogn)、O(nm) O(1)12345public void o1()&#123; int i = 10; i+=1; System.out.println(i);&#125; O(1)的时间复杂度表示，无论代码执行多少行，只要没有循环结构，代码的时间复杂度都为O(1)。如上述代码，他执行的消耗时间和某个变量的增长是没有关系的，时间复杂度始终为O(1)。 O(n)1234567public void On()&#123; int n = 10; for (int i = 0; i &lt; n; i++) &#123; System.out.println(n); &#125;&#125; O(n)的时间复杂度表示，当n的变化为10时，循环会执行十次，即时间复杂度时随着n的变化而线性变化的。 O(log n)1234567public void logn() &#123; int i = 10; int j = 0; while (j &lt; i) &#123; j *= 2; &#125;&#125; 在上述例子中，每次循环中，j的值都会乘以2(可以认为n)，所以当循环m次后j的值就大于i了，循环就退出了，因此时间复杂度就为 lognm，所以复杂度一般简化为log n O(nm)1234567for (int i = 0; i &lt; n; i++) &#123; for (int i1 = 0; i1 &lt; n; i1++) &#123; j = i; j++; &#125;&#125; 在上述中的例子中，嵌套了两层的n循环，他的时间复杂度就为O(n*n), 即为O(n2)，如果有m层嵌套，那么时间复杂度为O(nm) 如果上述例子中，如果嵌套的循环时间复杂度为O(m),那么整体时间复杂为O(n*m)。 空间复杂度空间复杂度是对一个算法在运行的过程中占用存储空间的一个度量指标，同时反应占用空间的一个趋势。 空间复杂度比较常用的有，O(1),O(n),O(n2) O(1)如果程序运行所需的临时空间不随着某个变量的变化而变化，那么算法的空间复杂度为一个常量 12345int i = 1;int j = 1;++ i;j ++;int m = j + i; 如上述的描述，执行所需的空间和i、j、m没有关系，所以他的空间复杂度为O(1) O(n)12345int[] a &#x3D; new int[n];for (int i &#x3D; 0; i &lt; n; i++) &#123; a[i] &#x3D; i;&#125; 上述的例子中，数组a的空间和n的值成线性关系，即n有多大，数组就有多长，所以内存空间和n是成线性关系，所以空间复杂度为O(n) O(nm)1234567int[] a = new int[n];for (int i = 0; i &lt; n; i++) &#123; for (int ii = 0; i &lt; n; i++) &#123; a[i] = ii; &#125;&#125; 上述例子中，双层循环中数组的长度和n、以及循环的嵌套层m数有关，所以内存空间和n、m的关系为nm,其空间复杂度为：O(nm) 总结这里值是罗列基本的概念，具体的算法复杂度计算大致可以参考这个思路去推断。可能存在误解，后续学习再做改正。","categories":[{"name":"算法","slug":"算法","permalink":"https://cha1yi.github.io/dist/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cha1yi.github.io/dist/tags/%E7%AE%97%E6%B3%95/"}],"author":"wuxuan.chai"},{"title":"GreenPlum的百分位数的实现","slug":"GP的百分位数的实现","date":"2021-01-20T03:11:37.157Z","updated":"2021-01-20T03:12:53.110Z","comments":true,"path":"2021/01/20/GP的百分位数的实现/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/20/GP%E7%9A%84%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"GreenPlum的百分位数的实现一、计算公式 二、实现思路计算百分位数1、确定数组 如下数组： 3710 3755 3850 3880 3880 3890 3920 3940 3950 4050 4130 4325 1 2 3 4 5 6 7 8 9 10 11 12 2、确定数组在有序序列中的位置 3、根据公式，计算百分位数所在的位置 $$Lp = (n +1)p/100$$公式描述： p表示百分数 n表示数组的长度 4、根据公式，计算百分数$$R= Array[Floor(Lp)] + (Lp-Floor(Lp))*(Array[Ceil(Lp)]-Array[Floor(Lp)])$$公式描述： Array[N] 表示数组中位置位N的元素 Floor[N] 表示向零取整 Ceil[N] 表示背零取整 Lp 表示百分数所在的位置 计算百分位1、确定元素在数组中的位置（I） 2、数组的长度表示为，L$$R = 100I/（L+1）$$ 三、PSql去实现这个逻辑计算百分位数1、准备数据 12345678910111213141516171819202122CREATE TABLE &quot;persent_table&quot; ( &quot;keyword&quot; varchar(255) COLLATE &quot;pg_catalog&quot;.&quot;default&quot;, &quot;play_count&quot; float8);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;lol&#x27;, 9.2);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;lol&#x27;, 7.5);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;lol&#x27;, 7.5);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;lol&#x27;, 22);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;lol&#x27;, 50.1);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;lol&#x27;, 6.2);INSERT INTO &quot;persent_table&quot; VALUES (&#x27;lol&#x27;, 9.8);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 223.5);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 208.7);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 122.9);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 68.4);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 49.6);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 47.3);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 43);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 42.4);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 41.6);INSERT INTO &quot;persent_table&quot;(&quot;keyword&quot;, &quot;play_count&quot;) VALUES (&#x27;英雄联盟手游&#x27;, 37); 2、确定数组和每一个数组的位置 将数据按照keyworld分组根据play_count的值从小到大排列 12345SELECT ROW_NUMBER() OVER ( PARTITION BY t1.keyword ORDER BY t1.play_count ASC ) AS seq, * FROM persent_table t1 结果： 3、计算百分位数所在的位置，例子中使用50百分位 12345678910SELECT keyword, 0.5 * ( COUNT ( 1 ) + 1 ) AS number_index, FLOOR (0.5 * ( COUNT ( 1 ) + 1 )) AS min_value, CEIL (0.5 * ( COUNT ( 1 ) + 1 )) AS max_value FROM persent_table WHERE play_count IS NOT NULL GROUP BY keyword 结果： 结果字段解释： number_index: 表示50百分位所对应的数值所在数组中的位置 min_value/max_value:表示50百分位所对应的数值所在的实际数组元素所在的区间 如： keyword为”lol”所对应的play_count的数组中50百分位数位置为4 keyword为“英雄联盟手游“所对应的play_count的数组中50百分位数位置为5和6之间 4、根据公式，计算百分数 123456789101112131415161718192021SELECT t3.keyword, (t2.number_index - FLOOR ( t2.number_index )) * (MAX ( t3.play_count ) - MIN ( t3.play_count )) + MIN ( t3.play_count ) AS persent_val FROM ( SELECT ROW_NUMBER () OVER ( PARTITION BY t1.keyword ORDER BY t1.play_count ASC ) AS seq,* FROM persent_table t1 ) t3 INNER JOIN ( SELECT keyword, 0.5 * ( COUNT ( 1 ) + 1 ) AS number_index, FLOOR (0.5 * ( COUNT ( 1 ) + 1 )) AS min_value, CEIL (0.5 * ( COUNT ( 1 ) + 1 )) AS max_value FROM persent_table WHERE play_count IS NOT NULL GROUP BY keyword ) t2 ON t3.keyword = t2.keyword AND ( seq = max_value OR seq = min_value ) GROUP BY t3.keyword, t2.number_index; 结果： 和步骤2中的数据对比： lol的seq = 4的play_count = 9.2 英雄联盟手游 的 5&lt; seq &lt; 6 的play_count 值区间为：47.3 ～ 49.6 用公式验证 47.3 + 0.5*（49.6 - 47.3）= 48.45 计算百分位1、求分组下的数组长度 123456789SELECT keyword, COUNT ( 1 ) AS count_val FROM persent_table WHERE play_count IS NOT NULL GROUP BY keyword 结果： 2、计算每个数组元素所在的位置的百分位 123456SELECT t1.keyword, 100 * (ROW_NUMBER () OVER ( PARTITION BY t1.keyword ORDER BY t1.play_count DESC )) / ( t2.count_val + 1 ) AS persent FROM persent_table t1 LEFT JOIN ( SELECT keyword, COUNT ( 1 ) AS count_val FROM persent_table WHERE play_count IS NOT NULL GROUP BY keyword ) t2 ON t1.keyword = t2.keyword 结果： 和计算百分位数进行对比：很明显发现lol的位置为4的百分位为50","categories":[{"name":"数据库","slug":"数据库","permalink":"https://cha1yi.github.io/dist/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cha1yi.github.io/dist/tags/%E7%AE%97%E6%B3%95/"},{"name":"SQL","slug":"SQL","permalink":"https://cha1yi.github.io/dist/tags/SQL/"}],"author":"wuxuan.chai"},{"title":"Java的位运算","slug":"java的位运算","date":"2021-01-19T08:37:39.865Z","updated":"2021-01-22T01:48:01.263Z","comments":true,"path":"2021/01/19/java的位运算/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/19/java%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"Java的位运算基础概念位：表示二进制位。是二进制计数系统中用来表示小于2的整数，一般用0或者1表示，是具有相等概率的两种状态的一种，二进制位的位数可以表示一个机器字的字长，一个二进制包含的信息量称之为1bit。 原码：二进制的定点表示法，即高位为符号位，’0’ 表示为正，’1’ 表示为负，其余位表示数值大小。 反码：正数的反码与其原码相同；负数的反码是对正数逐位取反，符号位保持为1。 补码：正数的补码与其原码相同，负数位的补码是在其反码的末位加1。 Practice为什么java中的int类型的值取值范围为：-231 ~ 231-1 ？ Integer占用4byte，1byte占用8bit：最大的正数原码：01111111 11111111 11111111 11111111最小的负数原码：10000000 00000000 00000000 00000000计算机存使用的都是补码：最大的正数的补码：01111111 11111111 11111111 11111111 -&gt; 231-1最大的负数的补码：11111111 11111111 11111111 11111111 +1 -&gt; -231-1 + 1 = -231 原码、反码、补码的产生、以及应用在自然界中，我们计数一般都是从正数计数，比如、一棵树、两头牛、三只羊….不存在负一棵树、负两头牛、负三只羊…都是我们在生产生活中，加入了统计之后才引入了负的概念。 在上面我们了解到，正数的原码、反码、补码都是相同的，而负数的反码是原码的取反，补码是反码+1。是不是觉得反码是针对负数设计的呢？哈哈。。 在计算机中如何处理 -7 + 7 = 0的计算呢？ 以4BIT的数为例，高位作为符号位： 如果从原码的角度-&gt; -7： 1111 7： 0111 如果拿原码做加法计算的话： 1 0110 高位舍去-&gt; 0110 = 6 结果很显然错了！ 如果从反码的角度-&gt; -7: 1000 7: 0111 如果拿反码做加法计算的话： 1111 = -7 结果很显然也是错的！ 如果从补码的角度-&gt; -7: 1001 7: 0111 如果拿补码做加法计算的话： 1 0000 丢到高位的符号位，结果为0 看结果就是这么巧合！！！ 综上，补码是做加减法最好的选择。 说到现在，是不是觉得补码就是为了计算而设计的呢？哈哈。。。 位运算关于位运算，这里运用哲学上三个究极问题试图讲解清楚位运算究竟是何方神圣：什么是位运算？位运算的作用？位运算有什么优势？ 什么是位运算？程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）。下表列出了位运算符的基本运算:假设：两个4bit的数，高位表示符号位，A=3，B=7bit(A)= 0011 bit(B)= 0111 运算符 描述 例子 按位与（&amp;） 如果相对应位都是1，则结果为1，否则为0 A&amp;B=3，即 0011 按位或（｜） 如果相对应位都是0，则结果为0，否则为1 A|B=7, 即 0111 按位异或（^） 如果相对应位值相同，则结果为0，否则为1 A^B= 4, 即 0100 按位取反（~） 按位取反运算符翻转操作数的每一位，即0变成1，1变成0 ~A=-4, 即 1100 左移 （&lt;&lt;） 按位左移运算符。左操作数按位左移右操作数指定的位数 A&lt;&lt;2=-4, 即 1100 右移 （&gt;&gt;） 按位右移运算符。左操作数按位右移右操作数指定的位数 B&gt;&gt;2=1, 即0001 位运算的作用？位运算其实在我们日常开发过程中经常会忽略掉，因为我们习惯了使用int或者long值进行计算，而忽略了底层的计算逻辑。找一个使用了位运算的代码研究下：copy自java.long.Integer的静态方法 12345678910111213141516171819/** * 返回一个int值，最多一个1位，位于指定int值的最高(&quot;最左&quot;)1位的位置。如果指定的值在其2的补码二进制表示中没有1位，也就是说，如果它等于0，则返回0。. * * @param i the value whose highest one bit is to be computed * @return an &#123;@code int&#125; value with a single one-bit, in the position * of the highest-order one-bit in the specified value, or zero if * the specified value is itself equal to zero. * @since 1.5 */public static int highestOneBit(int i) &#123; // HD, Figure 3-1 i |= (i &gt;&gt; 1); i |= (i &gt;&gt; 2); i |= (i &gt;&gt; 4); i |= (i &gt;&gt; 8); i |= (i &gt;&gt; 16); return i - (i &gt;&gt;&gt; 1);&#125; 方法流程： 123456789101112131415public static int highestOneBit(int i) &#123; //输入的i = 17 -&gt; 00000000 00000000 00000000 00010001 int left = i &gt;&gt; 1; // 00000000 00000000 00000000 00001000 i = i | left; //00000000 00000000 00000000 00011001 1 +8 +16 = 25 left = i &gt;&gt; 2; //00000000 00000000 00000000 0000110 i = i | left; //00000000 00000000 00000000 00011111 1+2+4+8+16 =31 left = i &gt;&gt; 4;//00000000 00000000 00000000 00000001 i = i | left; //00000000 00000000 00000000 00011111 31 left = i &gt;&gt; 8; //00000000 00000000 00000000 00000000 i = i | left; // 00000000 00000000 00000000 00011111 left = i &gt;&gt; 16; //00000000 00000000 00000000 00000000 i = i | left; //00000000 00000000 00000000 00011111 1+2+4+8+16 = 31 final int i1 = i &gt;&gt;&gt; 1; //00000000 00000000 00000000 00001111 1+2+4+8=15 return i-i1; // 31 -15 = 16&#125; 通过上述代码可以知道，这个过程其实就是一个求最高位的值，比如17的最高位是16，通过不断的右移做或运算，将17的除高位意外的其他位全部填为1，得到最终的i，然后通过i-i&gt;&gt;&gt;1得到高位的值 位运算有什么优势？通过上面的代码，可以看到位运算是很容易解决这种看似非常复杂的逻辑，另一方面如果从数据学计算的角度，我们可能需要引用其他的辅助参数和对象，去对其做计算可能会更加复杂。位运算是计算机的最容易读懂的计算逻辑，所以速度性能是最好的。 总结计算机的位运算设计真的是博大精深，我深深受其计算逻辑所折服，通过对二进制位运算的学习，加深了对位运算的印象，可能存在一些错误的理解，欢迎指正，不甚感激。","categories":[{"name":"Java","slug":"Java","permalink":"https://cha1yi.github.io/dist/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cha1yi.github.io/dist/tags/%E7%AE%97%E6%B3%95/"}],"author":"wuxuan.chai"},{"title":"Docker相关命令","slug":"Docker相关命令","date":"2021-01-18T14:39:45.626Z","updated":"2021-01-18T14:41:59.581Z","comments":true,"path":"2021/01/18/Docker相关命令/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Docker%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Docker访问mac宿主机器的ip通过域名的访问： script1docker.for.mac.host.internal","categories":[{"name":"Docker","slug":"Docker","permalink":"https://cha1yi.github.io/dist/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://cha1yi.github.io/dist/tags/docker/"}],"author":"wuxuan.chai"},{"title":"Presto从入门到放弃","slug":"Presto从入门到放弃","date":"2021-01-18T14:31:26.572Z","updated":"2021-02-22T01:46:24.006Z","comments":true,"path":"2021/01/18/Presto从入门到放弃/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Presto%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/","excerpt":"","text":"Prestto从入门到放弃presto安装环境：在自己的mac上通过docker，安装一个docker单机版的presto，学习presto的基本使用。 script1docker pull prestosql/presto 运行presto: script1docker run -p 1314:8080 --name presto prestosql/presto 启动成功后日志会打印：INFO main io.prestosql.server.PrestoServer ======== SERVER STARTED ======== 运行 Presto CLI script1docker exec -it presto presto presto常用命令增加catalog123456789101112131415# 进入presto的docker容器根目录docker exec -it ee418177a59e bash # 进入catalog的配置目录cd /data/presto/etc/catalog# 新增catalogvi mysql5.properties加入mysql5的配置---connector.name = mysqlconnection-url = jdbc:mysql://docker.for.mac.host.internal:3305connection-user = rootconnection-password = ch199407---保存配置，重启presto 注意： 1、connector.name=mysql 表示connector的类型，presto支持mysql、redis、hive。。。 也可以自定义connector，需要额外开发 2、配置文件位mysql5.properties，那么重启之后，presto中就会有一个mysql5的catalog，配置文件和catalog是一一对应的。 展示catalog123456789101112131415161718192021#进入presto的clidocker exec -it presto presto#展示所有的catalogshow catalogs&gt; Catalog --------- jmx memory mysql5 mysql8 system tpcds tpch (7 rows)Query 20210119_152711_00021_nvbet, FINISHED, 1 nodeSplits: 19 total, 19 done (100.00%)1.41 [0 rows, 0B] [0 rows/s, 0B/s]","categories":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://cha1yi.github.io/dist/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://cha1yi.github.io/dist/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"}],"author":"wuxuan.chai"},{"title":"记kafka启动失败","slug":"kafka错误处理解决总结","date":"2021-01-18T02:19:33.851Z","updated":"2021-01-18T02:22:01.165Z","comments":true,"path":"2021/01/18/kafka错误处理解决总结/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/kafka%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%A7%A3%E5%86%B3%E6%80%BB%E7%BB%93/","excerpt":"","text":"场景在项目开发中，需要使用到kafka，但是无论如何本地环境的kafka都无法启动，zookeeper状态是正常的，kafka就是起不来，导致项目的日志消费的任务一直阻塞。重新启动会发生异常：InconsistentClusterIdException。 异常的信息1234567ERROR Fatal error during KafkaServer startup. Prepare to shutdown (kafka.server.KafkaServer)kafka.common.InconsistentClusterIdException: The Cluster ID F-bhGf-3T1qgjuQ0c1wCRw doesn&#39;t match stored clusterId Some(FO2XIwDrSSiJSeWo4B80hQ) in meta.properties. The broker is trying to join the wrong cluster. Configured zookeeper.connect may be wrong. at kafka.server.KafkaServer.startup(KafkaServer.scala:223) at kafka.server.KafkaServerStartable.startup(KafkaServerStartable.scala:44) at kafka.Kafka$.main(Kafka.scala:82) at kafka.Kafka.main(Kafka.scala) .... 原因分析及解决方案kafka的配置日志路径，用来保存kafka的执行过程中的信息，如果kafka异常关闭，日志记录就会出现异常，会把当时的情况记录在meta.properties文件中，重启时，此文件会对启动产生影响。原因是，里面记录了borker 和cluster-id,导致的报错。 解决方式 清空日志目录【日志不重要或可以容忍日志丢失】。 调整日志目录【需要修改配置】。 删除日志目录下的meta.properties文件。","categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://cha1yi.github.io/dist/tags/kafka/"}],"author":"wuxuan.chai"},{"title":"CentOS7常用命令","slug":"CentOS7常用命令","date":"2021-01-18T02:18:08.079Z","updated":"2021-02-22T01:45:00.020Z","comments":true,"path":"2021/01/18/CentOS7常用命令/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/CentOS7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"CentOS7常用命令1、服务器之间copy文件12# 将文件spark-3.0.1-bin-hadoop2.7.tgz copy到node1机器的/home/wuxuan/package/目录下$ scp spark-3.0.1-bin-hadoop2.7.tgz wuxuan@node1:/home/wuxuan/package/ 2、防火墙相关操作123456789101112#查看防火墙状态$ firewall-cmd --state# 关闭防火墙$ systemctl stop firewalld.service# 启动防火墙$ systemctl start firewalld.service# 重启网卡$ systemctl restart network.service CentOS之间设置免密访问一、准备阶段准备两台机器：192.168.100.11 node1192.168.100.12 node2 二、设置hosts在每台机器中设置hosts 123456$ vim /etc/hosts#添加hosts192.168.100.11 node1 192.168.100.12 node2 三、每台机器设置hostname（主机名称）设置hostname 12345678# 登陆到192.168.100.11$ hostname node1# 登陆到192.168.100.12$ hostname node2 四、给每台机器生成ssh密钥1234567891011121314151617# 登陆到192.168.100.11$ cd /root/.ssh$ ssh-keygen -t rsa$ lsid_rsa id_rsa.pub# 将机器的公钥备份$ cp id_rsa.pub &gt;&gt; authorized_keys# 将文件传输给机器192.168.100.12$ scp authorized_keys root@node2:/root/.ssh/# 登陆到192.168.100.12 $ hostname node2$ cat id_rsa.pub &gt;&gt; authorized_keys 到此node2的authorized_keys包含node1和node2的公钥重复此操作，即可实现node1和node2的免密访问 测试: 12$ ssh node2Last login: Fri Nov 13 16:01:17 2020 from node1","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://cha1yi.github.io/dist/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://cha1yi.github.io/dist/tags/CentOS/"}],"author":"wuxuan.chai"},{"title":"SpringBoot自定义starter","slug":"SpringBoot自定义starter","date":"2021-01-18T01:57:06.360Z","updated":"2021-02-22T01:41:55.570Z","comments":true,"path":"2021/01/18/SpringBoot自定义starter/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/","excerpt":"","text":"SpringBoot自定义starter学习背景&nbsp;&nbsp;最近和同事在开发一个叫做数据准备的项目，用到了SpringBoot（ps：之前的项目用的是ssm，第一次正式使用SpringBoot）,现在对于这种开箱即用的SpringBoot-Starter感到无比的惊叹，需要使用某个中间件，只需引入然后附加少许配置即可投入生产。今天就开始学习一下SpringBoot的starter的开发规范。 Starter的构成1、命名创建一个工程叫做Flyway-spring-boot-starter Spring 官方对 starter 的命名是有规范的，只有官方提供的 starter, 才能命名为 spring-boot-starter-{name}, 比如 spring-boot-starter-web; 而对于非官方的，需以 {name}-spring-boot-starter 的格式命名。 2、增加Spring-Boot-AutoConfiguration依赖123456&lt;!-- 自动化配置依赖，自定义 starter 核心依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt; 3、新增自动配置类&nbsp;&nbsp;创建类 FlyWayAutoConfiguration 来实现自动配置化功能 12345678910111213141516171819202122232425package com.yidan.flyway;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author wuxuan.chai * @date 2020/10/19 5:57 下午 */@Configuration@ConditionalOnClass(SelfService.class)@EnableConfigurationProperties(SelfProperties.class)public class FlyWayAutoConfiguration &#123; @Bean @ConditionalOnMissingBean public SelfService selfService() &#123; return new SelfService(); &#125;&#125; 接下来，对上面相关注解说明一下：@Configuration: 标注类为一个配置类，让 spring 去扫描它；@ConditionalOnClass：条件注解，只有在 classpath 路径下存在指定 class 文件时，才会实例化 Bean；@EnableConfigurationProperties：使指定配置类生效；@Bean: 创建一个实例类注入到 Spring Ioc 容器中；@ConditionalOnMissingBean：条件注解，意思是，仅当 Ioc 容器不存在指定类型的 Bean 时，才会创建 Bean。 4、自定义配置类及功能实现创建自定义配置类 SelfProperties 123456789101112131415161718192021package com.yidan.flyway;import org.springframework.boot.context.properties.ConfigurationProperties;/** * @author wuxuan.chai * @date 2020/10/19 6:01 下午 */@ConfigurationProperties(prefix = &quot;flyway.self&quot;)public class SelfProperties &#123; private String message = &quot;hello flyway&quot;; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 创建SelfService业务方法 1234567891011121314151617package com.yidan.flyway;import javax.annotation.Resource;/** * @author wuxuan.chai * @date 2020/10/19 6:04 下午 */public class SelfService &#123; @Resource private SelfProperties selfProperties; public String message() &#123; return selfProperties.getMessage(); &#125;&#125; 5、创建spring.factories文件&nbsp;&nbsp;在resource目录下创建META-INF目录，在该目录下创建spring.factories文件。Spring Boot 会在启动时，自动会去查找指定文件 /META-INF/spring.factories，若有，就会根据配置的类的全路径去自动化配置。 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.yidan.flyway.FlywayAutoConfiguration 6、自定义的配置信息元数据描述我们在开发SpringBoot的项目时，在写application.properties(或application.yml)时，IDEA会自动智能提醒，key和value的值。它是如何做到的呢？在Spring的官方文档中有相对应的介绍SpringBoot自定义配置详解 在Resourse目录下的META-INF 创建:spring-configuration-metadata.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;groups&quot;: [ &#123; &quot;sourceType&quot;: &quot;com.yidan.flyway.SelfProperties&quot;, &quot;type&quot;: &quot;com.yidan.flyway.SelfProperties&quot;, &quot;name&quot;: &quot;flyway.self&quot; &#125; ], &quot;hints&quot;: [ &#123; &quot;name&quot;: &quot;flyway.self.message&quot;, &quot;values&quot;: [ &#123; &quot;value&quot;:&quot;hello flyway&quot;, &quot;description&quot;: &quot;第一个值&quot; &#125;, &#123; &quot;value&quot;: &quot;hello configuration&quot;, &quot;description&quot;: &quot;第二个值&quot; &#125; ], &quot;providers&quot;: [ &#123; &quot;name&quot;: &quot;flyway starter&quot;, &quot;parameters&quot;: &quot;123&quot; &#125; ] &#125; ], &quot;properties&quot;: [ &#123; &quot;name&quot;: &quot;flyway.self.message&quot;, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;description&quot;: &quot;自定义的配置&quot;, &quot;sourceType&quot;: &quot;com.yidan.flyway.SelfProperties&quot;, &quot;defaultValue&quot;: &quot;hello flyway&quot;, &quot;deprecation&quot;: &#123; &quot;level&quot;: &quot;warning&quot;, &quot;reason&quot;: &quot;测试忽略理由&quot;, &quot;replacement&quot;: &quot;hello configuration&quot; &#125; &#125; ]&#125; 项目使用引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.yidan&lt;/groupId&gt; &lt;artifactId&gt;flyway-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;&lt;/dependency&gt; 使用我们自动装配的bean： SelfService, 修改配置文件中：flyway.self.message=hello configuration （此时IDEA会自动提示我们自定义的key，甚至有值的推荐） 1234567891011121314151617181920212223package com.yidan.passport;import com.yidan.flyway.SelfService;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @author wuxuan.chai * @date 2020/10/19 6:08 下午 */@RestControllerpublic class TestController &#123; @Resource private SelfService selfService; @GetMapping(&quot;/get&quot;) public String message() &#123; return selfService.message(); &#125;&#125; 测试： 12$ curl http:&#x2F;&#x2F;localhost:6002&#x2F;gethello configuration 完，后续遇到再做补充！！！","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"}],"author":"wuxuan.chai"},{"title":"SpringBoot单元测试整理","slug":"SpringBoot测试系统整理","date":"2021-01-18T01:56:07.559Z","updated":"2021-02-22T01:41:42.177Z","comments":true,"path":"2021/01/18/SpringBoot测试系统整理/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/SpringBoot%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/","excerpt":"","text":"SpringBoot单元测试整理Spring boot 作为当前最流行的java后端开发框架，集成了很多非常有用的东西，今天探索：Springboot test引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 一、测试方式的整理1.1、单元测试在维基百科中的解释： 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 例如在开发过程中，我们一般都是这么做单元测试的： 12345678public class UtilsTest &#123; @Test public void testStringBuilder()&#123; String result = new StringBuilder().append(1).append(1).toString(); assert &quot;11&quot;.equals(result); &#125;&#125; 通常来说，开发每当修改一次方法，都会重新进行单元测试，以保证程序的方法是正确的。虽然单元测试在开发过程中不是必须的，但是对于开发来说是非常有必要的，属于开发自测的一种非常实用的手段，减少代码出现bug的机率。 1.2、集成测试 集成测试（有时称为集成和测试(Integration Testing)，缩写为I＆T）是软件测试的阶段，在该阶段中，将各个软件模块组合在一起并作为一个整体进行测试。集成测试中进行评估依从性的系统或部件的与指定的功能要求。[1]它发生在单元测试之后和验证测试之前。集成测试以经过单元测试的输入模块为准，将它们按较大的聚合分组，应用集成测试计划中定义的测试这些聚合，并提供集成系统作为系统测试准备就绪的输出。 集成测试和单元测试的区别在于，单元测试仅仅测试的一般是一个方法(单元)，不涉及到方法组合测试，因此集成测试将完成多个单元的组合测试，以测试在具有业务场景的逻辑下进行的测试集成，所以一般单元测试在集成测试之前。 1.3、Mock测试Mock测试属于一种特殊的测试场景，在开发的过程中，可能由于协同开发的原因，自己需要测试自己开发的业务，但是业务中又依赖了同事开发的一些功能。按照正常的测试逻辑，可能会出现无法正常的完成测试需求，甚至代码都无法执行，此时就可以使用Mock测试的方法方法。Mock测试的原理大致为：如果测试的方法依赖未知的对象时，可以通过Mock去抽象这个未知的对象，并对未知的对象的方法进行抽象返回我们想要的数据，以供我们的测试使用。以此完成我们的方法测试需求。Spring Boot的测试模块支持Mock测试和junit测试。因此我们在SpringBoot开发时，可以在引入了Springboot测试模块后直接享受Mock测试和Junit单元测试带来的便利。 二、Springboot常用的测试方法2.1、测试普通工具方法所谓普通的方法，类似于工具类中的工具方法，不依赖于任何外部环境，例如Spring上下文信息，redis template，Mysql jdbc等。那么我们可以直接使用Junit对其进行测试。 1234567public class UtilsTest &#123; @Test public void testStringBuilder()&#123; String result = new StringBuilder().append(1).append(1).toString(); assert &quot;11&quot;.equals(result); &#125;&#125; 2.3、测试业务方法在Spring中的业务方法，都是通过IOC直接注入到Spring 容器中的，简单的使用Junit是无法直接执行的，必须指定Spring的上下文信息，保证其运行时能够从Spring容器中获取到对应的依赖Bean。例如： 1234567891011121314151617@SpringBootTest@RunWith(SpringRunner.class)public class CarServiceTest &#123; @Autowired public CarService carService; @Test @Rollback @Transactional public void testAdd()&#123; Car car = new Car(); car.setType(&quot;SUV&quot;); car.setName(&quot;BMW&quot;); car = carService.add(car); System.out.println(car); &#125;&#125; 测试CarService中的一个add方法，并且注入了CarService的Bean，@Transactional 开启了该方法的事务，@Rollback的意思是，执行玩测试方法，事务回滚，即不会修改数据库的数据。@Rollback必须配合@Transactional ，也就是只有事务开启了，才会生效。 2.3、测试Restful接口在开发过程中，需要测试提供给前端的接口，一般有两种方式： postman：好处能够和对应的google插件一起配合使用，共享google浏览器的cookie信息 MockMvc的方式：好处就是纯代码测试，可以控制数据入库，也能得到更详细请求数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@SpringBootTest@RunWith(SpringRunner.class)public class CarControllerTest &#123; private MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setupMockMvc()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125; @SneakyThrows @Test public void testListCar()&#123; mockMvc.perform(get(&quot;/car/list/&quot;)).andDo(MockMvcResultHandlers.print()); &#125; @SneakyThrows @Test @Rollback @Transactional public void testAdd()&#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;name\\&quot;: \\&quot;BMW\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;SUV\\&quot;\\n&quot; + &quot;&#125;&quot;; mockMvc.perform(post(&quot;/car/&quot;).accept(MediaType.APPLICATION_JSON_VALUE).content(json).contentType(MediaType.APPLICATION_JSON_VALUE)) .andDo(MockMvcResultHandlers.print()); &#125;&#125;//测试的结果： /** * * MockHttpServletRequest: * HTTP Method = POST * Request URI = /car/ * Parameters = &#123;&#125; * Headers = [Content-Type:&quot;application/json&quot;, Accept:&quot;application/json&quot;, Content-Length:&quot;40&quot;] * Body = &lt;no character encoding set&gt; * Session Attrs = &#123;&#125; * * Handler: * Type = com.yiyi.controller.CarController * Method = com.yiyi.controller.CarController#add(Car) * * Async: * Async started = false * Async result = null * * Resolved Exception: * Type = null * * ModelAndView: * View name = null * View = null * Model = null * * FlashMap: * Attributes = null * * MockHttpServletResponse: * Status = 200 * Error message = null * Headers = [Content-Type:&quot;application/json&quot;] * Content type = application/json * Body = &#123;&quot;id&quot;:27,&quot;name&quot;:&quot;BMW&quot;,&quot;type&quot;:&quot;SUV&quot;&#125; * Forwarded URL = null * Redirected URL = null * Cookies = [] */ 在面的测试例子中，做了两件事：1、开启了Springboot的测试，初始化了Spring的上下文环境2、通过web上下文，初始化了MockMvc的Bean，便于接口的请求 2.4、特殊场景下，自定义配置的测试2.4.1、指定profile的方式新增配置文件application-test.xml将@ActiveProfiles设置为test，在运行测试时，将会按照上面的配置文件进行初始化Spring bean 12345678910111213141516171819202122232425@SpringBootTest@RunWith(SpringRunner.class)@ActiveProfiles(&quot;test&quot;)public class CarServiceTest &#123; @Autowired public CarService carService; @Value(&quot;$&#123;test.value&#125;&quot;) private int value; @Test public void testAdd()&#123; Car car = new Car(); car.setType(&quot;SUV&quot;); car.setName(&quot;BMW&quot;); car = carService.add(car); System.out.println(car); &#125; @Test public void testGetValue()&#123; assert value == 2; &#125;&#125; 2.5、Mock测试的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@SpringBootTest@RunWith(SpringRunner.class)public class MockTest &#123; @MockBean private CarService carService; public MockMvc mockMvc; @Autowired public WebApplicationContext context; @Before public void setUp()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @SneakyThrows @Test public void testAddCar()&#123; //测试添加CarController 的addCar接口，使用MockBean模拟的CarService的Bean Car car = new Car(); car.setId(111L); car.setName(&quot;BYD&quot;); car.setType(&quot;SUV&quot;); Car car1 = new Car(); //期望调用addCar方法传入一个car1返回一个car的对象，对象的数据为 id=111L，name=BYD， type=SUV Mockito.when(carService.add(car1)).thenReturn(car); String json = &quot;&#123;&#125;&quot;; mockMvc.perform(post(&quot;/car/&quot;).accept(MediaType.APPLICATION_JSON_VALUE).content(json).contentType(MediaType.APPLICATION_JSON_VALUE)) .andDo(MockMvcResultHandlers.print()); //执行结果： /** * MockHttpServletRequest: * HTTP Method = POST * Request URI = /car/ * Parameters = &#123;&#125; * Headers = [Content-Type:&quot;application/json&quot;, Accept:&quot;application/json&quot;, Content-Length:&quot;2&quot;] * Body = &lt;no character encoding set&gt; * Session Attrs = &#123;&#125; * * Handler: * Type = com.yiyi.controller.CarController * Method = com.yiyi.controller.CarController#add(Car) * * Async: * Async started = false * Async result = null * * Resolved Exception: * Type = null * * ModelAndView: * View name = null * View = null * Model = null * * FlashMap: * Attributes = null * * MockHttpServletResponse: * Status = 200 * Error message = null * Headers = [Content-Type:&quot;application/json&quot;] * Content type = application/json * Body = &#123;&quot;id&quot;:111,&quot;name&quot;:&quot;BYD&quot;,&quot;type&quot;:&quot;SUV&quot;&#125; * Forwarded URL = null * Redirected URL = null * Cookies = [] */ &#125;&#125; 在这个测试代码中，模拟了一个CarService的bean，并且模拟了CarService#add(car)的方法参数及返回的结果。所以Controller的接口调用依赖了这个模拟的方法，所以返回的结果和我们预期模拟的结果是一致的。针对于上面的例子，如果在不mock的方法的前提下调用Mock出来的CarSerVice#list()方法，结果会是什么呢？回去执行原本的Spring的代理方法操作数据库还是报错呢？ 123456789101112131415161718192021222324252627282930313233@SpringBootTest@RunWith(SpringRunner.class)public class MockTest &#123; @MockBean private CarService carService; public MockMvc mockMvc; @Autowired public WebApplicationContext context; @Before public void setUp()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void testList()&#123; Car car = new Car(); car.setName(&quot;BYD&quot;); car.setType(&quot;SUV&quot;); Car car1 = carService.add(car); System.out.println(&quot;car：&quot;+car1); List&lt;Car&gt; list = carService.list(); System.out.println(&quot;carList:&quot;+list); //result: /** * car：null * carList:[] */ &#125;&#125; 结果表明:没有执行数据库的操作，而是mock返回的是方法的默认值。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"}],"author":"wuxuan.chai"},{"title":"Spring事件驱动模型","slug":"Spring事件驱动模型","date":"2021-01-18T01:52:51.420Z","updated":"2021-01-18T01:56:37.009Z","comments":true,"path":"2021/01/18/Spring事件驱动模型/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Spring%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"一、Spring 事件驱动的简介事件驱动模型，简单理解就是发布-订阅模型，Spring针对这种发布-订阅模型作出了两种解决方案，应用间的发布-订阅模型，可以使用Spring AMQP和 Spring for Apache Kafka，结合Rabbit或者kafka等消息中间件完成。应用内的发布-订阅模型，可以使用Spring 的Application上下文提供的方案解决。这篇文章主要描述Spring 的应用内的事件驱动的实现以及应用。 二、Spring 应用内的事件驱动模型示例2.1、需求背景页面埋点，收集用户访问信息，并记录到数据库，并且根据用户的PV，作出适当的商品邮件推送 2.2、需求拆解 前端需要收集用户在当前页面的访问信息，调用后端提供的埋点接口，将数据提供给后端处理。（前端功能不做示例） 后端的埋点接口，调用发布消息的方法（发布事件） 后端需要开发对应的事件订阅方法，将事件解析并持久化，以及作出适当的邮件推送2.3、代码实现1、埋点接口12345678910111213141516171819202122232425262728293031package com.yiyi;import com.yiyi.service.MyEventService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * @author wuxuan.chai * @date 2020/6/22 12:59 下午 */@RestController@RequestMapping(value = &quot;/&quot;,produces = MediaType.APPLICATION_JSON_VALUE)public class EventController &#123; private final MyEventService myEventService; @Autowired public EventController(MyEventService myEventService) &#123; this.myEventService = myEventService; &#125; @PutMapping(&quot;send/&quot;) public void sendMessage(@RequestParam String msg)&#123; myEventService.publishEvent(msg); &#125;&#125; 2、定义事件接受类12345678910111213141516171819202122232425262728package com.yiyi.event;import lombok.Getter;import org.springframework.context.ApplicationEvent;/** * @author wuxuan.chai * @date 2020/6/22 12:51 下午 */@Getterpublic class MyEvent extends ApplicationEvent &#123; //前端的埋点收集信息 private String msg; /** * Create a new &#123;@code ApplicationEvent&#125;. * * @param source the object on which the event initially occurred or with * which the event is associated (never &#123;@code null&#125;) */ public MyEvent(Object source) &#123; super(source); &#125; public MyEvent(Object source, String msg) &#123; super(source); this.msg = msg; &#125;&#125; 3、发布事件12345678910111213141516171819202122232425262728package com.yiyi.service;import com.yiyi.event.MyEvent;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;/** * @author wuxuan.chai * @date 2020/6/22 12:52 下午 */@Componentpublic class MyEventService implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; //发布事件 public void publishEvent(String msg)&#123; MyEvent myEvent = new MyEvent(this,msg); applicationContext.publishEvent(myEvent); &#125;&#125; 4.订阅事件 12345678910111213141516171819202122232425package com.yiyi.compoent;import com.yiyi.event.MyEvent;import lombok.extern.slf4j.Slf4j;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;/** * @author wuxuan.chai * @date 2020/6/22 12:55 下午 */@Component@Slf4jpublic class EventListenerComponent &#123; @EventListener public void getEvent(MyEvent myEvent) &#123; log.info(&quot;持久化用户的浏览记录：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener public void sendEmail(MyEvent myEvent) &#123; log.info(&quot;发送Email：&#123;&#125;&quot;, myEvent.getMsg()); &#125;&#125; 5、执行结果 1232020-06-22 18:01:25.599 INFO 14040 --- [nio-1234-exec-2] c.yiyi.compoent.EventListenerComponent : 持久化用户的浏览记录：查看了华为Mate40 pro2020-06-22 18:01:25.599 INFO 14040 --- [nio-1234-exec-2] c.yiyi.compoent.EventListenerComponent : 发送Email：查看了华为Mate40 pro 2.4、实现优化的思考及实现方法1、如何提高埋点的并发？答：Spring 提供了方法异步执行的功能，需要开启异步执行—–@EnableAsync。然后通过@Async开启订阅者异步消费事件，异步执行的本质，就是将方法的执行的逻辑放到一个单独的线程中去执行。示例：(1)、开启异步执行 12345678910111213141516171819202122232425262728293031323334353637383940package com.yiyi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.AsyncConfigurer;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import java.util.concurrent.Executor;import java.util.concurrent.ThreadPoolExecutor;/** * @author wuxuan.chai * @date 2020/6/22 1:27 下午 */@Configuration@EnableAsyncpublic class AsyncListenerConfig implements AsyncConfigurer &#123; //定义一个线程池 @Override @Bean(name = &quot;taskExecutor&quot;) public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.initialize(); //设置核心线程数 executor.setCorePoolSize(10); //设置最大线程数 executor.setMaxPoolSize(20); //设置队列的大小 executor.setQueueCapacity(1000); //设置最大的线程空闲时间 executor.setKeepAliveSeconds(300); //设置线程名称 executor.setThreadNamePrefix(&quot;event-executor-&quot;); //拒绝策略 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); return new ExceptionHandlingAsyncTaskExecutor(executor); &#125;&#125; (2)、设置异步执行的任务执行器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.yiyi.config;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.core.task.AsyncTaskExecutor;import java.util.concurrent.Callable;import java.util.concurrent.Future;/** * 用独立的线程来包装，类似与@Async * @author wuxuan.chai * @date 2020/6/22 2:58 下午 */@AllArgsConstructor@NoArgsConstructor@Slf4jpublic class HandlingAsyncTaskExecutor implements AsyncTaskExecutor &#123; public AsyncTaskExecutor executor; @Override public void execute(Runnable task, long startTimeout) &#123; executor.execute(createWrappedRunnable(task), startTimeout); &#125; @Override public void execute(Runnable task) &#123; executor.execute(createWrappedRunnable(task)); &#125; @Override public Future&lt;?&gt; submit(Runnable task) &#123; return executor.submit(createWrappedRunnable(task)); &#125; @Override public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; return executor.submit(createCallable(task)); &#125; private &lt;T&gt; Callable&lt;T&gt; createCallable(final Callable&lt;T&gt; callable) &#123; return () -&gt; &#123; try &#123; return callable.call(); &#125; catch (Exception e) &#123; handle(e); throw e; &#125; &#125;; &#125; private Runnable createWrappedRunnable(Runnable task) &#123; return () -&gt; &#123; try &#123; task.run(); &#125; catch (Exception e) &#123; handle(e); throw e; &#125; &#125;; &#125; private void handle(Exception e) &#123; log.error(&quot;异步执行报错：&#123;&#125;&quot;, e.getMessage(), e); &#125;&#125; (3)、异步消费事件 12345678910111213141516171819202122232425262728package com.yiyi.compoent;import com.yiyi.event.MyEvent;import lombok.extern.slf4j.Slf4j;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;import org.springframework.scheduling.annotation.Async;/** * @author wuxuan.chai * @date 2020/6/22 12:55 下午 */@Component@Slf4jpublic class EventListenerComponent &#123; @EventListener @Async public void getEvent(MyEvent myEvent) &#123; log.info(&quot;持久化用户的浏览记录：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener @Async public void sendEmail(MyEvent myEvent) &#123; log.info(&quot;发送Email：&#123;&#125;&quot;, myEvent.getMsg()); &#125;&#125; 至此，发送邮件和持久化浏览记录都是异步执行的了，埋点接口的http链接会立即释放。对于执行埋点的接口执行来讲，能够多支持一些并发，当然可以在此基础上继续优化，例如批量持久化，批量发送email等。最大限度的利用线程。 2、如果持久化失败了，如何做到不让邮件发送？答：在之前开发的CRUD中，我们避免程序错误导致脏库，一般在做DML操作的时候，都会加入事务。与之类似，订阅者也会有事务的概念。示例：发布事件，添加事务 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.service;import com.yiyi.domain.EventDomain;import com.yiyi.domain.EventMapper;import com.yiyi.event.MyEvent;import org.springframework.beans.BeansException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;/** * @author wuxuan.chai * @date 2020/6/22 12:52 下午 */@Componentpublic class MyEventService implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Autowired private EventMapper eventMapper; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @Transactional(rollbackFor = Exception.class) public void publishEvent(String msg) throws Exception &#123; MyEvent myEvent = new MyEvent(this,msg); applicationContext.publishEvent(myEvent); EventDomain eventDomain = new EventDomain(); eventDomain.setMessage(msg); eventMapper.save(eventDomain); throw new Exception(&quot;error！&quot;); &#125;&#125; 订阅事件，给getEventSecond方法添加事务监听注解 12345678910111213141516171819202122232425262728293031323334package com.yiyi.compoent;import com.yiyi.event.MyEvent;import lombok.extern.slf4j.Slf4j;import org.springframework.context.event.EventListener;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import org.springframework.transaction.event.TransactionalEventListener;/** * @author wuxuan.chai * @date 2020/6/22 12:55 下午 */@Component@Slf4jpublic class EventListenerComponent &#123; @EventListener @Order(2) public void getEventFirst(MyEvent myEvent) &#123; log.info(&quot;我是第一个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @TransactionalEventListener @Order(1) public void getEventSecond(MyEvent myEvent) &#123; log.info(&quot;我是第二个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener @Order(3) public void getEventThird(MyEvent myEvent) &#123; log.info(&quot;我是第三个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125;&#125; 执行结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768692020-06-22 22:12:42.980 INFO 14373 --- [nio-1234-exec-3] c.yiyi.compoent.EventListenerComponent : 我是第一个收到消息：查看了华为Mate40 pro2020-06-22 22:12:42.980 INFO 14373 --- [nio-1234-exec-3] c.yiyi.compoent.EventListenerComponent : 我是第三个收到消息：查看了华为Mate40 proHibernate: select next_val as id_val from hibernate_sequence for updateHibernate: update hibernate_sequence set next_val= ? where next_val=?java.lang.Exception: error！ at com.yiyi.service.MyEventService.publishEvent(MyEventService.java:36) at com.yiyi.service.MyEventService$$FastClassBySpringCGLIB$$f3a92ba1.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) at com.yiyi.service.MyEventService$$EnhancerBySpringCGLIB$$fb19b4c8.publishEvent(&lt;generated&gt;) at com.yiyi.EventController.sendMessage(EventController.java:29) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920) at javax.servlet.http.HttpServlet.service(HttpServlet.java:663) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) 通过上述的执行结果很容易看出，@TransactionalEventListener注解所在的方法是在发布者的事务完成之后进行调用的，而且执行的顺序落后于@EventListener。除此之外，@EventListener，不管发布者事务是否提交，都会执行订阅的逻辑。:::tip订阅执行的顺序：@EventListener&gt;@EventListener+@Async&gt;@TransactionalEventListener::: 3、如何保持订阅被有序执行？答：Spring提供@Order的枚举，通过这个我们可以给订阅者设置顺序，那么在消费事件的时候，就会遵循这个顺序。示例： 1234567891011121314151617181920212223242526272829303132package com.yiyi.compoent;import com.yiyi.event.MyEvent;import lombok.extern.slf4j.Slf4j;import org.springframework.context.event.EventListener;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;/** * @author wuxuan.chai * @date 2020/6/22 12:55 下午 */@Component@Slf4jpublic class EventListenerComponent &#123; @EventListener @Order(2) public void getEventFirst(MyEvent myEvent) &#123; log.info(&quot;我是第一个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener @Order(1) public void getEventSecond(MyEvent myEvent) &#123; log.info(&quot;我是第二个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener @Order(3) public void getEventThird(MyEvent myEvent) &#123; log.info(&quot;我是第三个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125;&#125; 执行结果： 1232020-06-22 18:30:34.689 INFO 14195 --- [nio-1234-exec-1] c.yiyi.compoent.EventListenerComponent : 我是第二个收到消息：查看了华为Mate40 pro2020-06-22 18:30:34.691 INFO 14195 --- [nio-1234-exec-1] c.yiyi.compoent.EventListenerComponent : 我是第一个收到消息：查看了华为Mate40 pro2020-06-22 18:30:34.691 INFO 14195 --- [nio-1234-exec-1] c.yiyi.compoent.EventListenerComponent : 我是第三个收到消息：查看了华为Mate40 pro 三、Spring 事件驱动的原理","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"},{"name":"事件驱动","slug":"事件驱动","permalink":"https://cha1yi.github.io/dist/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"}],"author":"wuxuan.chai"},{"title":"Spring Cache 源码学习，自定义CacheManager","slug":"Spring Cache 源码学习，自定义CacheManager","date":"2021-01-18T01:48:30.711Z","updated":"2021-02-22T01:42:31.433Z","comments":true,"path":"2021/01/18/Spring Cache 源码学习，自定义CacheManager/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Spring%20Cache%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89CacheManager/","excerpt":"","text":"Spring Cache 源码学习，自定义CacheManager一、学习背景&emsp;&emsp;最近一直在学习Spring boot的框架，因为之前一直接触的都是Spring + Spring mvc + mybatis的ssm框架，对于约定大于配置的这种开发理念还是不太熟悉和上手，所以决定系统学习下Springboot。最近在看项目代码，对代码中Spring cache的一些自定义拓展很感兴趣，所以就好好整理下。（基于Spring 5.2.6-release 版本） 二、Spring Cache的源码学习2.1、Spring Cache的核心接口2.1.1、Cache123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package org.springframework.cache;import java.util.concurrent.Callable;import org.springframework.lang.Nullable;/** * 定义通用缓存操作的接口。 * * &lt;b&gt;注意：&lt;/b&gt;由于缓存的一般用法，建议实现允许存储&lt;tt&gt; null &lt;/tt&gt;值（例如，存储返回&#123;@code null&#125;的方法）。 * * @author Costin Leau * @author Juergen Hoeller * @author Stephane Nicoll * @since 3.1 */public interface Cache &#123; /** * 返回缓存的名称 */ String getName(); /** * 返回基础本机缓存提供程序。这里是指缓存实现类对象,返回类型为Class&lt;T extend Cache&gt; class */ Object getNativeCache(); /** * 返回此缓存将指定键映射到的值。 &lt;p&gt;如果缓存不包含该键的映射，则返回&#123;@code null&#125;； 否则，缓存的值（本身可能为&#123;@code null&#125;）将在&#123;@link * ValueWrapper&#125;中返回。 * @param key 要返回其关联值的key * @return 此缓存将指定键映射到的值，该值包含在&#123;@link ValueWrapper&#125;中，该值也可以保存缓存的&#123;@code null&#125;值。 直接返回&#123;@code null&#125;表示缓* 存不包含该键的映射。 * @see #get(Object, Class) * @see #get(Object, Callable) */ @Nullable ValueWrapper get(Object key); /** * 返回此缓存将指定键映射到的值，通常指定返回值将强制转换为的类型。 &lt;p&gt;注意：&#123;@code get&#125;的此变体不允许区分已缓存的&#123;@code null&#125;值和根本找不 * 到缓存条目。 为此，请使用标准的&#123;@link #get(Object）&#125;变体。 * @param key 要返回其关联值的key * @param type 需要返回值的类型（可以为&#123;@code null&#125;来绕过类型检查；如果在缓存中找到&#123;@code null&#125;值，则指定的类型无关紧要） * @return 此高速缓存将指定键映射到的值（本身可以是&#123;@code null&#125;），如果高速缓存不包含此键的映射，则还可以是&#123;@code null&#125; * @throws IllegalStateException 如果找到了高速缓存条目但未能匹配指定的类型 * @since 4.0 * @see #get(Object) */ @Nullable &lt;T&gt; T get(Object key, @Nullable Class&lt;T&gt; type); /** * 返回此缓存将指定键映射到的值，并在必要时从&#123;@code valueLoader&#125;获取该值。 此方法为常规的“如果已缓存，则返回；否则创建，缓存并返回”模式提供 * 了简单的替代方法。 &lt;p&gt;如果可能，实现应确保加载操作是同步的，以便在同时访问同一键的情况下，仅调用一次指定的&#123;@code valueLoader&#125;。 &lt;p&gt;如果 *&#123;@code valueLoader&#125;引发异常，则将其包装在&#123;@link ValueRetrievalException&#125;中 * @param key 要返回其关联值的key * @return 此缓存将指定键映射到的值 * @throws ValueRetrievalException 如果&#123;@code valueLoader&#125;抛出异常 * @since 4.3 * @see #get(Object) */ @Nullable &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader); /** * 将指定的值与此高速缓存中的指定键相关联。 &lt;p&gt;如果高速缓存先前包含此键的映射，则旧值将由指定值替换。 &lt;p&gt;可以以异步或延迟的方式执行实际注册，随 * 后的查找可能仍未看到该条目。 例如，事务性缓存装饰器可能就是这种情况。 使用&#123;@link #putIfAbsent&#125;保证立即注册。 * @param key the key with which the specified value is to be associated * @param value the value to be associated with the specified key * @see #putIfAbsent(Object, Object) */ void put(Object key, @Nullable Object value); /** * 如果尚未将指定值与该高速缓存中的指定键原子关联，则该值尚未设置。 &lt;p&gt;这等效于：&lt;pre&gt; &lt;code&gt; ValueWrapper existingValue = cache.get（key）; 如果（existingValue == null）&#123;cache.put（key，value）; 返回现存值； &lt;/ code&gt; &lt;/ pre&gt;，但该操作是原子执行的。 虽然所有开箱即用的&#123;@link CacheManager&#125;实现都可以自动执行放置，但操作也可以分两个步骤实现，例如 以非原子方式检查存在性并随后放置。 有关更多详细信息，请查看所使用的本机缓存实现的文档。 &lt;p&gt;默认实现沿着上面的代码片段委托给&#123;@link #get（Object）&#125;和&#123;@link #put（Object，Object）&#125;。 * @param key 与指定值关联的键 * @param value 与指定键关联的值 * @return 此缓存将指定键映射到的值（本身可能是&#123;@code null&#125;），如果在此调用之前缓存不包含该键的任何映射，则还为&#123;@code null&#125;。 因此，返回&#123;@code null&#125;表示给定的&#123;@code value&#125;已与密钥相关联。 * @since 4.1 * @see #put(Object, Object) */ @Nullable default ValueWrapper putIfAbsent(Object key, @Nullable Object value) &#123; ValueWrapper existingValue = get(key); if (existingValue == null) &#123; put(key, value); &#125; return existingValue; &#125; /** * 如果存在，请从此缓存中退出此键的映射。 &lt;p&gt;可以以异步或延迟的方式执行实际逐出，随后的查找可能仍会看到该条目。 例如，事务性缓存装饰器可能就是这种情况。 使用&#123;@link #evictIfPresent&#125;确保立即删除。 * @param key 要从缓存中删除其映射的键 * @see #evictIfPresent(Object) */ void evict(Object key); /** * 如果存在此键，则从此缓存中退出该键的映射，并期望该键对于后续查找立即不可见。 &lt;p&gt;默认实现委派给&#123;@link #evict（Object）&#125;，对于未确定的先前存在的键，返回&#123;@code false&#125;。 鼓励高速缓存提供者，尤其是高速缓存装饰器，如果可能的话（例如，在事务中通常延迟的高速缓存操作的情况下）执行立即驱逐并可靠地确定给定密钥的先前存在。 * @param key 要从缓存中删除其映射的键 * @return &#123;@code true&#125;（如果以前知道缓存对此键有映射），&#123;@ code false&#125;（如果没有）（或者无法确定先前的存在） * @since 5.2 * @see #evict(Object) */ default boolean evictIfPresent(Object key) &#123; evict(key); return false; &#125; /** * 通过删除所有映射来清除缓存。 &lt;p&gt;可以以异步或延迟的方式执行实际清除，随后的查找可能仍会看到条目。 例如，事务性缓存装饰器可能就是这种情况。 使用&#123;@link #invalidate（）&#125;可以确保立即删除条目。 * @see #invalidate() */ void clear(); /** * 通过删除所有映射来使缓存无效，并期望所有条目对于随后的查找立即不可见。 @return &#123;@code true&#125;（如果以前知道该缓存具有映射），&#123;@ code false&#125;（如果没有）（或者如果无法确定先前是否存在条目） * @since 5.2 * @see #clear() */ default boolean invalidate() &#123; clear(); return false; &#125; /** * 代表缓存值的（包装）对象。 */ @FunctionalInterface interface ValueWrapper &#123; /** * 返回缓存中的实际值。 */ @Nullable Object get(); &#125; /** * 如果值加载程序回调因异常而失败，则从&#123;@link #get(Object，Callable）&#125;引发包装器异常。 * @since 4.3 */ @SuppressWarnings(&quot;serial&quot;) class ValueRetrievalException extends RuntimeException &#123; @Nullable private final Object key; public ValueRetrievalException(@Nullable Object key, Callable&lt;?&gt; loader, Throwable ex) &#123; super(String.format(&quot;Value for key &#x27;%s&#x27; could not be loaded using &#x27;%s&#x27;&quot;, key, loader), ex); this.key = key; &#125; @Nullable public Object getKey() &#123; return this.key; &#125; &#125;&#125; 2.1.2、CacheManager12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.cache;import java.util.Collection;import org.springframework.lang.Nullable;/** * Spring的中央缓存管理器SPI。 * * &lt;p&gt;允许检索命名的&#123;@link Cache&#125;区域。 * * @author Costin Leau * @author Sam Brannen * @since 3.1 */public interface CacheManager &#123; /** * 获取与给定名称关联的缓存。 &lt;p&gt;请注意，如果本机提供程序支持，则缓存可能会在运行时延迟创建。 * @param name 缓存标识符（不得为&#123;@code null&#125;） * @return 关联的缓存，如果不存在或无法创建，则为&#123;@code null&#125; */ @Nullable Cache getCache(String name); /** * 获取此管理器已知的缓存名称的集合。 * @return 缓存管理器已知的所有缓存的名称 */ Collection&lt;String&gt; getCacheNames();&#125; 2.1.3、Cache相关的注解Spring cache 为了方便我们对缓存的使用，提供了五个比较有用的注解： @Cacheable @CachePut @CacheEvict @Caching @CacheConfig 2.1.3.1、@Cacheable源码注释翻译： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.concurrent.Callable;import org.springframework.core.annotation.AliasFor;/** * 标注可以缓存调用方法（或类中的所有方法）结果的注释。 * * &lt;p&gt;每次调用建议的方法时，都会应用缓存行为，检查是否已为给定参数调用了该方法。 通常默认设置只是使用方法参数来计算密钥，但是可以通过&#123;@link #key&#125;属性提供SpEL表达式，或者自定义&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125;实现可以替换 默认值之一（请参见&#123;@link #keyGenerator&#125;）。 * * &lt;p&gt;如果在高速缓存中找不到所计算键的值，则将调用目标方法，并将返回的值存储在关联的高速缓存中。 请注意，Java8的&#123;@code Optional&#125;返回类型是自动处理的，并且其内容存储在缓存中（如果存在）。 * * &lt;p&gt;此注释可用作&lt;em&gt;元注释&lt;/ em&gt;，以创建具有属性覆盖的自定义&lt;em&gt;组成的注释&lt;/ em&gt;。 * * @author Costin Leau * @author Phillip Webb * @author Stephane Nicoll * @author Sam Brannen * @since 3.1 * @see CacheConfig */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Cacheable &#123; /** * 缓存名称的别名 */ @AliasFor(&quot;cacheNames&quot;) String[] value() default &#123;&#125;; /** * 存储方法调用结果的缓存的名称。 * &lt;p&gt;名称可用于确定目标缓存（或多个缓存），与特定Bean定义的限定符值或Bean名称匹配。 * @since 4.2 * @see #value * @see CacheConfig#cacheNames */ @AliasFor(&quot;value&quot;) String[] cacheNames() default &#123;&#125;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String key() default &quot;&quot;; /** * 要使用的自定义&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125;的bean名称。 &lt;p&gt;与&#123;@link #key&#125;属性互斥。 * @see CacheConfig#keyGenerator */ String keyGenerator() default &quot;&quot;; /** * 自定义&#123;@link org.springframework.cache.CacheManager&#125;的bean名称，用于创建默认的&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;（如果尚未设置）。 * &lt;p&gt;与&#123;@link #cacheResolver&#125;属性互斥。 * @see org.springframework.cache.interceptor.SimpleCacheResolver * @see CacheConfig#cacheManager */ String cacheManager() default &quot;&quot;; /** * 要使用的定制&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;的bean名称。 * @see CacheConfig#cacheResolver */ String cacheResolver() default &quot;&quot;; /** * Spring表达式语言（SpEL）表达式，用于使方法缓存成为条件。 * &lt;p&gt;默认值为&#123;@code“”&#125;，这意味着方法结果始终被缓存。 * &lt;p&gt; SpEL表达式根据提供以下元数据的专用上下文进行评估：&lt;ul&gt; * &lt;li&gt; &#123;@ code＃root.method&#125;，&#123;@ code＃root.target&#125;和&#123;@code #root。 缓存&#125;，分别引用&#123;@link java.lang.reflect.Method方法&#125;，目标对象和受影响的缓存。&lt;/li&gt; * &lt;li&gt;方法名称的快捷方式（&#123;@code＃root.methodName &#125;）和目标类别（&#123;@code＃root.targetClass&#125;）也可用。 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args [1]&#125;，&#123;@ code＃p1&#125;或&#123;@code＃a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; &lt;/ ul&gt; */ String condition() default &quot;&quot;; /** * Spring表达式语言（SpEL）表达式用于否决方法缓存。 * &lt;p&gt;与&#123;@link #condition&#125;不同，此表达式是在调用方法后求值的，因此可以引用&#123;@code result&#125;。 * &lt;p&gt;默认值为&#123;@code“”&#125;，表示永远不会否决缓存。 * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; * @since 3.2 */ String unless() default &quot;&quot;; /** * 如果多个线程试图为同一键加载值，则同步基础方法的调用。 同步带来了两个限制： * &lt;ol&gt; * &lt;li&gt;不支持&#123;@link #unless（）&#125;&lt;/li&gt; * &lt;li&gt;只能指定一个缓存&lt;/li&gt; * &lt;li&gt;不能合并其他与缓存相关的操作&lt;/li&gt; * &lt;/ol&gt; * 这实际上是一个提示，您正在使用的实际缓存提供程序可能不以同步方式支持它。 检查您的提供程序文档，以获取有关实际语义的更多详细信息。 * @since 4.3 * @see org.springframework.cache.Cache#get(Object, Callable) */ boolean sync() default false;&#125; 主要参数 描述 用法 value cacheNames 的别名 @Cacheable(“mysqlCache”) cacheNames 缓存的名称 @Cacheable(cacheNames = MysqlCache.NAME) key 缓存的key，支持Spring EL 表达式 @Cacheable(cacheNames = MysqlCache.NAME, key = “‘CacheDemoService-get’+ args[0]”) @Cacheable(cacheNames = MysqlCache.NAME, key = “‘CacheDemoService-get’+ #p0”) @Cacheable(cacheNames = MysqlCache.NAME, key = “‘CacheDemoService-get’+ #a0”) keyGenerator key的构造器，和key属性互斥 需要定义一个customerKeyGenerator的bean @Cacheable(cacheNames = MysqlCache.NAME, keyGenerator = “customerKeyGenerator”) cacheManager 指定CacheManager，需要先定义CacheManager的bean，指定后则不能指定cacheResolver，两者互斥，如不指定，则使用注入的默认的CacheManagerBean @Cacheable(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”） cacheResolver 指定cacheResolver的bean的名称，和cacheManager互斥 暂时未做测试 condition 是否使用方法缓存条件，默认“”，是否去取方法缓存，在方法执行之前计算条件结果 @Cacheable(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,condition=“#a0 == ‘xx’”) unless 否决方法的结果缓存，默认“”，始终缓存方法，如果条件不成立则不缓存方法结果，在方法执行结果后计算条件结果 @Cacheable(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,unless=“#a0 == ‘xx’”) sync 多线程访问方法，是否同步缓存，默认值为false，使用有三个限制，不支持unless，只能指定一个缓存，不能与@Caching一起使用 @Cacheable(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,sync=false) 2.1.3.2、@CachePut源码注释翻译： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;/** * 指示方法（或类中的所有方法）触发&#123;@link org.springframework.cache.Cache＃put(Object，Object）cache put&#125;操作的注释。 * * &lt;p&gt;与&#123;@link Cacheable @Cacheable&#125;注释相反，此注释不会导致建议的方法被跳过。 而是，它总是使方法被调用并将其结果存储在关联的缓存中。 请注意，Java8的&#123;@code Optional&#125;返回类型是自动处理的，并且其内容存储在缓存中（如果存在）。 * * &lt;p&gt;此注释可用作&lt;em&gt;元注释&lt;/ em&gt;，以创建具有属性覆盖的自定义&lt;em&gt;组成的注释&lt;/ em&gt;。 * * @author Costin Leau * @author Phillip Webb * @author Stephane Nicoll * @author Sam Brannen * @since 3.1 * @see CacheConfig */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CachePut &#123; /** * 别名&#123;@link #cacheNames&#125;. */ @AliasFor(&quot;cacheNames&quot;) String[] value() default &#123;&#125;; /** * 用于缓存放置操作的缓存名称。 * &lt;p&gt;名称可以用来确定目标缓存（或多个缓存），与特定bean定义的限定符值或bean名称匹配。 * @since 4.2 * @see #value * @see CacheConfig#cacheNames */ @AliasFor(&quot;value&quot;) String[] cacheNames() default &#123;&#125;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String key() default &quot;&quot;; /** * 要使用的自定义&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125;的bean名称。 &lt;p&gt;与&#123;@link #key&#125;属性互斥。 * @see CacheConfig#keyGenerator */ String keyGenerator() default &quot;&quot;; /** * 自定义&#123;@link org.springframework.cache.CacheManager&#125;的bean名称，用于创建默认的&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;（如果尚未设置）。 * &lt;p&gt;与&#123;@link #cacheResolver&#125;属性互斥。 * @see org.springframework.cache.interceptor.SimpleCacheResolver * @see CacheConfig#cacheManager */ String cacheManager() default &quot;&quot;; /** * 要使用的定制&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;的bean名称。 * @see CacheConfig#cacheResolver */ String cacheResolver() default &quot;&quot;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String condition() default &quot;&quot;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String unless() default &quot;&quot;;&#125; 主要参数 描述 注释 value 同Cacheable @CachePut(“mysqlCache”) cacheNames 同Cacheable @CachePut(cacheNames=”mysqlCache”) key 同Cacheable @CachePut(cacheNames=”mysqlCache”,key=”#a1”) keyGenerator 同Cacheable @CachePut(cacheNames=”mysqlCache”,keyGenerator=”customKeyGenerator”) cacheManager 同Cacheable @CachePut(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”) cacheResolver() 同Cacheable 暂未测试 condition 同Cacheable @CachePut(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,condition=”#a1 == ‘xxx’”) unless 同Cacheable @CachePut(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,unless=”#a1 == ‘xxx’”) 2.1.3.3、@CacheEvict源码注释翻译： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;/** * 表示方法（或类中的所有方法）触发&#123;@link org.springframework.cache.Cache＃evict（Object）cache evict&#125;操作的注释。 * * &lt;p&gt;此注释可用作&lt;em&gt;元注释&lt;/ em&gt;，以创建具有属性覆盖的自定义&lt;em&gt;组成的注释&lt;/ em&gt;。 * * @author Costin Leau * @author Stephane Nicoll * @author Sam Brannen * @since 3.1 * @see CacheConfig */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CacheEvict &#123; /** * 别名 &#123;@link #cacheNames&#125;. */ @AliasFor(&quot;cacheNames&quot;) String[] value() default &#123;&#125;; /** * 用于缓存逐出操作的缓存名称。 &lt;p&gt;名称可用于确定目标缓存（或多个缓存），与特定Bean定义的限定符值或Bean名称匹配。 * @since 4.2 * @see #value * @see CacheConfig#cacheNames */ @AliasFor(&quot;value&quot;) String[] cacheNames() default &#123;&#125;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String key() default &quot;&quot;; /** * 自定义key生成器的bean名字&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125; * to use. * &lt;p&gt;与 &#123;@link #key&#125; 互斥 * @see CacheConfig#keyGenerator */ String keyGenerator() default &quot;&quot;; /** * 自定义&#123;@link org.springframework.cache.CacheManager&#125;的bean名称，用于创建默认的&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;（如果尚未设置）。 * &lt;p&gt;与&#123;@link #cacheResolver&#125; 互斥. * @see org.springframework.cache.interceptor.SimpleCacheResolver * @see CacheConfig#cacheManager */ String cacheManager() default &quot;&quot;; /** * 自定义的bean的名称&#123;@link org.springframework.cache.interceptor.CacheResolver&#125; * to use. * @see CacheConfig#cacheResolver */ String cacheResolver() default &quot;&quot;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String condition() default &quot;&quot;; /** * 是否删除缓存内的所有条目。 * &lt;p&gt;默认情况下，仅删除关联键下的值。 * &lt;p&gt;请注意，不允许将此参数设置为&#123;@code true&#125;并指定&#123;@link #key&#125;。 */ boolean allEntries() default false; /** * 在调用该方法之前是否应该收回。 * &lt;p&gt;将此属性设置为&#123;@code true&#125;，将导致驱逐发生，而与方法结果无关（即，是否引发异常）。 * &lt;p&gt;默认值为&#123;@code false&#125;，这意味着将在成功调用建议的方法后（即仅在调用未引发异常的情况下）&lt;/ em&gt;进行缓存逐出操作。 */ boolean beforeInvocation() default false;&#125; 主要参数 描述 用法 value 同Cacheable @CacheEvict(“mysqlCache”) cacheNames 同Cacheable @CacheEvict(cacheNames=”mysqlCache”) key 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”#a1”) keyGenerator 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”customKeyGenerator”) cacheManager 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”customKeyGenerator”,cacheManager=”customCacheManager”) cacheResolver 同Cacheable 暂时未测试 condition 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”#a1”,condition=”#a1 == true”) unless 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”#a1”,unless=”#a1 == true”) allEntries 是否删除该缓存实例下的所有缓存的信息，默认值：false，当值为true时，则与属性key互斥 @CacheEvict(cacheNames=”mysqlCache”,allEntries = false beforeInvocation 在调用该方法之前是否移除缓存，默认为false，如果为true时，则移除缓存和方法是否执行异常无关 @CacheEvict(cacheNames=”mysqlCache”,key=”#a1”,unless=”#a1 == true”,beforeInvocation = true) 2.1.3.4、@Caching源码注释翻译： 1234567891011121314151617181920212223242526272829303132package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 多个（不同或相同类型的）缓存注释的组注释。 * * &lt;p&gt;此注释可用作&lt;em&gt;元注释&lt;/ em&gt;，以创建具有属性覆盖的自定义&lt;em&gt;组成的注释&lt;/ em&gt;。 * * @author Costin Leau * @author Chris Beams * @since 3.1 */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Caching &#123; Cacheable[] cacheable() default &#123;&#125;; CachePut[] put() default &#123;&#125;; CacheEvict[] evict() default &#123;&#125;;&#125; 2.1.3.5、@CacheConfig源码注释翻译: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * &#123;@code @CacheConfig&#125;提供了一种在类级别共享与缓存相关的常见设置的机制。 * * &lt;p&gt;当给定类上存在此批注时，它将为该类中定义的任何缓存操作提供一组默认设置。 * * @author Stephane Nicoll * @author Sam Brannen * @since 4.1 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CacheConfig &#123; /** * 要为带注释的类中定义的缓存操作考虑的默认缓存的名称。 * &lt;p&gt;如果在操作级别未设置任何值，则将使用这些值而不是默认值。 * &lt;p&gt;可用于确定目标缓存（或多个缓存），与 * 限定符值或特定bean定义的bean名称。 */ String[] cacheNames() default &#123;&#125;; /** * 默认&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125;的bean名 * &lt;p&gt;如果在操作级别未设置任何值，则使用该值代替默认值。 * &lt;p&gt;密钥生成器与自定义密钥互斥。 当这样的钥匙是 * 为操作定义的，此密钥生成器的值将被忽略。 */ String keyGenerator() default &quot;&quot;; /** * 自定义&#123;@link org.springframework.cache.CacheManager&#125;的bean名称，用于创建默认&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;（如果尚未设置）。 * &lt;p&gt;如果在操作级别未设置解析器和缓存管理器，并且未通过&#123;@link #cacheResolver&#125;设置缓存解析器，则使用该解析器而不是默认值。 @see org.springframework.cache.interceptor.SimpleCacheResolver */ String cacheManager() default &quot;&quot;; /** * 要使用的定制&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;的bean名称。 * &lt;p&gt;如果在操作级别未设置解析器和缓存管理器，则使用该解析器而不是默认值。 */ String cacheResolver() default &quot;&quot;;&#125; 该注解只能使用在类上，为该类中的@Cacheable、@CachePut、@CacheEvict提供cacheNames、cacheManager、keyGenerator、cacheResolver默认的设置。不难发现这些值都是Spring 的bean的实例名称。 主要参数 描述 用法 cacheNames 缓存名称的bean的名称,默认值：“”，则以实际的设置为准 @CacheConfig(cacheNames=”mysqlCache”) cacheManager 缓存管理器的bean的名称,默认值：“”，则以实际的设置为准 @CacheConfig(cacheManager=”customCacheManager”) keyGenerator key生成器的bean的名称,默认值：“”，则以实际的设置为准 @CacheConfig(keyGenerator=”customKeyGnenrator”) cacheResolver 缓存实现的bean的名称,默认值：“”，则以实际的设置为准 @CacheConfig(cacheResolver=”customCacheResolver”) 三、Spring Cache的实现原理3.1、基本实现原理&emsp;&emsp;Spring的缓存实现，依赖于Spring AOP，通过获取上面讲述的五个注解的切点位置，来实现对应的功能。&emsp;&emsp;那么意味着如果要使用缓存或者缓存生效前提，所有的缓存方法调用实例都必须是Spring 代理的Bean。否则的话就无法使用。 3.2、核心实现类Spring Cache的核心类的依赖关系图： Spring Cache的执行逻辑： 3.3、Spring Cache 注解失效的场景在开发的过程中，可能会发现缓存没有生效，原因可能如下： 1、方法所在的Bean没有注入到Spring的容器2、方法是私有的或者是final修饰的3、方法的调用对象为非Spring的代理类，类似于this.method()方式调用 四、自定义Spring Cache在学习的过程中，做了一个简单的小demo拓展了一个Cache方式，尝试将缓存存储到Mysql的数据表中。 4.1、准备阶段 技术选型 版本 java 1.8.0_241 Spring boot 2.3.0.release Spring jpa 2.3.0.release 数据库 Mysql 5.x Spring boot test 2.3.0.release 实体类加强工具 lombok 4.2、创建缓存表的CRUD123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.yiyi.cache.cache.entity;import lombok.Data;import javax.persistence.*;import java.time.LocalDateTime;/** * @author wuxuan.chai * @date 2020/6/4 1:42 下午 */@Data@Entity(name = &quot;t_cache&quot;)public class CacheObject &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @Column(name = &quot;cache_key&quot;,nullable = false) private String cacheKey; @Column(name = &quot;cache_value&quot;,nullable = false) private String cacheValue; @Column(name = &quot;create_date&quot;,nullable = false) private LocalDateTime createDate;&#125;package com.yiyi.cache.cache.entity;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.transaction.annotation.Transactional;/** * @author wuxuan.chai * @date 2020/6/4 4:07 下午 */public interface CacheObjectMapper extends JpaRepository&lt;CacheObject,String&gt; &#123; CacheObject getByCacheKey(String cacheKey); @Modifying @Transactional void deleteCacheObjectByCacheKey(String cacheKey);&#125;package com.yiyi.cache.cache.entity;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.SneakyThrows;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;import java.time.LocalDateTime;/** * @author wuxuan.chai * @date 2020/6/4 4:08 下午 */@Servicepublic class CacheObjectService &#123; @Resource private CacheObjectMapper cacheObjectMapper; public String getValue(String key)&#123; CacheObject cacheObject = cacheObjectMapper.getByCacheKey(key); if (cacheObject == null)&#123; return null; &#125; return cacheObject.getCacheValue(); &#125; @SneakyThrows @Transactional(rollbackFor = Exception.class) public void putValue(String key, String value) &#123; CacheObject oldCacheObject = cacheObjectMapper.getByCacheKey(key); if (oldCacheObject != null)&#123; cacheObjectMapper.delete(oldCacheObject); &#125; CacheObject cacheObject = new CacheObject(); cacheObject.setCacheKey(key); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(value); cacheObject.setCacheValue(json); cacheObject.setCreateDate(LocalDateTime.now()); cacheObjectMapper.save(cacheObject); &#125; public void evict(String key) &#123; cacheObjectMapper.deleteCacheObjectByCacheKey(key); &#125; @Transactional public void clear() &#123; cacheObjectMapper.deleteAll(); &#125;&#125; 4.3、Spring Cache的拓展4.3.1、定义CacheManager12345678910111213141516171819202122232425262728293031323334353637package com.yiyi.cache.cache.manager;import org.springframework.cache.Cache;import org.springframework.cache.CacheManager;import java.util.Collection;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;/** * @author wuxuan.chai * @date 2020/6/4 3:52 下午 */public class CustomCacheManager implements CacheManager &#123; //定义存储Cache的存储器，所有拓展并且实例化的Cache对象都会存到这里面 private final static ConcurrentMap&lt;String,Cache&gt; cacheMap = new ConcurrentHashMap&lt;&gt;(); //通过名称，获取Cache实例化对象，我们定义Cacheable的注解用到的CacheNames属性的值，所标注的名称获取Cache实例就是这个方法提供的 @Override public Cache getCache(String name) &#123; return cacheMap.get(name); &#125; //获取所有的cache实例化对象的名称 @Override public Collection&lt;String&gt; getCacheNames() &#123; return cacheMap.keySet(); &#125; //创建Cache实例 public void createCache(Cache cache)&#123; cacheMap.put(cache.getName(),cache); &#125;&#125; 4.3.2、定义Cache1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.yiyi.cache.cache.manager;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializerProvider;import com.yiyi.cache.cache.entity.CacheObjectService;import com.yiyi.cache.cache.serializer.CustomSerializerImpl;import lombok.SneakyThrows;import org.springframework.beans.BeansException;import org.springframework.cache.Cache;import org.springframework.cache.support.SimpleValueWrapper;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import java.util.concurrent.Callable;/** * @author wuxuan.chai * @date 2020/6/4 4:02 下午 */@Componentpublic class MysqlCache implements Cache, ApplicationContextAware &#123; public final static String NAME = &quot;MYSQL&quot;; private ApplicationContext applicationContext; @Override public String getName() &#123; return NAME; &#125; @Override public Object getNativeCache() &#123; return this; &#125; @Override public ValueWrapper get(Object key) &#123; String value = applicationContext.getBean(CacheObjectService.class).getValue(key.toString()); return value != null ? new SimpleValueWrapper(fromStoreValue(value)) : null; &#125; @SneakyThrows @Override public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) &#123; String value = applicationContext.getBean(CacheObjectService.class).getValue(key.toString()); return (T) fromStoreValue(value); &#125; @SneakyThrows @Override public &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader) &#123; String value = applicationContext.getBean(CacheObjectService.class).getValue(key.toString()); return (T) fromStoreValue(value); &#125; @Override public void put(Object key, Object value) &#123; String cacheValue = toStoreValue(value); applicationContext.getBean(CacheObjectService.class).putValue(key.toString(), cacheValue); &#125; @Override public void evict(Object key) &#123; applicationContext.getBean(CacheObjectService.class).evict(key.toString()); &#125; @Override public void clear() &#123; applicationContext.getBean(CacheObjectService.class).clear(); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @SneakyThrows private String toStoreValue(Object value)&#123; CustomSerializerImpl customSerializer = new CustomSerializerImpl(); return customSerializer.serialize(value); &#125; @SneakyThrows private Object fromStoreValue(String value)&#123; CustomSerializerImpl customSerializer = new CustomSerializerImpl(); return customSerializer.deserialize(value); &#125;&#125; 4.3.3、配置Cache1234567891011121314151617181920212223242526272829303132package com.yiyi.cache.cache.config;import com.yiyi.cache.cache.manager.CustomCacheManager;import com.yiyi.cache.cache.manager.MysqlCache;import org.springframework.cache.CacheManager;import org.springframework.cache.concurrent.ConcurrentMapCache;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.annotation.Resource;/** * @author wuxuan.chai * @date 2020/6/4 3:40 下午 */@Configurationpublic class CacheConfig &#123; @Resource private MysqlCache mysqlCache; //定义了两个Cache：一个自己实现的MysqlCache（Mysql） 还有一个就是Spring Cache默认实现了的基于并发包ConcurrentMap实现的的ConcurrentMapCache (LOCAL) @Bean public CacheManager cacheManager()&#123; CustomCacheManager customCacheManager = new CustomCacheManager(); customCacheManager.createCache(mysqlCache); ConcurrentMapCache local = new ConcurrentMapCache(&quot;LOCAL&quot;); customCacheManager.createCache(local); return customCacheManager; &#125;&#125; 4.4.4、Cache的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.yiyi.cache.cache.service;import com.yiyi.cache.cache.entity.User;import com.yiyi.cache.cache.manager.MysqlCache;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.Cacheable;import org.springframework.cache.annotation.Caching;import org.springframework.stereotype.Service;/** * @author wuxuan.chai * @date 2020/6/4 2:46 下午 */@Servicepublic class CacheDemoService &#123; @Cacheable(cacheNames = MysqlCache.NAME, key = &quot;&#x27;CacheDemoService-get&#x27;+ args[0]&quot;) public String get(String name) &#123; return name; &#125; @Cacheable(cacheNames = MysqlCache.NAME, keyGenerator = &quot;customKeyGenerator&quot;) public User keyGenerator(String name, String value) &#123; User user = new User(); user.setUsername(name+value); return user; &#125; @Cacheable(cacheNames = MysqlCache.NAME, key = &quot;&#x27;CacheDemoService-getUser&#x27;+ args[0]&quot;) public User getUser(String name) &#123; User user = new User(); user.setUsername(name); return user; &#125; @Cacheable(cacheNames = &quot;LOCAL&quot;, key = &quot;&#x27;CacheDemoService-get&#x27;+ args[0]&quot;) public String getLocalCache(String name) &#123; return name; &#125; @Caching(evict = &#123; @CacheEvict(cacheNames = &#123;MysqlCache.NAME&#125;, key = &quot;&#x27;CacheDemoService-get&#x27;+ args[0]&quot;), @CacheEvict(cacheNames = MysqlCache.NAME, key = &quot;&#x27;CacheDemoService-getUser&#x27;+ args[0]&quot;) &#125;) public void clearCache(String name) &#123; &#125;&#125; 测试用例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.yiyi.cache.SpringCacheApplication;import com.yiyi.cache.cache.entity.User;import com.yiyi.cache.cache.service.CacheDemoService;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.annotation.Resource;/** * @author wuxuan.chai * @date 2020/6/4 2:49 下午 */@SpringBootTest(classes = &#123;SpringCacheApplication.class&#125;)public class CacheDemoServiceTest &#123; @Resource private CacheDemoService cacheDemoService; @Test public void testGet()&#123; String name = &quot;1231231&quot;; String s = cacheDemoService.get(name); System.out.println(s); System.out.println(cacheDemoService.get(&quot;1231&quot;).equals(&quot;1231&quot;)); &#125; @Test public void testGetUser()&#123; String name = &quot;1231231&quot;; User user = cacheDemoService.getUser(name); System.out.println(user.getUsername().equals(name)); &#125; @Test public void testGetLocalCache()&#123; String name = &quot;1231231&quot;; String s = cacheDemoService.getLocalCache(name); System.out.println(s); System.out.println(cacheDemoService.getLocalCache(&quot;1231&quot;).equals(&quot;1231&quot;)); &#125; @Test public void testClearCache()&#123; cacheDemoService.clearCache(&quot;1231231&quot;); &#125; @Test public void testKeyGenerator()&#123; User wuxuan = cacheDemoService.keyGenerator(&quot;wuxuan&quot;, &quot;123456&quot;); System.out.println(wuxuan); &#125;&#125; 五、总结&emsp;&emsp;通过阅读Spring Cache的源码后，感觉收获到了很多，首先从心理上认识到，源码也并没有那么的难。其次，Spring 能够受到广大Java开发人员的追捧也并非偶然，Spring的源码从思路上以及设计上还是非常的优秀的，从中能够学到很多。以后再接再厉，多多尝试Discover Why 而不 Ask Why。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"}],"author":"wuxuan.chai"},{"title":"Mac的VM中设置虚拟机静态ip","slug":"Mac的VM中设置虚拟机静态ip","date":"2021-01-17T16:13:21.416Z","updated":"2021-02-22T01:45:00.023Z","comments":true,"path":"2021/01/18/Mac的VM中设置虚拟机静态ip/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Mac%E7%9A%84VM%E4%B8%AD%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%99%E6%80%81ip/","excerpt":"","text":"Mac的VM中设置虚拟机静态ip闲来无事，想学习下spark相关的知识，于是需要几台服务器，无奈囊中羞涩双十一都买不起一台服务器，只能借助2015款的mac pro帮助虚拟几台服务器来暂时用用。 准备过程FinalShell 一款国产的mac上可用的shell命令工具VMware Fusion mac上用来安装虚拟机的工具centos7 的最简版镜像 设置VMware Fusion第一步：修改vmware 配置网卡的配置文件只更改Vnet8 的网卡 1234567891011121314151617181920$ vim /Library/Preferences/VMware\\ Fusion/networkingVERSION=1,0answer VNET_1_DHCP yesanswer VNET_1_DHCP_CFG_HASH EC13F23285B5086AFF5BDFFA85E8DE0338C2AF74answer VNET_1_HOSTONLY_NETMASK 255.255.255.0answer VNET_1_HOSTONLY_SUBNET 172.16.208.0answer VNET_1_VIRTUAL_ADAPTER yes#关闭dhcpanswer VNET_8_DHCP noanswer VNET_8_DHCP_CFG_HASH 13FB4A1FC14575A20209A2C7C8C2E5EED98C6665# 子网掩码answer VNET_8_HOSTONLY_NETMASK 255.255.255.0#设置ip段answer VNET_8_HOSTONLY_SUBNET 192.168.100.0answer VNET_8_NAT yesanswer VNET_8_VIRTUAL_ADAPTER yes# vmnet8 的IPanswer VNET_8_VIRTUAL_ADAPTER_ADDR 192.168.100.1 第二步：设置网关1234567#配置nat.conf 这个文件vim /Library/Preferences/VMware\\ Fusion/vmnet8/nat.conf #设定nat网管和子网# NAT gateway addressip = 192.168.100.2netmask = 255.255.255.0 第三步： 重启vmnet8网卡1234567# 查看网卡状态$ sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --status # 关闭网卡$ sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --stop# 启动网卡$ sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --start ～～～～中间省去在vm中创建centos的虚拟机步骤～～～～ 第四步：设置centos网卡1、配置网卡1234567891011121314151617181920212223242526272829 $ vi /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=no# 设置静态的ip，而不是dhcp方式BOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=74ad3dd0-742d-422b-b165-6f0d0b6e2f6dDEVICE=ens33# 设置网卡开机启动ONBOOT=yes# 设置当前centos的ip地址IPADDR=192.168.100.15# 设置网关GATEWAY=192.168.100.2# 设置子网掩码NETMASK=255.255.255.0#设置dnsDNS1=119.29.29.29DNS2=182.254.116.116 2、重启centos网卡123456#重启网卡systemctl restart network # 查看网卡ip addr 2、测试12345678910111213141516171819$ ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:dd:bc:55 brd ff:ff:ff:ff:ff:ff inet 192.168.100.15/24 brd 192.168.100.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::a3c4:b923:6d37:e7aa/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::3427:d5be:210e:dce2/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::3f6a:22ae:8bdd:e0ac/64 scope link noprefixroute valid_lft forever preferred_lft forever 测试发现ens33的ip地址已经变成了我们设置的ip了. 测试访问外网 1234567891011$ ping www.baidu.comPING www.a.shifen.com (180.101.49.12) 56(84) bytes of data.64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq=1 ttl=128 time=17.9 ms64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq=2 ttl=128 time=117 ms64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq=4 ttl=128 time=26.7 ms^C--- www.a.shifen.com ping statistics ---4 packets transmitted, 3 received, 25% packet loss, time 3004msrtt min/avg/max/mdev = 17.996/54.184/117.813/45.134 ms 大工告成，开始happy！！！","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://cha1yi.github.io/dist/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://cha1yi.github.io/dist/tags/Mac/"},{"name":"VM","slug":"VM","permalink":"https://cha1yi.github.io/dist/tags/VM/"}],"author":"wuxuan.chai"},{"title":"Apache SkyWalking 单机版测试","slug":"Apache SkyWalking 单机版测试","date":"2021-01-17T16:11:29.586Z","updated":"2021-01-18T02:21:54.194Z","comments":true,"path":"2021/01/18/Apache SkyWalking 单机版测试/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Apache%20SkyWalking%20%E5%8D%95%E6%9C%BA%E7%89%88%E6%B5%8B%E8%AF%95/","excerpt":"","text":"Apache SkyWalking 单机版测试一、部署SkyWalking学习之前，最好先浏览一下SkyWalking的设计原理：分布式追踪 &amp; APM 系统 SkyWalking 源码分析 —— Collector 存储 Trace 数据 1、下载SkyWalkingSkyWalking官方下载地址 2、解压tar.gz得到类似的目录： 3、启动SkyWalkingSkyWalking启动分两步进行：webApp、OapServer 1234567891011121314localhost:bin wuxuan.chai$ pwd/Users/wuxuan.chai/Documents/application/skywalking/apache-skywalking-apm-bin-es7/binlocalhost:bin wuxuan.chai$ ls -l-rwxr-xr-x 1 wuxuan.chai staff 1352 12 24 14:10 oapService.bat-rwxr-xr-x 1 wuxuan.chai staff 1599 12 24 14:10 oapService.sh-rwxr-xr-x 1 wuxuan.chai staff 1364 12 24 14:10 oapServiceInit.bat-rwxr-xr-x 1 wuxuan.chai staff 1597 12 24 14:10 oapServiceInit.sh-rwxr-xr-x 1 wuxuan.chai staff 1367 12 24 14:10 oapServiceNoInit.bat-rwxr-xr-x 1 wuxuan.chai staff 1616 12 24 14:10 oapServiceNoInit.sh-rwxr-xr-x 1 wuxuan.chai staff 941 12 24 14:10 startup.bat-rwxr-xr-x 1 wuxuan.chai staff 934 12 24 14:10 startup.sh-rwxr-xr-x 1 wuxuan.chai staff 1426 12 24 14:10 webappService.bat-rwxr-xr-x 1 wuxuan.chai staff 1630 12 24 14:10 webappService.shlocalhost:bin wuxuan.chai$ bin目录里面包含了三个部分：oap服务、oap服务初始化、webappService webappService服务的作用：提供SkyWalking的web服务 oap服务初始化：初始化oap服务所需要的环境初始化，例如：DataStorage的初始化,读取配置中心配置等 oap服务：相当于监控数据的收集（collecter）和持久化 如果配置完成，可以直接执行 sh startup.sh,启动整个项目 4、SkyWalking相关的配置4.1、oap收集数据存储位置配置12345# 打开配置文件~ vim ./config/application.yml# 查看storage配置项的支持，SkyWalking支持将数据落地到：elasticsearch、elasticsearch7、h2# 根据实际需求设置响应的配置信息 4.2、设置配置中心SkyWalking支持的配置中心有apollo、nacos、zookeeper、etcd、consul 123# 打开配置文件~ vim ./config/application.yml# 根据实际需求设置响应的配置信息 4.3、服务端口的设置1234# 打开配置文件~ vim ./webapp/webapp.yml# 修改web端口，server.port=9090 默认为8080# cellector服务的调用地址 修改listOfServers，多个服务用‘,’隔开 4.4、Agent的配置1234567# 打开配置文件～ vim ./agent/config/agent.config# oapservice的后端服务，用于应用订阅（默认值127.0.0.1:11800）collector.backend_service=xxx# 是否追踪sql的参数plugin.mysql.trace_sql_parameters=true/false 配置完成这些基本配置之后，就可以直接执行 sh startup.sh,启动整个项目了 5、将应用加入到SkyWalking的监控代理中5.1、springboot项目springboot应用：启动springboot的demo应用， 1234567891011#!/usr/bin/env sh# SkyWalking Agent 配置export SW_AGENT_NAME=demo-application # 配置 Agent 名字。一般来说，我们直接使用 Spring Boot 项目的 `spring.application.name` 。export SW_AGENT_COLLECTOR_BACKEND_SERVICES=127.0.0.1:11800 # 配置 Collector 地址。export SW_AGENT_SPAN_LIMIT=2000 # 配置链路的最大 Span 数量。一般情况下，不需要配置，默认为 300 。主要考虑，有些新上 SkyWalking Agent 的项目，代码可能比较糟糕。export JAVA_AGENT=-javaagent:/Users/wuxuan.chai/Documents/application/skywalking/apache-skywalking-apm-bin-es7/agent/skywalking-agent.jar # SkyWalking Agent jar 地址。# Jar 启动java -jar $JAVA_AGENT -jar lab-39-demo-2.2.2.RELEASE.jar 执行启动脚本，即可在SkyWalking的拓扑图中看到对应的服务监控信息 5.2、传统的ssm项目，使用tomcat/jetty等容器发布的工程需要在启动的参数中加入 1234-DSW_AGENT_NAME=xxx-DSW_AGENT_COLLECTOR_BACKEND_SERVICES=127.0.0.1:11800-DSW_AGENT_SPAN_LIMIT=2000-javaagent:/Users/wuxuan.chai/Documents/application/skywalking/apache-skywalking-apm-bin-es7/agent/skywalking-agent.jar 启动tomcat/jetty，即可。 效果如图：","categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"SkyWalking","slug":"SkyWalking","permalink":"https://cha1yi.github.io/dist/tags/SkyWalking/"},{"name":"系统监控","slug":"系统监控","permalink":"https://cha1yi.github.io/dist/tags/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"}],"author":"wuxuan.chai"},{"title":"Maven常用命令","slug":"maven相关命令","date":"2021-01-17T16:10:41.139Z","updated":"2021-01-18T02:22:42.870Z","comments":true,"path":"2021/01/18/maven相关命令/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/maven%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","excerpt":"","text":"maven常用命令一、上传包到maven中央仓库命令： 1mvn deploy:deploy-file -DgroupId=com.aliyun -DartifactId=taobao-sdk-java-auto -Dversion=202011-release -Dpackaging=jar -Dfile=/Users/wuxuan.chai/Downloads/dingtalk-sdk-java/taobao-sdk-java-auto_1479188381469-20201126.jar -Durl=http://ci.yunat.com:8091/nexus/content/repositories/thirdparty/ -DrepositoryId=nexus 参数解释:deploy:deploy-file：发布，发布文件到远程，和install的区别在于，install的意思是将jar安装到本地maven仓库groupId、artifactId、version：表示maven的坐标file：发布的文件的本地地址url：远程仓库的地址repositoryId：本地maven配置文件的仓库id，配置这个的话他会去找配置文件中的对应仓库的访问鉴权所需的账户和密码","categories":[{"name":"开发总结","slug":"开发总结","permalink":"https://cha1yi.github.io/dist/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://cha1yi.github.io/dist/tags/maven/"}],"author":"wuxuan.chai"},{"title":"项目版本管理的最佳实践","slug":"项目版本管理的最佳实践","date":"2021-01-17T16:06:38.488Z","updated":"2021-01-18T02:23:25.567Z","comments":true,"path":"2021/01/18/项目版本管理的最佳实践/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"项目版本管理的最佳实践一、Git设置1、添加公钥 1234567891011121314151617打开 git bash (mac 下直接打开终端即可)#: ssh-keygen -t rsa -C &quot;邮箱&quot;#: cat ~/.ssh/id_rsa.pub会生成：以ssh-rsa 开头的字符串，复制，贴到git公钥管理里面测试是否可以通过公钥，免密拉取上传代码#: ssh -T git@gitee.com （我这里用的gitee，对应的域名请自行切换）成功：Hi 柴梧炫 (DeployKey)! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access.Note: Perhaps the current use is DeployKey.Note: DeployKey only supports pull/fetch operations失败：The authenticity of host &#x27;gitlab.com (172.65.251.78)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:HbW3g8zUjNSksFbqTiUWPWg2Bq1x8xdGUrliXFzSnUw. 二、项目版本在web开发的过程中，maven 除了作为项目的依赖管理之外，还处理着项目的版本控制 1、maven 的多项目的标准结构1.1、如何组织项目123456789101112131415161718[MavenMultiProject] ├── module-1 │ ├── pom.xml │ └── src ├── module-2 │ ├── pom.xml │ └── src ├── module-3 │ ├── pom.xml │ ├── module-3-1 │ ├── pom.xml │ └── src │ ├── module-3-2 │ ├── pom.xml │ └── src ├── pom.xml ├── README.en.md ├── README.md 其中子模块也可以有其子模块 1.2、POM文件中的内容1.2.1、parent pom.xml父模块的pom文件一般存放公用的信息，以及定义标准，打包的格式：pom 除了上述的信息，一般不要引入其他的元素，因为一旦引入，子模块就会继承这些依赖，导致子模块的依赖被污染 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!-- 属性定义--&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; ....&lt;/properties&gt;&lt;!-- 仓库的定义 --&gt;&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;local nexus&lt;/id&gt; &lt;name&gt;local nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;local nexus&lt;/id&gt; &lt;name&gt;local nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt;&lt;!-- 软件配置管理（项目git地址信息）如果git需要权限，则需要加入公钥，免密访问--&gt;&lt;scm&gt; &lt;connection&gt; scm:git:https://gitee.com/wuxuanchai_admin/m-v.git &lt;/connection&gt; &lt;developerConnection&gt; scm:git:https://gitee.com/wuxuanchai_admin/m-v.git &lt;/developerConnection&gt; &lt;url&gt; https://gitee.com/liang.liang/version-mangement-best-practices &lt;/url&gt; &lt;tag&gt;HEAD&lt;/tag&gt;&lt;/scm&gt;&lt;!--开发者--&gt;&lt;developers&gt; &lt;developer&gt; &lt;name&gt;wuxuan.chai&lt;/name&gt; &lt;email&gt;wuxuan.chai@gmail.com&lt;/email&gt; &lt;organizationUrl&gt;www.shuyun.com&lt;/organizationUrl&gt; &lt;/developer&gt;&lt;/developers&gt;&lt;!--模块定义--&gt;&lt;moudles&gt; &lt;moudle&gt;../moudle1&lt;/moudle&gt;&lt;/moudles&gt;&lt;build&gt; &lt;!--插件定义--&gt; &lt;pluginManagement&gt; &lt;/pluginManagement&gt;&lt;/build&gt;&lt;!--依赖定义--&gt;&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt; pom文件中可被继承的元素： 可继承的POM元素如下： groupId：项目组ID，项目坐标的核心元素 version：项目版本，项目坐标的核心因素 description：项目的描述信息 organization：项目的组织信息 inceptionYear：项目的创始年份 url：项目的URL地址 developers：项目的开发者信息 contributors：项目的贡献者信息 distributionManagement：项目的部署配置 issueManagement：项目的缺陷跟踪系统信息 ciManagement：项目的持续集成系统信息 scm：项目的版本控制系统西溪 malilingLists：项目的邮件列表信息 properties：自定义的Maven属性 dependencies：项目的依赖配置 dependencyManagement：项目的依赖管理配置 repositories：项目的仓库配置 build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等 reporting：包括项目的报告输出目录配置、报告插件配置等 1.2.2、子模块子模块是具体依赖的配置，一般以jar包的格式提供服务（使用springboot后，war包格式会被打成jar） 在子模块中，所有的version都不应该存在，要放在parent.pom 中进行统一管理 模块本身：version 继承父模块的versoin 所有依赖version，在父模块的dependencyManagement 元素中进行定义 12345678910111213141516171819&lt;!-- 父模块的坐标--&gt;&lt;parent&gt; &lt;/parent&gt;&lt;!-- 当前模块的坐标，不需要写版本信息，会继承父模块的版本号--&gt;&lt;artifactId&gt;com.example&lt;/artifactId&gt;&lt;name&gt;demo&lt;/name&gt;&lt;!-- 模块描述--&gt;&lt;description&gt;xxx&lt;/description&gt;&lt;!-- 模块依赖列表--&gt;&lt;dependencies&gt;&lt;/dependencies&gt;&lt;!-- 模块的构建所需要的插件--&gt;&lt;build&gt;&lt;/build&gt; 1.3、语义化的版本号（Semantic Versioning）1.3.1、版本号的格式版本号的格式： 主版本号.次版本号.修订号 版本号的递增的规则： 1、主版本号：当你做了不兼容的API修改 2、次版本号：当你做了向下兼容的功能性新增 3、修订号：当你做了向下兼容的问题修正 先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 也就是说可以支持这种版本号： 4.7.5.202005 4 主版本号 7 次版本号 5 修订号 202005 编译元数据-编译日期 其他的语义描述： Alpha：内测版 Beta：公测版 Gamma：比较成熟的测试版，与即将发行的正式版相差无几 RC：是 Release Candidate 的缩写，意思是发布倒计时，候选版本 Stable：稳定版 1.4、版本性质： Snapshot 与Release1.4.1、概念Snapshot：快照，他是一个不稳定的版本，处于开发中的，经常变化的版本 Release：发行版，功能稳定的版本，将停止代码的更新，用于发行到生产环境 1.4.2、理想的流程日常的开发基于Snapshot的版本进行开发，snapshot版本会有一些特性 执行 mvn complie 时会去仓库中尝试拉最新打包，因为他可以被多次构建，使用时必须保证最新 可以被重复构建 版本发布在发布版本的时候，我们需要做以下的几件事： 1、创建Tag分支，tag/v版本号（例如：tag/v0.0.1） 2、在仓库中构建发布包（release 的jar） 3、创建新的开发分支，升级本地pom文件版本，根据实际的需求提升版本号 如果hotfix发布，则：x.y.z -&gt; x.y.z+1 例如：4.7.5 &gt; 4.7.6 次版本发布， 则： x.y.z -&gt; x.y+1.0 例如：4.7.5 &gt; 4.8.0 大版本更新，则：x.y.z -&gt; x+1.0.0 例如：4.7.5 &gt; 5.0.0 4、非hotfix版本发布，还需要创建hotfix分支，用于以后修复 现有的项目如何做？插件管理：maven-release-plugin 插件地址：http://maven.apache.org/maven-release/maven-release-plugin/ parent pom配置文件配置： 1234567891011121314151617181920212223242526272829&lt;scm&gt; &lt;!-- git项目地址可以用SSH 也可以用 HTTPS的--&gt; &lt;connection&gt;scm:git:https://gitee.com/wuxuanchai_admin/m-v.git&lt;/connection&gt; &lt;!-- #git项目地址可以用SSH 也可以用 HTTPS的--&gt; &lt;developerConnection&gt;scm:git:https://gitee.com/wuxuanchai_admin/m-v.git&lt;/developerConnection&gt; &lt;!-- #git项目浏览器里的地址--&gt; &lt;url&gt;https://gitee.com/liang.liang/version-mangement-best-practices&lt;/url&gt; &lt;tag&gt;HEAD&lt;/tag&gt;&lt;/scm&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- tag分支的名称，project.version只包含版本，不包含SNAPSHOT后缀 --&gt; &lt;tagNameFormat&gt;v@&#123;project.version&#125;&lt;/tagNameFormat&gt; &lt;!-- 升级子模块 --&gt; &lt;autoVersionSubmodules&gt;true&lt;/autoVersionSubmodules&gt; &lt;!-- 跳过单元测试 --&gt; &lt;arguments&gt;-DskipTests&lt;/arguments&gt; &lt;!-- 执行目标，此句可省 --&gt; &lt;goals&gt;-f pom.xml deploy&lt;/goals&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如何使用？？1) release:branch（创建分支 ）创建的分支是用于hotfix修复的基础分支，在第一次创建次要版本是，要一并创建，以后的修改都基于此分支，后续如果有需要的hotfix来修复问题，则基于此分支创建一个新的分支hotfix-xxx，然后提交代码后，将release一个hotfix的版本：x.y.z+1(z表示当前的修订号) 命令： 1mvn release:branch -DbranchName=0.2.x -DupdateBranchVersions=true -DupdateWorkingCopyVersions=false 命令含义： -DbranchName=0.2.x：创建一个叫 0.2.x 的分支 -DupdateBranchVersions=true ：分支会升级版本号，如果当前的版本号为0.0.1-snapshot，则新的分支版本号为： 0.0.2-snapshot DupdateWorkingCopyVersions=false 当前工作空间的pom文件不做更改，方便后面的release操作 2) release:prepare(预处理，升级pom-version)预处理阶段，release插件会： 执行一次打包过程 在git仓库里面创建好Tag分支 升级pom文件版本，并提交到本地仓库（此处不会更改远程仓库的分支） 1mvn release:prepare 在默认的情况下，他是一个交互式的命令，有如下问题需要确认： 1234567What is the release version for &quot;mvc-test&quot;? (com.fruits.mvc:mvc-test) 0.1.15: :What is SCM release tag or label for &quot;mvc-test&quot;? (com.fruits.mvc:mvc-test) v0.1.15: :What is the new development version for &quot;mvc-test&quot;? (com.fruits.mvc:mvc-test) 0.1.16-SNAPSHOT: :&#x2F;&#x2F;要发布的版本是哪一个？默认当前版本&#x2F;&#x2F;要打的tag叫什么？现在的样子 &#x2F;&#x2F;创建一个新的开发版本吗？默认当前版本+1 修订（此处我们可以手工改成 子版本号更新） 执行了 release:prepare命令后，在git仓库中，我们可以看到一个叫：v0.1.15的tag被创建，这操作是可以回滚的，插件在项目里面创建了一个，pom.xml.releaseBackup的文件，用于回滚pom.xml，同时还会生成：release.properties 里面会记录release版本的属性 3) release:rollback(回滚)Release:prepare 阶段都是进行了本地的提交，因此可以进行回滚，但tag分支必须手工删除，插件不能帮你删除已经创建好的本地Tag 除此之外，可以还行发布预览： 1mvn release:prepare -DdryRun=true 干跑会生成预览文件： pom.xml.nextpom.xml.releaseBackuppom.xml.tagrelease.properties 但是不会提交。 4) release:perform (执行)执行命令，会在release仓库里面构建发布包 可能碰到的问题 release:rollback不会回滚git的tag，需要手动删除tag maven配置的优先级(idea下) pom.xml&gt;.m2/setting.xml&gt;setting.xml pom.xml 发生改变，无法执行release:prepare 私服的设置和maven的配置文件如果配置不正确，无法执行命令 效果私服中release的jar： 私服中的snapshot的jar： git中的tag：发布release后创建的tag分支","categories":[{"name":"开发总结","slug":"开发总结","permalink":"https://cha1yi.github.io/dist/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://cha1yi.github.io/dist/tags/maven/"}],"author":"wuxuan.chai"},{"title":"Arthas诊断神器","slug":"Arthas诊断神器","date":"2021-01-17T15:59:56.357Z","updated":"2021-01-18T02:21:54.192Z","comments":true,"path":"2021/01/17/Arthas诊断神器/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/Arthas%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8/","excerpt":"","text":"一、快速入门1.1、Arthas简介Arthas 是Alibaba开源的Java诊断工具。可以安装在系统所在服务器，也可以远程诊断其他服务器的服务。可以帮助开发人员或者运维人员查找问题，分析性能，bug追踪。 1.2、Arthas的快速入门下载地址： 1wget https://alibaba.github.io/arthas/arthas-boot.jar 应用程序：可以自己启一个java服务 1.3、启动Arthas1java -jar arthas-boot.jar 执行arthas程序的用户要和应用程序的执行用户为相同的权限。比如：应用程序使用admin用户来执行，那么arthas的启动：sudo su admin &amp;&amp; java -jar arthas-boot.jar 或者 sudo -u admin -EH java -jar arthas-boot.jarjava -jar arthas-boot.jar -h 打印更多的信息 开始启动： 123456789101112localhost:Downloads wuxuan.chai$ java -jar arthas-boot.jar [INFO] arthas-boot version: 3.3.3[INFO] Process 84742 already using port 3658[INFO] Process 84742 already using port 8563[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.* [1]: 84742 com.yiyi.Application [2]: 84898 arthas-boot.jar [3]: 1572 kafka.Kafka [4]: 981 org.apache.zookeeper.server.quorum.QuorumPeerMain [5]: 84726 org.codehaus.plexus.classworlds.launcher.Launcher [6]: 83691 [7]: 84010 org.jetbrains.idea.maven.server.RemoteMavenServer36 可以看到我们通过wuxuan.chai用户启动了7个java进程（pid）： 1234567* [1]: 84742 com.yiyi.Application [2]: 84898 arthas-boot.jar [3]: 1572 kafka.Kafka [4]: 981 org.apache.zookeeper.server.quorum.QuorumPeerMain [5]: 84726 org.codehaus.plexus.classworlds.launcher.Launcher [6]: 83691 [7]: 84010 org.jetbrains.idea.maven.server.RemoteMavenServer36 选择应用的java进程：这里我们选择我们的测试app，1输入1，再回车/enter，arthas会attach到目标进程： 123456789101112131415161718192021222324252627282930313233localhost:Downloads wuxuan.chai$ java -jar arthas-boot.jar [INFO] arthas-boot version: 3.3.3[INFO] Process 84742 already using port 3658[INFO] Process 84742 already using port 8563[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.* [1]: 84742 com.yiyi.Application [2]: 84898 arthas-boot.jar [3]: 1572 kafka.Kafka [4]: 981 org.apache.zookeeper.server.quorum.QuorumPeerMain [5]: 84726 org.codehaus.plexus.classworlds.launcher.Launcher [6]: 83691 [7]: 84010 org.jetbrains.idea.maven.server.RemoteMavenServer361[INFO] arthas home: /Users/wuxuan.chai/.arthas/lib/3.3.6/arthas[INFO] The target process already listen port 3658, skip attach.[INFO] arthas-client connect 127.0.0.1 3658 ,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \\ | .--. &#x27;&#x27;--. .--&#x27;| &#x27;--&#x27; | / O \\ &#x27; .-&#x27; | .-. || &#x27;--&#x27;.&#x27; | | | .--. || .-. |`. `-. | | | || |\\ \\ | | | | | || | | |.-&#x27; | `--&#x27; `--&#x27;`--&#x27; &#x27;--&#x27; `--&#x27; `--&#x27; `--&#x27;`--&#x27; `--&#x27;`-----&#x27; wiki https://alibaba.github.io/arthas tutorials https://alibaba.github.io/arthas/arthas-tutorials version 3.3.6 pid 84742 time 2020-07-06 10:46:47 [arthas@84742]$ 1.4、Arthas的基本操作Arthas的入门基本操作：Dashboard/thread/jad/watch，来查看一些最基本的指标信息，比如，资源占用，线程，类信息，方法执行信息。 1.4.1、查看Dashboard123456789101112131415161718192021222324252627282930313233[arthas@84742]$ dashboard ID NAME GROUP PRIORITY STATE %CPU TIME INTERRUPTED DAEMON 149 Timer-for-arthas-dashboard-3bf90e35- system 10 RUNNABLE 51 0:0 false true 113 Catalina-utility-1 main 1 TIMED_WAITI 14 0:0 false false 116 http-nio-7070-BlockPoller main 5 RUNNABLE 14 0:0 false true 127 http-nio-7070-ClientPoller main 5 RUNNABLE 13 0:0 false true 114 Catalina-utility-2 main 1 WAITING 5 0:0 false false 131 Attach Listener system 9 RUNNABLE 0 0:0 false true 130 DestroyJavaVM main 5 RUNNABLE 0 0:1 false false 3 Finalizer system 8 WAITING 0 0:0 false true 2 Reference Handler system 10 WAITING 0 0:0 false true 4 Signal Dispatcher system 9 RUNNABLE 0 0:0 false true 136 arthas-shell-server system 9 TIMED_WAITI 0 0:0 false true 137 arthas-shell-server system 9 TIMED_WAITI 0 0:0 false true 133 arthas-timer system 9 WAITING 0 0:0 false true 141 as-command-execute-daemon system 10 TIMED_WAITI 0 0:0 false true 115 container-0 main 5 TIMED_WAITI 0 0:0 false false Memory used total max usage GC heap 169M 370M 3641M 4.66% gc.ps_scavenge.count 4 ps_eden_space 140M 183M 1344M 10.46% gc.ps_scavenge.time(ms) 37 ps_survivor_space 0K 10752K 10752K 0.00% gc.ps_marksweep.count 2 ps_old_gen 29M 176M 2731M 1.07% gc.ps_marksweep.time(ms) 118 nonheap 53M 57M -1 92.98% code_cache 5M 7M 240M 2.17% metaspace 42M 44M -1 95.78% Runtime os.name Mac OS X os.version 10.14.6 java.version 1.8.0_241 java.home /Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre systemload.average 3.25 processors 8 uptime 上半部分是程序的线程信息，中间是内存使用情况，这里可以查看gc的次数，下面是当前程序运行的环境信息 1.4.2、thread命令查看进程1234567[arthas@84742]$ thread 115 &quot;container-0&quot; Id=115 TIMED_WAITING at java.lang.Thread.sleep(Native Method) at org.apache.catalina.core.StandardServer.await(StandardServer.java:570) at org.springframework.boot.web.embedded.tomcat.TomcatWebServer$1.run(TomcatWebServer.java:197)Affect(row-cnt:0) cost in 1 ms. 查看线程的具体信息，调用对象，状态等。。。 1.4.3、jad反编译class类通过jad反编译springboot的启动类： 12345678910111213141516171819202122232425262728[arthas@84742]$ jad com.yiyi.ApplicationClassLoader: +-sun.misc.Launcher$AppClassLoader@4e25154f +-sun.misc.Launcher$ExtClassLoader@2ef1e4fa Location: /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/target/classes/ /* * Decompiled with CFR. */package com.yiyi;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@SpringBootApplication@ComponentScan(value=&#123;&quot;com.yiyi&quot;&#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;Affect(row-cnt:2) cost in 181 ms.[arthas@84742]$ 1.4.4、watch查看函数的返回值通过watch命令查看方法的返回值，查看获取微信的accessToken的方法返回值： 1234[arthas@84742]$ watch com.yiyi.api.WeixinSupportApi getAccessToken Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 38 ms, listenerId: 3 执行命令后，Arthas会监听该方法的执行，每次调用，都会将执行结果打印出来,例如： 12345ts=2020-07-06 11:26:17; [cost=3.13107ms] result=@ArrayList[ @Object[][isEmpty=false;size=2], @WeixinSupportApi[com.yiyi.api.WeixinSupportApi@14cb7037], @String[i9c7LCIqY8cJuneYN9C9q4kN-FZoo7YZFVxEpgT3ugMmeX1KJ5HuVgSLK5IkJW7JF_adbkmjGrGdu9aw9XFhrMBLBMC9eFm82ICpst1-UVGujAvdUMcPRkUNcgb7I7MmxHk2ZVIpZzLKxf-3zw1-oE-wfhETKjRrjRhoP7z7g9UD4OS-cctNJBUJk8XfcE2cW_S2GUuj-tm2vyvVNK9oDQ],] 二、进阶使用2.1、基础命令2.1.1、所有命令的集合 NAME DESCRIPTION help 展示Arthas帮助 keymap 展示所有指定的连接的可用的快捷键 sc 搜索所有被jvm加载类 sm 搜索所有被jvm加载的类的方法 classloader 展示类加载器的信息 jad 类反编译 getstatic 展示一个类的静态的属性字段 monitor 监控方法执行的数据，例如：合计/成功/失败的数值，实时平均值失败比率等 stack 展示指定类和方法的调用栈信息 thread 展示线程信息和调用栈 trace 指定方法调用栈的执行时间 watch 展示指定方法的调用过程中，输入/输出的参数，结果返回值，异常抛出等 tt 时间隧道 jvm 展示目标jvm的信息 perfcounter 展示性能计数器的信息 ognl 执行ognl表达式 mc 内存编译器，将java文件在内存中编译成字节码和内存中的类文件 redefine 重新定义类，参考Instrumentation#redefineClasses(ClassDefinition…) dashboard 预览目标jvm的线程，gc，环境变量，tomcat信息 dump 从jvm中转存类的字节码 heapdump 堆转存 options 查看和更改各种Arthas选项 cls 清理屏幕 reset 重置所有的增强类 version 展示Arthas版本 session 展示当前会话的信息 sysprop 展示，修改系统的配置 sysenv 展示系统环境变量 vmoption 展示修改vm诊断选项 logger 打印日志信息，修改日志级别 history 展示历史命令 cat 连接并打印文件内容，类似linux的cat命令 echo 将参数写入标准输出 pwd 返回工作目录名称 mbean 显示mbean信息 grep 用于管道的grep命令 tee 管道的tee命令 profiler 异步分析工具https://github.com/jvm-profiling-tools/async-profiler stop 停止/关闭Arthas服务器并退出控制台 2.1.2、redefine命令，替换指定源class文件redefine后的原来的类不能恢复，redefine也有可能失败（比如新增了field），reset命令对redefine无效，如果想重置，需要redefine原始的字节码。不允许新增加field/method。正在执行的函数，没有退出不能生效。 示例，替换接口的返回值： 123456789@RestController@RequestMapping(value = &quot;/weixin&quot;, produces = MediaType.APPLICATION_JSON_VALUE)@Slf4jpublic class WeixinSupportApi &#123; @GetMapping(&quot;/test/&quot;) public String test() &#123; return &quot;这是正牌的接口结果&quot;; &#125;&#125; 请求接口会返回一个字符串：“这是正牌的接口结果”。接下来通过arthas的redifine命令替换成接口返回成一个：“hello” 1234567891011121314@RestController@RequestMapping(value = &quot;/weixin&quot;, produces = MediaType.APPLICATION_JSON_VALUE)@Slf4jpublic class WeixinSupportApi &#123; @GetMapping(&quot;/test/&quot;) public String test() &#123; return &quot;hello&quot;; &#125;&#125;``` 方式一、 将上述的java文件编译成class文件,上传到服务器，使用redefine命令,开始替换：```shellredefine weixin/WeixinSupportApi.class 方式二、 12345678910111213//通过jad将class 文件编译成java文件jad --source-only com.yiyi.api.WeixinSupportApi &gt; weixin/src/main/java/com/yiyi/api/WeixinSupportApi.java//通过vim对文件进行编辑，实现我们想要的一个逻辑vim weixin/src/main/java/com/yiyi/api/WeixinSupportApi.java//通过mc 内存编译，将上面的java文件编译成class 代码mc weixin/src/main/java/com/yiyi/api/WeixinSupportApi.java -d weixin-&gt;输出编译后的class 文件地址：Memory compiler output:/Users/wuxuan.chai/Documents/project/springboot-learn/weixin/com/yiyi/api/WeixinSupportApi.classAffect(row-cnt:1) cost in 1467 ms.//redefine 替换内存中的class文件为刚才编译的class 文件redefine /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/com/yiyi/api/WeixinSupportApi.class即可实现对源class 的编辑，并且进行热部署。。 2.1.3、headdump命令dump java heap，类似jmap命令的heap dump功能 123456//dump到指定的文件heapdump ./dump.hprof//只dump live对象heapdump --live ./dump.hprof//dump到临时文件heapdump 2.1.4、classloader的命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//按类加载类型查看统计信息[arthas@89977]$ classloader name numberOfInstances loadedCountTotal sun.misc.Launcher$AppClassLoader 1 4440 BootstrapClassLoader 1 2932 com.taobao.arthas.agent.ArthasClassloader 1 2095 lombok.launch.ShadowClassLoader 1 242 sun.reflect.DelegatingClassLoader 77 77 sun.misc.Launcher$ExtClassLoader 1 4 javax.management.remote.rmi.NoCallStackClassLoader 2 2 sun.reflect.misc.MethodUtil 1 1 Affect(row-cnt:8) cost in 5 ms.//按类加载实例查看统计信息[arthas@89977]$ classloader -l name loadedCount hash parent BootstrapClassLoader 2932 null null com.taobao.arthas.agent.ArthasClassloader@3c708a1d 2095 3c708a1d sun.misc.Launcher$ExtClassLoader@770c2e6b javax.management.remote.rmi.NoCallStackClassLoader@1060b431 1 1060b431 null javax.management.remote.rmi.NoCallStackClassLoader@63440df3 1 63440df3 null lombok.launch.ShadowClassLoader@1756d9eb 242 1756d9eb sun.misc.Launcher$AppClassLoader@18b4aac2 sun.misc.Launcher$AppClassLoader@18b4aac2 4440 18b4aac2 sun.misc.Launcher$ExtClassLoader@770c2e6b sun.misc.Launcher$ExtClassLoader@770c2e6b 4 770c2e6b null sun.reflect.misc.MethodUtil@2c109df9 1 2c109df9 sun.misc.Launcher$AppClassLoader@18b4aac2 Affect(row-cnt:8) cost in 5 ms.// 查看classloader的继承树[arthas@89977]$ classloader -t+-BootstrapClassLoader +-javax.management.remote.rmi.NoCallStackClassLoader@1060b431 +-javax.management.remote.rmi.NoCallStackClassLoader@63440df3 +-sun.misc.Launcher$ExtClassLoader@770c2e6b +-com.taobao.arthas.agent.ArthasClassloader@3c708a1d +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-lombok.launch.ShadowClassLoader@1756d9eb +-sun.reflect.misc.MethodUtil@2c109df9 Affect(row-cnt:8) cost in 5 ms.//查看URLClassloader的实际urls[arthas@89977]$ classloader -c 770c2e6bfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/sunec.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/nashorn.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/cldrdata.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/jfxrt.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/dnsns.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/localedata.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk16-143.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk15-135.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/jaccess.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/zipfs.jar file:/System/Library/Java/Extensions/MRJToolkit.jar Affect(row-cnt:84) cost in 5 ms.//尝试查找类的class文件[arthas@89977]$ classloader -c 770c2e6b -r java/lang/String.class jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/rt.jar!/java/lang/String.class Affect(row-cnt:1) cost in 4 ms.//使用classloader加载类[arthas@89977]$ classloader -c 2c109df9 --load com.yiyi.api.WeixinSupportApiload class success. class-info com.yiyi.api.WeixinSupportApi code-source /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/target/classes/ name com.yiyi.api.WeixinSupportApi isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name WeixinSupportApi modifier public annotation org.springframework.web.bind.annotation.RestController,org.springframework.web.bind.annotation.RequestMapping interfaces super-class +-java.lang.Object class-loader +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-sun.misc.Launcher$ExtClassLoader@770c2e6b classLoaderHash 18b4aac2 //使用classloader去查找resource[arthas@89977]$ classloader -c 2c109df9 -r META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk16-143.jar!/META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk15-135.jar!/META-INF/MANIFEST.MF jar:file:/System/Library/Java/Extensions/MRJToolkit.jar!/META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/charsets.jar!/META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/deploy.jar!/META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk15-135.jar!/META-INF/MANIFEST.MF 2.1.4、getstatic获取类中的静态属性1234[arthas@89977]$ getstatic com.yiyi.api.WeixinSupportApi CORP_IDfield: CORP_ID@String[ww91156f2c9067a7ba]Affect(row-cnt:1) cost in 4 ms. 如果对象是一个复杂的对象，可以使用OGNL表达式进行遍历,过滤 2.1.5、tt命令，记录调用记录方法执行记录的隧道，记录指定方法每次调用的入参和返回的信息，并能对这些不同时间下的调用进行观测。 tt的调用方式：|选项|描述||-|-||-d,–delete|删除索引指定的时间片段||–delete-all|删除所有的时间片段||-x,–expand value|展开对象级别(默认为1)||-h,–help|命令使用指南||-i,–index value|展示指定的时间片段的相信信息||-n,–limits value|执行时间阈值||-l,–list|展示所有的时间片段的信息||–listenerId value|指定监听id||-p,–play|重放由索引指定的时间片段||-E,–regex|启用正则表达式匹配(默认情况下为通配符匹配)||–replay-interval value|选项r大于1的tt的回放间隔||–replay-times value|执行tt时的次数||-s,–search-express value|搜索表达式，用ognl表达式搜索时间片段。|||advice的结构类似条件式表达||-M,–sizeLimit value|结果的字节上限(默认为1010241024)||-t,–time-tunnel|在时间片段内记录方法调用||-w,–watch-express value&gt;|观看ognlexpress的时间片段||class-pattern|模式匹配的路径和类名||method-pattern|模式匹配法||condition-express|ognl风格的条件表达式| 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//记录调用[arthas@89977]$ tt -t com.yiyi.api.WeixinSupportApi test Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 129 ms, listenerId: 1 INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD -------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1000 2020-07-06 17:21:20 0.531715 true false 0x437d2cf WeixinSupportApi test 1001 2020-07-06 17:21:24 0.026004 true false 0x437d2cf WeixinSupportApi test 1002 2020-07-06 17:21:27 0.027567 true false 0x437d2cf WeixinSupportApi test 1003 2020-07-06 17:21:28 0.064779 true false 0x437d2cf WeixinSupportApi test //展示时间片列表[arthas@89977]$ tt -l INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD -------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1000 2020-07-06 17:21:20 0.531715 true false 0x437d2cf WeixinSupportApi test 1001 2020-07-06 17:21:24 0.026004 true false 0x437d2cf WeixinSupportApi test 1002 2020-07-06 17:21:27 0.027567 true false 0x437d2cf WeixinSupportApi test 1003 2020-07-06 17:21:28 0.064779 true false 0x437d2cf WeixinSupportApi test Affect(row-cnt:4) cost in 1 ms.//展示时间片的具体信息[arthas@89977]$ tt -i 1000 INDEX 1000 GMT-CREATE 2020-07-06 17:21:20 COST(ms) 0.531715 OBJECT 0x437d2cf CLASS com.yiyi.api.WeixinSupportApi METHOD test IS-RETURN true IS-EXCEPTION false RETURN-OBJ @String[hello] Affect(row-cnt:1) cost in 1 ms.//重新调用索引为1000的调用[arthas@89977]$ tt -i 1000 -p RE-INDEX 1000 GMT-REPLAY 2020-07-06 17:22:10 OBJECT 0x437d2cf CLASS com.yiyi.api.WeixinSupportApi METHOD test IS-RETURN true IS-EXCEPTION false COST(ms) 0.260785 RETURN-OBJ @String[hello] Time fragment[1000] successfully replayed 1 times.[arthas@89977]$ 表格字段 字段解释 INDEX 时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。 TIMESTAMP 方法执行的本机时间，记录了这个时间片段所发生的本机时间 COST(ms) 方法执行的耗时 IS-RET 方法是否以正常返回的形式结束 IS-EXP 方法是否以抛异常的形式结束 OBJECT 执行对象的hashCode()，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体 CLASS 执行的类名 METHOD 执行的方法名 使用OGNL表达式，对调用参数进行过滤监听。 12345678910111213141516171819202122232425262728[arthas@89977]$ tt -t com.yiyi.api.WeixinSupportApi sendMessage &#x27;params[0].text.content==&quot;test&quot;&#x27;Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 72 ms, listenerId: 5 INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD -------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1004 2020-07-06 17:33:42 354.578854 true false 0x437d2cf WeixinSupportApi sendMessage [arthas@89977]$ tt -i 1004 INDEX 1004 GMT-CREATE 2020-07-06 17:33:42 COST(ms) 354.578854 OBJECT 0x437d2cf CLASS com.yiyi.api.WeixinSupportApi METHOD sendMessage IS-RETURN true IS-EXCEPTION false PARAMETERS[0] @SendMessageVO[ touser=@String[Feng], msgtype=@String[text], agentid=@Integer[1000036], text=@Text[com.yiyi.model.SendMessageVO$Text@504511d7], safe=@Integer[0], ] RETURN-OBJ @WeixinResponse[ errcode=@Integer[0], errmsg=@String[ok], invaliduser=@String[], ] Affect(row-cnt:1) cost in 1 ms. 2.1.6、使用sc查看jvm已加载的类信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//模糊匹配，查看某个包下面的类加载信息[arthas@89977]$ sc com.yiyi.*com.yiyi.Applicationcom.yiyi.Application$$EnhancerBySpringCGLIB$$7f85004ecom.yiyi.WebConfigcom.yiyi.WebConfig$$EnhancerBySpringCGLIB$$bf76c934com.yiyi.api.WeixinSupportApicom.yiyi.api.WeixinSupportApi$$Lambda$451/966754950com.yiyi.api.WeixinSupportApi$$Lambda$467/1545239474com.yiyi.api.WeixinSupportApi$$Lambda$468/1304820993com.yiyi.model.AccessTokenVocom.yiyi.model.SendMessageVOcom.yiyi.model.SendMessageVO$Textcom.yiyi.model.WeixinResponseAffect(row-cnt:12) cost in 15 ms.//指定类的详细信息[arthas@89977]$ sc -d com.yiyi.api.WeixinSupportApi class-info com.yiyi.api.WeixinSupportApi code-source /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/target/classes/ name com.yiyi.api.WeixinSupportApi isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name WeixinSupportApi modifier public annotation org.springframework.web.bind.annotation.RestController,org.springframework.web.bind.annotation.RequestMapping interfaces super-class +-java.lang.Object class-loader +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-sun.misc.Launcher$ExtClassLoader@770c2e6b classLoaderHash 18b4aac2 Affect(row-cnt:1) cost in 8 ms.// 指定类的加载信息以及属性字段的信息[arthas@89977]$ sc -d -f com.yiyi.api.WeixinSupportApi class-info com.yiyi.api.WeixinSupportApi code-source /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/target/classes/ name com.yiyi.api.WeixinSupportApi isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name WeixinSupportApi modifier public annotation org.springframework.web.bind.annotation.RestController,org.springframework.web.bind.annotation.RequestMapping interfaces super-class +-java.lang.Object class-loader +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-sun.misc.Launcher$ExtClassLoader@770c2e6b classLoaderHash 18b4aac2 fields name log type org.slf4j.Logger modifier final,private,static value Logger[com.yiyi.api.WeixinSupportApi] name response type javax.servlet.http.HttpServletResponse modifier private annotation javax.annotation.Resource name CORP_ID type java.lang.String modifier final,private,static value ww91156f2c9067a7ba name APP_SECRET type java.lang.String modifier final,private,static value r5ifq9RFqtsL34sdWXmrzMytY7KYksz5cAimzoH1jeg name ACCESS_TOKEN_CACHE type com.google.common.cache.Cache modifier final,private,static value com.google.common.cache.LocalCache$LocalManualCache@39373908 Affect(row-cnt:1) cost in 10 ms. 2.1.7、mc，内存编译Memory Compiler/内存编译器，编译.java 生成.class文件 1mc /tmp/Test.java 可以通过-c指定classloader： 1mc -c 327a647b /tmp/Test.java 可以通过-d指定输出的class文件的目录 1mc -d /tmp/output /tmp/ClassA.java /tmp/ClassB.java 编译成的.class文件后，可以结合redefine命令实现热更新代码 注意，mc命令有可能失败。如果编译失败可以在本地编译好.class文件，再上传到服务器。 2.1.8、查看方法的stack12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[arthas@89977]$ stack com.yiyi.api.WeixinSupportApi getAccessToken Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 43 ms, listenerId: 8ts=2020-07-06 17:50:49;thread_name=http-nio-7070-exec-2;id=83;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@2fc07784 @com.yiyi.api.WeixinSupportApi.getAccessToken() at com.yiyi.api.WeixinSupportApi.sendMessage(WeixinSupportApi.java:68) at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) 也可以使用OGNL表达式，对请求参数进行过滤，或者使用执行时间进行过滤 2.2.1、Springboot集成arthas引入arthas的依赖 12345678910&lt;properties&gt; &lt;arthas.version&gt;3.3.6&lt;/arthas.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.taobao.arthas&lt;/groupId&gt; &lt;artifactId&gt;arthas-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;arthas.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 应用配置：application.properties 1234//指定arthas的agentIdarthas.agentId=weixin//arthas tunnel server 的websocket的地址arthas.tunnel-server=ws://localhost:7777/ws 重启应用 2.2.2、通过浏览器连接arthas第一步：下载arthas tunnel serverwget https://github.com/alibaba/arthas/releases/download/arthas-all-3.3.6/arthas-tunnel-server-3.3.6.jar第二步：启动arthas tunnel server 1java -jar arthas-tunnel-server.jar -server.port=8888 启动并指定web的端口 这个服务有两个socket连接方式，一个正常的http，用的端口是我们指定的8888，还有一个就是供显示服务器的命令行的websocket连接，端口7777第三步：访问arthas tunnel server ，我是本机测试，所以就是localhost:8888,如图： 连接指定的应用： 默认情况下，连接地址为本地，websocket的端口为7777 三、总结Arthas贵为java应用诊断神器，对于应用的资源占用，性能分析，jvm监控都有很大的支持帮助。除此之外，在排查线上问题时，可以监听对应的方法的调用，以及动态修改class类，很湿，很方便。而且Arthas对docker的java进程，以及k8s都有很好的支持，后续用到的时候在做学习。","categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Arthas","slug":"Arthas","permalink":"https://cha1yi.github.io/dist/tags/Arthas/"}],"author":"wuxuan.chai"},{"title":"通过Jackson玩转Json","slug":"通过Jackson玩转Json","date":"2021-01-17T15:46:42.338Z","updated":"2021-01-18T01:52:30.328Z","comments":true,"path":"2021/01/17/通过Jackson玩转Json/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/%E9%80%9A%E8%BF%87Jackson%E7%8E%A9%E8%BD%ACJson/","excerpt":"","text":"一、Jackson 注解示例1.1、简介在本章中，我们将深入探讨Jackson注解。我们将看到如何使用现有的注解，如何创建自定义注解，最后-如何禁用它们。 1.2、maven 依赖首先，将jackson-databind依赖项添加到pom.xml： 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 或者 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 此依赖项还将在类路径中可传递地添加以下库： jackson-annotations-2.9.8.jar jackson-core-2.9.8.jar jackson-databind-2.9.8.jar 1.3、Jackson序列化注解首先，我们来看看序列化注解。 1.3.1、@JsonAnyGetter{@JsonAnyGetter } 注解允许灵活地使用Map字段作为标准属性。这是一个简单的示例– ExtendableBean实体具有name属性和一组以键/值对形式的可扩展属性,我们还可以使用启用为false的可选参数来禁用@JsonAnyGetter()。 在这种情况下，Map将转换为JSON，并在序列化后显示在properties变量下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonAnyGetter;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.collect.Maps;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import java.util.Map;/** * @author wuxuan.chai * @date 2020/6/8 9:44 上午 */@Getter@Setter@NoArgsConstructorpublic class ExtendableBean &#123; private String name; private Map&lt;String,Object&gt; properties; private Map&lt;String,Object&gt; properties1; public String getName() &#123; return name; &#125; @JsonAnyGetter(enabled = false) public Map&lt;String, Object&gt; getProperties() &#123; return properties; &#125; @JsonAnyGetter public Map&lt;String,Object&gt; getProperties1()&#123; return properties1; &#125; public static void main(String[] args) throws JsonProcessingException &#123; ExtendableBean extendableBean = new ExtendableBean(); extendableBean.setName(&quot;wuxuan&quot;); Map&lt;String, Object&gt; map = Maps.newHashMap(); map.put(&quot;age&quot;,11); map.put(&quot;sex&quot;,&quot;male&quot;); extendableBean.setProperties(map); Map&lt;String, Object&gt; map1 = Maps.newHashMap(); map1.put(&quot;work&quot;,&quot;java pg&quot;); map1.put(&quot;no&quot;,1); extendableBean.setProperties1(map1); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(extendableBean); System.out.println(json); // result: &#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;properties&quot;:&#123;&quot;sex&quot;:&quot;male&quot;,&quot;age&quot;:11&#125;,&quot;no&quot;:1,&quot;work&quot;:&quot;java pg&quot;&#125; &#125;&#125; 1.3.1、@JsonGetter@JsonGetter注解是@JsonProperty注解的替代方法将方法标记为getter方法。在以下示例中，我们将方法getTheName() 指定为MyBeanentity的name属性的getter方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonGetter;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.naming.Name;/** * @author wuxuan.chai * @date 2020/6/8 10:06 上午 */@Setter@NoArgsConstructorpublic class MyBean &#123; private int id; private String name; @JsonGetter(&quot;name&quot;) public String getTheName()&#123; return this.name; &#125; public int getId()&#123; return this.id; &#125; public static void main(String[] args) throws JsonProcessingException &#123; MyBean myBean = new MyBean(); myBean.setId(1); myBean.setName(&quot;wuxuan&quot;); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(myBean); System.out.println(json); //result: &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125; &#125;&#125; 1.3.3、@JsonPropertyOrder我们可以使用@JsonPropertyOrder批注指定序列化属性的顺序。让我们为MyBean实体的属性设置自定义顺序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonGetter;import com.fasterxml.jackson.annotation.JsonPropertyOrder;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.naming.Name;/** * @author wuxuan.chai * @date 2020/6/8 10:06 上午 */@Setter@NoArgsConstructor@JsonPropertyOrder(&#123;&quot;name&quot;,&quot;id&quot;&#125;)public class MyBean &#123; private int id; private String name; @JsonGetter(&quot;name&quot;) public String getTheName()&#123; return this.name; &#125; public int getId()&#123; return this.id; &#125; public static void main(String[] args) throws JsonProcessingException &#123; MyBean myBean = new MyBean(); myBean.setId(1); myBean.setName(&quot;wuxuan&quot;); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(myBean); System.out.println(json); //result: &#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;id&quot;:1&#125; &#125;&#125; 我们还可以使用@JsonPropertyOrder（alphabetic = true）按字母顺序对属性进行排序。 在这种情况下，序列化的输出将是： 1&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125; 1.3.4、@JsonRawValue@JsonRawValue批注可以指示Jackson完全按原样序列化属性。在以下示例中，我们使用@JsonRawValue嵌入一些自定义JSON作为实体的值： 123456789101112131415161718192021222324252627282930313233package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonRawValue;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 10:15 上午 */@Getter@Setterpublic class RawBean &#123; public String name; @JsonRawValue(false) public String json; @SneakyThrows public static void main(String[] args) &#123; RawBean rawBean = new RawBean(); rawBean.setName(&quot;wuxuan&quot;); rawBean.setJson(&quot;&#123;\\&quot;raw\\&quot;:false&#125;&quot;); String json = new ObjectMapper().writeValueAsString(rawBean); System.out.println(json); //@JsonRawValue result: &#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;json&quot;:&#123;&quot;raw&quot;:false&#125;&#125; //@JsonRawValue(false) result: &#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;json&quot;:&quot;&#123;\\&quot;raw\\&quot;:false&#125;&quot;&#125; &#125;&#125; 我们还可以使用可选的布尔参数值来定义此注解是否处于活动状态。 1.3.5、@JsonValue@JsonValue表示库将用于序列化整个实例的单个方法。例如，在一个枚举中，我们用@JsonValue注解getName，以便任何这样的实体都通过其名称序列化： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonValue;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.AllArgsConstructor;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 10:23 上午 */@AllArgsConstructorpublic enum TypeEnumWithValue &#123; /** * 测试枚举序列化 */ TYPE1(1, &quot;wuxuan&quot;), TYPE2(2, &quot;yiyi&quot;); private final Integer id; private final String name; public Integer getId()&#123; return id; &#125; @JsonValue public String getName()&#123; return name; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = new ObjectMapper().writeValueAsString(TYPE1); System.out.println(json); //result: &quot;wuxuan&quot; &#125;&#125; 1.3.6、@JsonRootName如果启用了包装，则使用@JsonRootName批注指定要使用的根包装的名称。包装意味着不要将用户序列化为以下内容： 1234&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;wuxuan&quot;&#125; 而是序列化为： 123456&#123; &quot;user&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;wuxuan&quot; &#125;&#125; 因此，让我们看一个示例–我们将使用@JsonRootName批注指示此潜在包装实体的名称： 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonRootName;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 10:30 上午 */@JsonRootName(&quot;user&quot;)@Getter@Setterpublic class UserWithRoot &#123; private Integer id; private String name; @SneakyThrows public static void main(String[] args) &#123; UserWithRoot userWithRoot = new UserWithRoot(); userWithRoot.setId(1); userWithRoot.setName(&quot;wuxuan&quot;); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.enable(SerializationFeature.WRAP_ROOT_VALUE); String json = objectMapper.writeValueAsString(userWithRoot); System.out.println(json); //result: &#123;&quot;user&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125;&#125; &#125;&#125; 默认情况下，包装器的名称将为类– UserWithRoot。 通过使用注解，我们得到了看上去更干净的用户： 123456&#123; &quot;user&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;wuxuan&quot; &#125;&#125; 从Jackson 2.4开始，新的可选参数名称空间可用于XML之类的数据格式。 如果添加它，它将成为标准名称的一部分： 12345678910111213141516171819202122232425262728293031323334353637383940package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonRootName;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import com.fasterxml.jackson.dataformat.xml.XmlMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 10:30 上午 */@JsonRootName(value = &quot;user&quot;,namespace = &quot;users&quot;)@Getter@Setterpublic class UserWithRoot &#123; private Integer id; private String name; @SneakyThrows public static void main(String[] args) &#123; UserWithRoot userWithRoot = new UserWithRoot(); userWithRoot.setId(1); userWithRoot.setName(&quot;wuxuan&quot;); XmlMapper xmlMapper = new XmlMapper(); xmlMapper.enable(SerializationFeature.WRAP_ROOT_VALUE); String xml = xmlMapper.writeValueAsString(userWithRoot); System.out.println(xml);// result:// &lt;user xmlns=&quot;users&quot;&gt;// &lt;id xmlns=&quot;&quot;&gt;1&lt;/id&gt;// &lt;name xmlns=&quot;&quot;&gt;wuxuan&lt;/name&gt;// &lt;/user&gt; &#125;&#125; 序列化的xmlMapper结果为： 1234&lt;user xmlns=&quot;users&quot;&gt; &lt;id xmlns=&quot;&quot;&gt;1&lt;/id&gt; &lt;name xmlns=&quot;&quot;&gt;wuxuan&lt;/name&gt;&lt;/user&gt; 1.3.6、@JsonSerialize@JsonSerialize表示在编组实体时要使用的自定义序列化程序。让我们看一个简单的例子。 我们将使用@JsonSerialize通过CustomDateSerializer序列化eventDate属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yiyi.entity;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.annotation.JsonSerialize;import com.yiyi.annotation.support.CustomDateSerializer;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import java.text.SimpleDateFormat;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 10:45 上午 */@Getter@Setterpublic class Event &#123; public String name; @JsonSerialize(using = CustomDateSerializer.class) public Date eventDate; @SneakyThrows public static void main(String[] args) &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;dd-MM-yyy hh:mm:ss&quot;); Event event = new Event(); event.setName(&quot;wuxuan coming&quot;); Date eventDate = new Date(); event.setEventDate(eventDate); System.out.println(simpleDateFormat.format(eventDate)); String json = new ObjectMapper().writeValueAsString(event); System.out.println(json); //result: 08-06-2020 10:54:12 //result: &#123;&quot;name&quot;:&quot;wuxuan coming&quot;,&quot;eventDate&quot;:&quot;08-06-2020 10:52:37&quot;&#125; &#125;&#125; 1.4、Jackson 反序列化的注解接下来，开始探索Jackson的反序列化的注解 1.4.1、@JsonCreator我们可以使用@JsonCreator批注来调整反序列化中使用的构造函数/工厂。 当我们需要反序列化某些与我们需要获取的目标实体不完全匹配的JSON时，这非常有用。看下面的例子，我们需要反序列化这个json： 1234&#123; &quot;id&quot;: 1, &quot;the name&quot;: &quot;wuxuan&quot;&#125; 但是，我们的目标实体中没有TheName字段-只有一个name字段。 现在，我们不想更改实体本身-我们只需要对解组过程进行更多控制-通过使用@JsonCreator注解构造函数并同时使用@JsonProperty注解： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JsonProperty;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 11:04 上午 */@Getter@Setter@ToStringpublic class BeanWithCreator &#123; private int id; private String name; public BeanWithCreator(@JsonProperty(&quot;id&quot;) int id,@JsonProperty(&quot;the name&quot;) String name) &#123; this.id = id; this.name = name; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot;\\&quot;id\\&quot;: 1,\\n&quot; + &quot;\\&quot;the name\\&quot;: \\&quot;wuxuan\\&quot;\\n&quot; + &quot;&#125;&quot;; BeanWithCreator value = new ObjectMapper().readerFor(BeanWithCreator.class).readValue(json); System.out.println(value.toString()); //result: BeanWithCreator(id=1, name=wuxuan) &#125;&#125; 1.4.2. @JacksonInject@JacksonInject指示属性将从注入而不是从JSON数据获取其值。 1234567891011121314151617181920212223242526272829303132package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JacksonInject;import com.fasterxml.jackson.databind.InjectableValues;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 11:15 上午 */@Getter@Setterpublic class BeanWithInject &#123; @JacksonInject private int id; private String name; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\&quot;name\\&quot;: \\&quot;wuxuan\\&quot;&#125;&quot;; InjectableValues.Std std = new InjectableValues.Std().addValue(int.class, 1); BeanWithInject beanWithInject = new ObjectMapper().reader(std).forType(BeanWithInject.class).readValue(json); System.out.println(beanWithInject.id == 1); //result: true &#125;&#125; 1.4.3. @JsonAnySetter@JsonAnySetter使我们可以灵活地使用Map作为标准属性。 反序列化时，JSON的属性将被简单地添加到Map中。让我们看看它是如何工作的–我们将使用@JsonAnySetter反序列化实体ExtendableBean，将下列的json反序列化： 12345&#123; &quot;name&quot;:&quot;My bean&quot;, &quot;attr2&quot;:&quot;val2&quot;, &quot;attr1&quot;:&quot;val1&quot;&#125; 如何使用@JsonAnySetter注解： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JsonAnySetter;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import lombok.ToString;import java.util.HashMap;import java.util.Map;/** * @author wuxuan.chai * @date 2020/6/8 11:21 上午 */@Getter@Setter@ToStringpublic class ExtendableBean &#123; private String name; private Map&lt;String,Object&gt; properties = new HashMap&lt;&gt;(); @JsonAnySetter public void setProperties(String key,String value)&#123; properties.put(key,value); &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;name\\&quot;:\\&quot;My bean\\&quot;,\\n&quot; + &quot; \\&quot;attr2\\&quot;:\\&quot;val2\\&quot;,\\n&quot; + &quot; \\&quot;attr1\\&quot;:\\&quot;val1\\&quot;\\n&quot; + &quot;&#125;&quot;; ExtendableBean extendableBean = new ObjectMapper().readerFor(ExtendableBean.class).readValue(json); System.out.println(extendableBean.toString()); //result: ExtendableBean(name=My bean, properties=&#123;attr2=val2, attr1=val1&#125;) &#125;&#125; 1.4.4. @JsonSetter@JsonSetter是@JsonProperty的替代方法––将方法标记为设置方法。当我们需要读取一些JSON数据但目标实体类与数据不完全匹配时，这非常有用，因此我们需要调整过程以使其适合。在以下示例中，我们将在MyBeanentity中将setTheName()方法指定为name属性的设置方法： 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JsonSetter;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 11:36 上午 */@Getterpublic class MyBean &#123; @Setter private int id; private String theName; @JsonSetter(&quot;name&quot;) public void setTheName(String name)&#123; this.theName = name; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;id\\&quot;: 1,\\n&quot; + &quot; \\&quot;name\\&quot;: \\&quot;wuxuan\\&quot;\\n&quot; + &quot;&#125;&quot;; MyBean myBean = new ObjectMapper().readerFor(MyBean.class).readValue(json); System.out.println(myBean.getTheName().equals(&quot;wuxuan&quot;)); &#125;&#125; 1.4.5. @JsonDeserialize@JsonDeserialize指示使用自定义解串器。让我们看一下效果如何–我们将使用@JsonDeserialize通过CustomDateDeserializer反序列化eventDate属性： 12345678910111213141516171819202122232425262728293031323334353637package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.annotation.JsonDeserialize;import com.yiyi.annotation.support.CustomDateDeserializer;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import java.text.SimpleDateFormat;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 11:41 上午 */@Getter@Setterpublic class Event &#123; private String name; @JsonDeserialize(using = CustomDateDeserializer.class) private Date eventDate; @SneakyThrows public static void main(String[] args) &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;dd-MM-yyy hh:mm:ss&quot;); Date parse = simpleDateFormat.parse(&quot;08-06-2020 10:52:37&quot;); String json = &quot;&#123;\\&quot;name\\&quot;:\\&quot;wuxuan coming\\&quot;,\\&quot;eventDate\\&quot;:\\&quot;08-06-2020 10:52:37\\&quot;&#125;&quot;; Event event = new ObjectMapper().readerFor(Event.class) .readValue(json); System.out.println(parse.equals(event.eventDate)); //result: true &#125;&#125; 1.4.6. @JsonAlias@JsonAlias在反序列化期间为属性定义一个或多个备用名称。 让我们用一个简单的例子来看看这个注解是如何工作的： 12345678910111213141516171819202122232425262728293031323334package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JsonAlias;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 11:52 上午 */@Getter@Setterpublic class AliasBean &#123; @JsonAlias(&#123;&quot;f_name&quot;,&quot;fName&quot;&#125;) private String firstName; private String secondName; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;f_name\\&quot;: \\&quot;chai\\&quot;,\\n&quot; + &quot; \\&quot;secondName\\&quot;: \\&quot;wuxuan\\&quot;\\n&quot; + &quot;&#125;&quot;; AliasBean aliasBean= new ObjectMapper().readerFor(AliasBean.class).readValue(json); System.out.println(aliasBean.getFirstName().equals(&quot;chai&quot;)); //result: true &#125;&#125; 1.5、Jackson多态类型处理注解接下来–让我们看一下Jackson的多态类型处理注解： @JsonTypeInfo - 指示要在序列化中包含哪些类型信息的详细信息 @JsonSubTypes - 指示带注解类型的子类型 @JsonTypeName - 定义用于注解类的逻辑类型名称让我们看一个更复杂的示例，并使用全部三个@ JsonTypeInfo，@ JsonSubTypes和@JsonTypeName来序列化/反序列化实体Zoo： 123456789101112131415161718192021222324252627282930package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 12:54 下午 */@Getter@Setterpublic class Zoo &#123; public Animal animal; @SneakyThrows public static void main(String[] args) &#123; Dog dog = new Dog(); dog.setName(&quot;wangwang&quot;); dog.setBackVolume(2.0); Zoo zoo = new Zoo(); zoo.setAnimal(dog); String json = new ObjectMapper().writeValueAsString(zoo); System.out.println(json); //result: &#123;&quot;animal&quot;:&#123;&quot;type&quot;:&quot;dog&quot;,&quot;name&quot;:&quot;wangwang&quot;,&quot;backVolume&quot;:2.0&#125;&#125; &#125;&#125; 12345678910111213141516171819package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.annotation.JsonSubTypes;import com.fasterxml.jackson.annotation.JsonTypeInfo;import lombok.Getter;import lombok.Setter;/** * @author wuxuan.chai * @date 2020/6/8 12:54 下午 */@Getter@Setter@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;type&quot;)@JsonSubTypes(&#123;@JsonSubTypes.Type(value = Dog.class, name = &quot;dog&quot;), @JsonSubTypes.Type(value = Cat.class, name = &quot;cat&quot;)&#125;)public class Animal &#123; private String name;&#125; 1234567891011121314151617package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.annotation.JsonTypeName;import lombok.Getter;import lombok.Setter;/** * @author wuxuan.chai * @date 2020/6/8 12:54 下午 */@Getter@Setter@JsonTypeName(&quot;dog&quot;)public class Dog extends Animal &#123; public double backVolume;&#125; 1234567891011121314151617package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.annotation.JsonTypeName;import lombok.Getter;import lombok.Setter;/** * @author wuxuan.chai * @date 2020/6/8 12:56 下午 */@Getter@Setter@JsonTypeName(&quot;cat&quot;)public class Cat extends Animal&#123; private boolean likesCream; private int lives;&#125; 现在测试反序列化： 12345678&#123; &quot;animal&quot;: &#123; &quot;type&quot;:&quot;dog&quot;, &quot;name&quot;:&quot;wangwang&quot;, &quot;backVolume&quot;:2.0 &#125;&#125; 1234567891011121314151617181920212223242526272829package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 12:54 下午 */@Getter@Setter@ToStringpublic class Zoo &#123; public Animal animal; @SneakyThrows public static void main(String[] args) &#123; String dJson = &quot;&#123;\\&quot;animal\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;dog\\&quot;,\\&quot;name\\&quot;:\\&quot;wangwang\\&quot;,\\&quot;backVolume\\&quot;:2.0&#125;&#125;&quot;; Zoo zoo1 = new ObjectMapper().readerFor(Zoo.class).readValue(dJson); System.out.println(zoo1); //result: Zoo(animal=Dog(backVolume=2.0)) &#125;&#125; 1.6、Jackson一般的注解接下来，一起讨论一些jackson的一般注解 1.6.1、@JsonProperty我们可以添加@JsonProperty注解去表示在json中的属性名称，在处理非标准的getter和setter时，让我们使用@JsonProperty对属性名称进行序列化/反序列化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonProperty;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 1:47 下午 */public class MyBean &#123; @Getter @Setter private Integer id; private String theName; @JsonProperty(&quot;name&quot;) public void setTheName(String name) &#123; this.theName = name; &#125; @JsonProperty(&quot;name&quot;) public String getTheName() &#123; return theName; &#125; @SneakyThrows public static void main(String[] args) &#123; MyBean myBean = new MyBean(); myBean.setId(1); myBean.setTheName(&quot;wuxuan&quot;); String json = new ObjectMapper().writeValueAsString(myBean); System.out.println(json); MyBean myBean1 = new ObjectMapper().readerFor(MyBean.class).readValue(json); System.out.println(myBean1.theName.equals(myBean.theName)); //reasult: //&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125; //true &#125;&#125; 1.6.2、@JsonFormat@JsonFormat批注指定序列化日期/时间值时的格式。在下面的示例中，我们使用@JsonFormat来控制属性eventDate的格式： 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonFormat;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.*;import java.text.SimpleDateFormat;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 1:53 下午 */@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Event &#123; private String name; @JsonFormat(shape = JsonFormat.Shape.STRING,pattern = &quot;dd-MM-yyyy hh:mm:ss&quot;) private Date eventDate; @SneakyThrows public static void main(String[] args) &#123; Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;dd-MM-yyyy hh:mm:ss&quot;); String format = simpleDateFormat.format(date); Event event = new Event(&quot;wuxuan comming&quot;, date); String json = new ObjectMapper().writeValueAsString(event); assert json.contains(format); &#125;&#125; 1.6.3、@JsonUnWrapped@JsonUnwrapped定义应展开/展平的值序列化/反序列化时。让我们看看它是如何工作的； 我们将使用注解解开属性名称： 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonUnwrapped;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 2:01 下午 */@Datapublic class UnwappedUser &#123; private int id; @JsonUnwrapped(prefix = &quot;n_&quot;,suffix = &quot;_o&quot;,enabled = true) private Name name; @Data public static class Name&#123; private String firstName; private String lastName; &#125; @SneakyThrows public static void main(String[] args) &#123; Name name = new Name(); name.setFirstName(&quot;chai&quot;); name.setLastName(&quot;wuxuan&quot;); UnwappedUser unwappedUser = new UnwappedUser(); unwappedUser.setName(name); String json = new ObjectMapper().writeValueAsString(unwappedUser); System.out.println(json); //result: &#123;&quot;id&quot;:0,&quot;n_firstName_o&quot;:&quot;chai&quot;,&quot;n_lastName_o&quot;:&quot;wuxuan&quot;&#125; &#125;&#125; 1.6.4、@JsonView@JsonView指示将在其中包含属性以进行序列化/反序列化的View。一个示例将确切显示其工作原理-我们将使用@JsonView序列化Item实体的实例。 让我们从视图开始： 123456789101112131415161718192021222324252627282930package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonView;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.AllArgsConstructor;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 2:08 下午 */@Data@AllArgsConstructorpublic class Item &#123; @JsonView(Views.Public.class) private Integer id; @JsonView(Views.Public.class) private String itemName; @JsonView(Views.internal.class) private String ownerName; @SneakyThrows public static void main(String[] args) &#123; Item item = new Item(1, &quot;wuxuan&quot;, &quot;wuxuan111&quot;); String json = new ObjectMapper().writerWithView(Views.Public.class).writeValueAsString(item); System.out.println(json); &#125;&#125; 1.6.5. @JsonManagedReference, @JsonBackReference@JsonManagedReference和@JsonBackReference注解可以处理父/子关系并解决循环。在以下示例中–我们使用@JsonManagedReference和@JsonBackReference序列化我们的ItemWithRefentity： 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonManagedReference;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.collect.Lists;import lombok.AllArgsConstructor;import lombok.Data;import lombok.SneakyThrows;import java.util.List;/** * @author wuxuan.chai * @date 2020/6/8 2:18 下午 */@Data@AllArgsConstructorpublic class ItemWithRef &#123; private int id; private String itemName; @JsonManagedReference public UserWithRef owner; @SneakyThrows public static void main(String[] args) &#123; UserWithRef userWithRef = new UserWithRef(1,&quot;wuxuan&quot;,null); ItemWithRef itemWithRef = new ItemWithRef(1, &quot;wwww&quot;, null); List&lt;ItemWithRef&gt; itemWithRefs = Lists.newArrayList(); itemWithRefs.add(itemWithRef); userWithRef.setUserItems(itemWithRefs); String json = new ObjectMapper().writeValueAsString(userWithRef); System.out.println(json); //result: &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonBackReference;import com.google.common.collect.Lists;import lombok.AllArgsConstructor;import lombok.Data;import java.util.List;/** * @author wuxuan.chai * @date 2020/6/8 2:19 下午 */@Data@AllArgsConstructorpublic class UserWithRef &#123; public int id; private String name; @JsonBackReference public List&lt;ItemWithRef&gt; userItems; public List&lt;ItemWithRef&gt; addItem(ItemWithRef itemWithRef) &#123; if (userItems == null)&#123; userItems = Lists.newArrayList(); userItems.add(itemWithRef); return userItems; &#125; userItems.add(itemWithRef); return userItems; &#125;&#125; 处理循环调用的场景 1.6.6. @JsonIdentityInfo@JsonIdentityInfo指示在对值进行序列化/反序列化时应使用对象标识，例如，以处理无限递归类型的问题。在以下示例中–我们有一个ItemWithIdentity实体，它与UserWithIdentity实体具有双向关系： 1234567891011121314151617181920212223242526272829303132333435363738package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonIdentityInfo;import com.fasterxml.jackson.annotation.ObjectIdGenerators;import com.google.common.collect.Lists;import lombok.Data;import java.util.List;/** * @author wuxuan.chai * @date 2020/6/8 2:30 下午 */@Data@JsonIdentityInfo( generator= ObjectIdGenerators.PropertyGenerator.class, property = &quot;id&quot;)public class UserWithIdentity &#123; private Integer id; private String name; private List&lt;ItemWithIdentity&gt; userItems; public UserWithIdentity(Integer id, String name) &#123; this.id = id; this.name = name; &#125; public void addItem(ItemWithIdentity item) &#123; if (userItems == null)&#123; userItems = Lists.newArrayList(); userItems.add(item); return; &#125; userItems.add(item); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonIdentityInfo;import com.fasterxml.jackson.annotation.ObjectIdGenerators;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 2:29 下午 */@JsonIdentityInfo( generator = ObjectIdGenerators.PropertyGenerator.class, property = &quot;id&quot;)@Datapublic class ItemWithIdentity &#123; private Integer id; private String itemName; private UserWithIdentity owner; public ItemWithIdentity(Integer id, String itemName, UserWithIdentity owner) &#123; this.id = id; this.itemName = itemName; this.owner = owner; &#125; @SneakyThrows public static void main(String[] args) &#123; UserWithIdentity user = new UserWithIdentity(1, &quot;John&quot;); ItemWithIdentity item = new ItemWithIdentity(2, &quot;book&quot;, user); user.addItem(item); String json = new ObjectMapper().writeValueAsString(item); System.out.println(json); //result: &#123;&quot;id&quot;:2,&quot;itemName&quot;:&quot;book&quot;,&quot;owner&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;userItems&quot;:[2]&#125;&#125; &#125;&#125; 1.6.7. @JsonFilter@JsonFilter批注指定在序列化期间使用的过滤器。让我们看一个例子； 首先，我们定义实体，然后指向过滤器： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonFilter;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 2:47 下午 */@JsonFilter(&quot;myFilter&quot;)@Datapublic class BeanWithFilter &#123; private Integer id; private String name; public BeanWithFilter(Integer id, String name) &#123; this.id = id; this.name = name; &#125; @SneakyThrows public static void main(String[] args) &#123; BeanWithFilter beanWithFilter = new BeanWithFilter(1, &quot;Wuxuuan&quot;); String json = new ObjectMapper() .writer(new SimpleFilterProvider() .addFilter(&quot;myFilter&quot;, SimpleBeanPropertyFilter.filterOutAllExcept(&quot;name&quot;))) .writeValueAsString(beanWithFilter); System.out.println(json); //result: &#123;&quot;name&quot;:&quot;Wuxuuan&quot;&#125; &#125;&#125; 1.7、自定义Jackson注解接下来，我们一起学习如何创建一个Jackson自定义注解，我们可以使用@JacksonAnnotationsInside注解： 123456789101112131415161718192021222324package com.yiyi.annotation.customAnnotation;import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.annotation.JsonPropertyOrder;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @author wuxuan.chai * @date 2020/6/8 2:54 下午 * * 运行时注解 * json包含非空 * json排序 */@Retention(RetentionPolicy.RUNTIME)@JacksonAnnotationsInside@JsonInclude(JsonInclude.Include.NON_NULL)@JsonPropertyOrder(&#123;&quot;name&quot;,&quot;id&quot;,&quot;datteCreated&quot;&#125;)public @interface CustomAnnotation &#123;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.annotation.customAnnotation;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 2:56 下午 */@CustomAnnotation@Datapublic class BeanWithCustomAnnotation &#123; private Integer id; private String name; private Date dateCreated; public BeanWithCustomAnnotation(Integer id, String name, Date dateCreated) &#123; this.id = id; this.name = name; this.dateCreated = dateCreated; &#125; @SneakyThrows public static void main(String[] args) &#123; BeanWithCustomAnnotation bean = new BeanWithCustomAnnotation(1, &quot;wuxuan&quot;, new Date()); String json = new ObjectMapper().writeValueAsString(bean); System.out.println(json); //result：&#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;id&quot;:1,&quot;dateCreated&quot;:1591599545147&#125; &#125;&#125; 1.8、Jackson 混入注解接下来，让我们一起看看如何使用Jackson的混入注解，让我们用混入注解举个例子 - 忽略User类中的属性： 12345678910111213package com.yiyi.annotation.mixln;import lombok.Data;/** * @author wuxuan.chai * @date 2020/6/8 3:05 下午 */@Datapublic class User &#123; private String sex;&#125; 123456789101112package com.yiyi.annotation.mixln;import com.fasterxml.jackson.annotation.JsonIgnoreType;/** * @author wuxuan.chai * @date 2020/6/8 3:06 下午 */@JsonIgnoreTypepublic class MyMixinForIgnoreType &#123;&#125; 12345678910111213141516171819202122232425262728293031323334353637package com.yiyi.annotation.mixln;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 3:04 下午 */@Datapublic class Item &#123; private Integer id; private String itemName; private User owner; public Item(Integer id, String itemName, User owner) &#123; this.id = id; this.itemName = itemName; this.owner = owner; &#125; @SneakyThrows public static void main(String[] args) &#123; Item item = new Item(1, &quot;ccc&quot;, null); String json = new ObjectMapper().writeValueAsString(item); //检查是否序列化了User类型 assert json.contains(&quot;owner&quot;); ObjectMapper objectMapper = new ObjectMapper().addMixIn(User.class, MyMixinForIgnoreType.class); String json1 = objectMapper.writeValueAsString(item); //检查是否忽略了User类型 assert !json1.contains(&quot;owner&quot;); &#125;&#125; 1.9、禁用 Jackson 注解最后，我们一起看看如何禁用所有的jackson注解，我们可以通过禁用MapperFeature.USE_ANNOTATIONS来实现此目的，如以下示例所示： 12345678910111213141516171819202122232425262728293031323334353637package com.yiyi.annotation.disabledJson;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.annotation.JsonPropertyOrder;import com.fasterxml.jackson.databind.MapperFeature;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 3:13 下午 */@Data@JsonInclude(JsonInclude.Include.NON_NULL)@JsonPropertyOrder(&#123;&quot;name&quot;,&quot;id&quot;&#125;)public class MyBean &#123; private String id; private String name; public MyBean(String id, String name) &#123; this.id = id; this.name = name; &#125; @SneakyThrows public static void main(String[] args) &#123; MyBean wuxuan = new MyBean(&quot;1&quot;, &quot;wuxuan&quot;); String json = new ObjectMapper().disable(MapperFeature.USE_ANNOTATIONS).writeValueAsString(wuxuan); System.out.println(json); //期望，非空校验和排序注解都失效 //result：&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;wuxuan&quot;&#125; &#125;&#125; 二、Jackson ObjectMapper 的简介2.1、简介本章着重于理解Jackson ObjectMapper类，以及如何将Java对象序列化为JSON以及如何将JSON字符串反序列化为Java对象。 2.2、使用ObjectMapper读和写让我们从基本的读写操作开始。ObjectMapper的简单readValue API是一个很好的入口点。 我们可以使用它来将JSON内容解析或反序列化为Java对象。同样，在编写方面，我们可以使用writeValue API将任何Java对象序列化为JSON输出。在本章中，我们将使用以下带有两个字段的Car类作为对象进行序列化或反序列化： 1234567891011121314package com.yiyi.objectMapper.using;import lombok.Data;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Datapublic class Car &#123; private String color; private String type;&#125; 2.2.1、Java对象序列化成json让我们一起学习第一个序列化例子，用ObjectMapper类的writeValue将java转换成json 1234567891011121314151617181920212223242526272829package com.yiyi.objectMapper.using;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import java.io.File;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Datapublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; @SneakyThrows public static void main(String[] args) &#123; Car car = new Car(&quot;red&quot;, &quot;BMW&quot;); new ObjectMapper().writeValue(new File(&quot;/Users/wuxuan.chai/Documents/project/springboot-learn/Jackson/src/main/java/com/yiyi/objectMapper/using/Car.json&quot;),car); &#125;&#125; 运行结果： 1234生成一个Car.json文件内容：&#123;&quot;color&quot;:&quot;red&quot;,&quot;type&quot;:&quot;BMW&quot;&#125; ObjectMapper类的writeValueAsString和writeValueAsBytes方法从Java对象生成JSON，并以字符串或字节数组形式返回生成的JSON： 12345678910111213141516171819202122232425262728293031323334package com.yiyi.objectMapper.using;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import java.io.File;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Datapublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; @SneakyThrows public static void main(String[] args) &#123; Car car = new Car(&quot;red&quot;, &quot;BMW&quot;); String json = new ObjectMapper().writeValueAsString(car); System.out.println(json); byte[] bytes = new ObjectMapper().writeValueAsBytes(car); String bytesStr = new String(bytes); System.out.println(json.equals(bytesStr)); &#125;&#125; 运行结果： 12&#123;&quot;color&quot;:&quot;red&quot;,&quot;type&quot;:&quot;BMW&quot;&#125;true 2.2.2、Json转换成Java对象以下是使用ObjectMapper类将JSON字符串转换为Java对象的简单示例： 1&#123;&quot;color&quot;:&quot;red&quot;,&quot;type&quot;:&quot;BMW&quot;&#125; readValue（）函数还接受其他形式的输入，例如包含JSON字符串的文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.objectMapper.using;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import java.io.File;import java.net.URL;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Data@EqualsAndHashCodepublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; public Car()&#123; &#125; @SneakyThrows public static void main(String[] args) &#123; Car car = new Car(&quot;red&quot;, &quot;BMW&quot;); String json = &quot;&#123;\\&quot;color\\&quot;:\\&quot;red\\&quot;,\\&quot;type\\&quot;:\\&quot;BMW\\&quot;&#125;&quot;; Car car1 = new ObjectMapper().readValue(json, Car.class); System.out.println(car1.equals(car)); Car car2 = new ObjectMapper().readValue(new File(&quot;/Users/wuxuan.chai/Documents/project/springboot-learn/Jackson/src/main/java/com/yiyi/objectMapper/using/Car.json&quot;), Car.class); System.out.println(car2.equals(car)); //result： // true // true &#125;&#125; 2.2.3、Json转换成Jackson的Json节点另外，可以将JSON解析为JsonNode对象，并用于从特定节点检索数据： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.yiyi.objectMapper.using;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import java.io.File;import java.net.URL;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Data@EqualsAndHashCodepublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; public Car()&#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\&quot;color\\&quot;:\\&quot;red\\&quot;,\\&quot;type\\&quot;:\\&quot;BMW\\&quot;&#125;&quot;; JsonNode jsonNode = new ObjectMapper().readTree(json); String type = jsonNode.get(&quot;type&quot;).asText(); System.out.println(type.equals(&quot;BMW&quot;)); //result: true &#125;&#125; 2.2.4、从Json数组字符串中创建Java集合我们可以使用TypeReference将数组形式的JSON解析为Java对象列表： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.yiyi.objectMapper.using;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;import java.util.List;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Data@EqualsAndHashCode@ToStringpublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; public Car()&#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String jsonArray = &quot;[\\n&quot; + &quot; &#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;BMW\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; &#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Black\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;audi\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;]&quot;; List&lt;Car&gt; cars = new ObjectMapper().readValue(jsonArray, new TypeReference&lt;List&lt;Car&gt;&gt;()&#123;&#125;); System.out.println(cars); //result: [Car(color=Red, type=BMW), Car(color=Black, type=audi)] &#125;&#125; 2.2.5、从json中创建Java Map同样，我们可以将JSON解析为Java Map： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.objectMapper.using;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;import java.util.List;import java.util.Map;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Data@EqualsAndHashCode@ToStringpublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; public Car()&#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;BMW\\&quot;\\n&quot; + &quot;&#125;&quot;; Map&lt;String, String&gt; javaMap = new ObjectMapper().readValue(json, new TypeReference&lt;Map&lt;String, String&gt;&gt;() &#123;&#125;); System.out.println(javaMap); //result: &#123;color=Red, type=BMW&#125; &#125;&#125; 三、高级功能Jackson库的最大优势之一是高度可定制的序列化和反序列化过程。在本部分中，我们将介绍一些高级功能，其中输入或输出JSON响应可能不同于生成或使用响应的对象。 3.1、 配置 Serialization / Deserialization 功能在将JSON对象转换为Java类时，如果JSON字符串具有一些新字段，则默认过程将导致异常： 12345&#123; &quot;color&quot;: &quot;Red&quot;, &quot;type&quot;: &quot;BMW&quot;, &quot;year&quot;: &quot;2020&quot;&#125; 上面示例中的默认解析过程中，针对Car类的Java对象的JSON字符串将导致UnrecognizedPropertyException异常。通过configure方法，我们可以扩展默认过程以忽略新字段： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yiyi.advanced;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 3:59 下午 */@Data@ToString@EqualsAndHashCodepublic class Car &#123; private String type; private String color; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;BMW\\&quot;,\\n&quot; + &quot; \\&quot;year\\&quot;: \\&quot;2020\\&quot;\\n&quot; + &quot; &#125;&quot;; // 也可以这么写： new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false); ObjectMapper objectMapper = new ObjectMapper().disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); Car car = objectMapper.readValue(json, Car.class); System.out.println(car); JsonNode jsonNode = objectMapper.readTree(json); String year = jsonNode.get(&quot;year&quot;).asText(); System.out.println(year); &#125;&#125; 对于DeserializationFeature枚举中中的设置的描述： 配置 默认值 作用描述 USE_BIG_DECIMAL_FOR_FLOATS false 如果只有通用类型描述（Object或Number或未类型化的java.util.Map或java.util.Collection上下文中）可用，此功能确定是否将JSON浮点数反序列化为java.math.BigDecimals。 如果启用，则将这些值反序列化为java.math.BigDecimals;。 如果禁用，将反序列化为Doubles。默认情况下，此功能为禁用状态，这意味着默认情况下，“未类型化”的浮点数将反序列化为Doubles（出于性能考虑，选择-BigDecimals慢于Doubles）。 USE_BIG_INTEGER_FOR_INTS false 确定是否将JSON整数（非浮点数）数字反序列化为java.math.BigIntegers的功能（如果只有通用类型描述（Object或Number或在无类型的java.util.Map或java.util.Collection上下文中） ）可用。 如果启用，则将这些值反序列化为java.math.BigIntegers;。 如果禁用，则将反序列化为“最小”可用类型，根据类型的数目，可以是Integer，Long或java.math.BigInteger。默认情况下，此功能是禁用的，这意味着默认情况下，将使用最紧凑的整数类型对“未类型化”的整数进行反序列化，以优化效率。 USE_LONG_FOR_INTS false 当目标类型被松散地键入为Object或Number（或在其中）时，用于确定如何绑定“小” JSON整数（非浮点数）（适合32位有符号整数（int））的功能 未类型化的java.util.Map或java.util.Collection上下文）。 如果启用，则这些值将反序列化为Long； 如果禁用，它们将反序列化为“最小”可用类型，整数。 此外，如果启用了该选项，则尝试绑定不适合Long的值将引发com.fasterxml.jackson.core.JsonProcessingException。注意：如果启用USE_BIG_INTEGER_FOR_INTS，它将优先于此设置，并强制对所有整数值使用java.math.BigInteger。该功能默认情况下处于禁用状态，这意味着如果值合适，默认情况下将使用Integer反序列化“无类型”整数。 USE_JAVA_ARRAY_FOR_JSON_ARRAY false 绑定“无类型”对象（标称类型为java.lang.Object的对象）时确定JSON数组是映射到Object[]还是List的功能。 如果为true，则绑定为Object[]; 如果为false，则为List。默认情况下，功能是禁用的，这意味着JSON数组绑定为java.util.Lists。 FAIL_ON_UNKNOWN_PROPERTIES true 确定遇到未知属性（不映射到属性，并且没有“任何setter”或处理程序的处理程序）的功能是否会导致失败（通过抛出JsonMappingException）。 仅在尝试了其他所有用于未知属性的处理方法并且该属性保持未处理状态后，此设置才生效。 默认情况下启用此功能（这意味着如果遇到未知属性，将抛出JsonMappingException）。 FAIL_ON_NULL_FOR_PRIMITIVES false 反序列化为Java基本类型（如“ int”或“ double”）时，确定是否遇到JSON null的错误的功能。 如果是，则抛出JsonProcessingException来表明这一点。 如果不是，则使用默认值（0表示“ int”，0.0表示double，与JVM使用的默认值相同）。默认情况下禁用此功能。 FAIL_ON_NUMBERS_FOR_ENUMS false 确定JSON整数是否是用于反序列化Java枚举值的有效值的功能。 如果设置为“ false”，则数字是可接受的，并用于映射到匹配枚举值的ordinal（）； 如果为“ true”，则不允许数字，并且将引发JsonMappingException。 如果担心可能会发生从整数值到枚举的意外映射（并且枚举始终序列化为JSON字符串的情况），那么后者的行为就很有意义。默认情况下禁用此功能。 FAIL_ON_INVALID_SUBTYPE true 确定无法找到（丢失）或解决（丢失）类名称（例如，无效的类名，不可映射的id）的多态值的类型（例如，由com.fasterxml.jackson.annotation.JsonTypeInfo指示）时发生的情况的功能； 如果启用，则引发异常； 如果为false，则使用null值。默认情况下启用功能，以便因缺少类型信息或无效类型信息而引发异常。 FAIL_ON_READING_DUP_TREE_KEY false 该功能确定在将JSON内容读入树（com.fasterxml.jackson.core.TreeNode）并遇到重复键（已为JSON对象看到的属性名称）时发生什么情况。 如果启用，将抛出JsonMappingException； 如果禁用，则不会引发异常，并且新的（较新的）值将覆盖较早的值。请注意，此属性不会影响数据绑定的其他方面。 也就是说，不对POJO属性或java.util.Map键进行检测。 可以添加新功能来控制其他情况。默认情况下，功能是禁用的，因此不会引发异常。 FAIL_ON_IGNORED_PROPERTIES false 确定在输入中遇到显式标记为可忽略的属性时将发生什么的功能：如果启用了功能，则抛出JsonMappingException； 如果为false，则默默地跳过属性。 默认情况下，功能是禁用的，因此不会引发异常。 FAIL_ON_UNRESOLVED_OBJECT_IDS true 确定遇到的对象ID引用不引用具有该ID的实际对象（“未解决的对象ID”）的情况时发生的功能：抛出异常（true），或者使用空对象代替（false） 。 请注意，如果将其设置为false，则不会进行进一步处理； 具体来说，如果引用是通过setter方法定义的，则不会调用该方法。默认情况下启用此功能，以便在反序列化结束时，未知的对象ID将导致引发异常。 FAIL_ON_MISSING_CREATOR_PROPERTIES false 该功能确定一个或多个创建者属性（绑定到创建者方法（构造函数或静态工厂方法）的参数的属性）缺少要从内容绑定到的值时发生的情况。 如果启用，则此类缺少的值会导致抛出JsonMappingException并附带第一个（按索引）缺少的属性的信息。 如果禁用，并且未将属性标记为必需，则缺少的Creator属性将由反序列化器为参数类型提供的空值填充（通常对于Object类型为null，对于基元为默认值；但可通过自定义反序列化器重新定义）。注意，具有可注射的值算作“不丢失”。默认情况下，该功能为禁用状态，因此除非缺少将创建者属性值明确标记为“必需”的属性，否则不会引发任何异常。 FAIL_ON_NULL_CREATOR_PROPERTIES false 该功能可确定如果将一个或多个Creator属性（绑定到Creator方法（构造方法或静态工厂方法）的参数的属性）绑定到null值（来自JSON或作为默认值）时会发生什么。 如果要避免代码库中为null，则这很有用，如果对非强制性字段使用Java或Scala可选参数，则这特别有用。 默认情况下，该功能为禁用状态，因此除非缺少将创建者属性值明确标记为“必需”的属性，否则不会引发任何异常。 FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY true 该功能确定缺少使用com.fasterxml.jackson.annotation.JsonTypeInfo.As.EXTERNAL_PROPERTY注解的属性但用的关联类型ID时发生的情况。 如果启用，则总是在缺少属性值时（如果类型ID确实存在）抛出JsonMappingException； 如果禁用，则仅在将属性标记为“必需”时抛出异常。默认情况下启用功能，以便在缺少子类型属性时引发异常。 FAIL_ON_TRAILING_TOKENS false 绑定根值后确定数据绑定行为的功能。 如果启用了功能，则再次调用com.fasterxml.jackson.core.JsonParser.nextToken以确保找不到更多令牌（如果找到了更多令牌，则抛出com.fasterxml.jackson.databind.exc.MismatchedInputException ）; 如果禁用，则不进行进一步检查。该功能也可以称为READ_FULL_STREAM，因为它可以有效地验证输入流仅包含绑定完整值所需的数据，而仅包含其他内容（可能的可忽略空格或注解，如果数据格式支持，则除外）。由于向后兼容的原因，默认情况下功能是禁用的（因此不检查可能的尾随令牌）。 WRAP_EXCEPTIONS true 确定杰克逊代码是否应捕获并包装异常（但绝不要出错！）以添加有关问题位置（在输入范围内）的附加信息的功能。 如果启用，大多数异常将被捕获并重新抛出（特别是java.io.IOExceptions可以按原样传递，因为它们被声明为可抛出）。 这很方便，因为将检查并声明所有异常，因此有更多上下文信息。 但是，有时调用应用程序可能只希望按原样传递“原始”未经检查的异常。默认情况下启用此功能。 ACCEPT_SINGLE_VALUE_AS_ARRAY false 确定强制将非数组（JSON）值强制用于Java集合（数组，java.util.Collection）类型的功能。 如果启用，集合反序列化器将尝试处理非数组值，就像它们对JSON数组具有“隐式”一样。 此功能旨在出于兼容性/互操作性原因而使用，以与在数组中只有单个元素的情况下忽略JSON数组的程序包（例如XML到JSON转换器）一起使用。默认情况下禁用此功能。 UNWRAP_SINGLE_VALUE_ARRAYS false 确定将单个值数组（在JSON中）的值强制转换为相应值类型是否可接受的功能。 这基本上与ACCEPT_SINGLE_VALUE_AS_ARRAY功能相反。 如果在数组中找到多个值，则抛出JsonMappingException。默认情况下禁用功能 UNWRAP_ROOT_VALUE false 允许“解包”根级JSON值以匹配用于序列化的SerializationFeature.WRAP_ROOT_VALUE的设置。 将验证根JSON值是一个JSON对象，并且它具有具有预期根名的单个属性。 如果不是，则抛出JsonMappingException。 否则，包装属性的值将被反序列化，就好像它是根值一样。默认情况下禁用此功能。 ACCEPT_EMPTY_STRING_AS_NULL_OBJECT false 可以启用此功能以允许将POJO和其他结构化值（java.util.Maps，java.util.Collections）的JSON空字符串值（“”）绑定为“ null”。 如果禁用，则只能从JSONnull或JSON对象绑定标准POJO（标准含义是未定义任何自定义反序列化器或构造函数；这两种都可以添加对其他种类JSON值的支持）； 如果启用，则可以将空JSON字符串等效为JSON null。注意：这不适用于标量值，例如布尔值和数字； 是否可以强制使用它们取决于MapperFeature.ALLOW_COERCION_OF_SCALARS。默认情况下禁用此功能。 ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT false 可以启用此功能，以允许将空JSON数组值（即[]）绑定为POOL（以及2.9，还包含其他值）为“ null”。 如果禁用，则只能从JSONnull或JSON对象绑定标准POJO（标准含义是未定义任何自定义反序列化器或构造函数；这两种都可以添加对其他种类JSON值的支持）； 如果启用，则将使用空JSON数组等效于JSON null。默认情况下禁用此功能。 ACCEPT_FLOAT_AS_INT true 确定是否强制转换为从JSON浮点数（任何带命令（.）或指数部分（e /E&#39;））到期望的整数（int，long，java.lang .integer，java.lang.Long，java.math.BigDecimal是否允许。 如果启用，强制将截断值； 如果禁用，将抛出JsonMappingException。默认情况下启用此功能。 READ_ENUMS_USING_TO_STRING false 确定用于Enum值的标准反序列化机制的功能：如果启用，则假定Enums已使用Enum.toString（）的返回值进行了序列化； 如果禁用，则假定已使用Enum.name（）的返回值。注意：此功能通常应与SerializationFeature.WRITE_ENUMS_USING_TO_STRING具有相同的值。默认情况下禁用此功能。 READ_UNKNOWN_ENUM_VALUES_AS_NULL false 允许将未知的Enum值解析为空值的功能。 如果禁用，未知的Enum值将引发异常。请注意，在某些情况下，这基本上会忽略未知的Enum值； 这是java.util.EnumMap的键的键和java.util.EnumSet的值的（因为在这些情况下不接受null）。默认情况下禁用此功能。 READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE false 该功能允许忽略未知的Enum值，并通过@JsonEnumDefaultValue批注指定预定义值。 如果禁用，未知的Enum值将引发异常。 如果启用，但未指定预定义的默认Enum值，则也会引发异常。 默认情况下禁用此功能。 READ_DATE_TIMESTAMPS_AS_NANOSECONDS true 当且仅当数据类型支持这种分辨率时，此功能可控制是否应使用（启用）或不使用（禁用）纳秒级时间戳写入数字时间戳值。 只有较新的数据类型（例如Java8日期/时间）才支持这种分辨率-较旧的类型（Java8之前的java.util.Date等）和Joda则不支持-并且此设置对此类类型无效。如果禁用，则假定为标准毫秒时间戳。 这与SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS相对应。默认情况下启用此功能，以支持最准确的时间值。 ADJUST_DATES_TO_CONTEXT_TIME_ZONE true 该功能指定上下文提供的java.util.TimeZone（DeserializationContext.getTimeZone（）是否应用于在反序列化时调整日期/时间值，即使值本身包含时区信息也是如此。 如果禁用，则仅当值本身不包含任何TimeZone信息时才使用它。请注意，确切的行为取决于所讨论的日期/时间类型。 特别是JDK类型的java.util.Date没有内置时区信息，因此此设置无效。 此外，尽管java.util.Calendar确实具有此信息，但是基本JDK java.text.SimpleDateFormat无法保留已解析的区域信息，因此，无论此设置如何，java.util.Calendar始终将获得上下文时区调整。考虑到上述因素，只有Joda和Java 8日期/文字数据类型的扩展模块才支持此功能。 EAGER_DESERIALIZER_FETCH true 决定ObjectReader是否应在可能的情况下热切获取必要的JsonDeserializer的功能。 如果多次使用类似配置的ObjectReader实例，则可以提高性能。 并且不会对一次性使用案例产生重大影响。请注意，通常不需要禁用此功能：仅在存在实际可察觉问题的情况下考虑。 默认情况下启用此功能。 对于SerializationFeature枚举中的设置进行描述： |配置|默认值|作用描述||-|-||WRAP_ROOT_VALUE|false|可以启用以使根值（通常为JSON对象，但可以是任何类型）包装在单个属性JSON对象中的功能，其中键为“根名”，由注释内省者确定（对于使用@XmlRootElement的JAXB尤其如此） .name）或后备广告（非合格的类名）。 功能主要是为了与JAXB兼容。默认情况下禁用此功能。||INDENT_OUTPUT|false|该功能允许使用为ObjectMapper（以及从mapper创建的ObjectWriters）配置的默认漂亮打印机为基础生成器启用（或禁用）缩进。请注意，仅当未为生成器或ObjectWriter配置显式com.fasterxml.jackson.core.PrettyPrinter时，才使用默认的漂亮打印机。默认情况下禁用此功能。||FAIL_ON_EMPTY_BEANS|true|该功能用于确定在找不到类型的访问器时会发生什么情况（并且没有注释指示它打算被序列化）。 如果启用（默认），则将引发异常以指示这些类型为不可序列化的类型； 如果禁用，它们将被序列化为空对象，即没有任何属性。请注意，此功能仅对那些没有任何可识别注释的“空” bean（例如，@JsonSerialize）起作用的空类型：具有注释的那些不会导致抛出异常。默认情况下启用此功能。||FAIL_ON_SELF_REFERENCES|true|决定POJO检测到直接自我引用时会发生什么情况的功能（并且未启用对象ID处理）：抛出JsonMappingException（如果为true），或者通常对引用进行处理（false）。默认情况下启用功能||WRAP_EXCEPTIONS|true|确定Jackson代码是否应捕获并包装异常（但绝不要出错！）以添加有关问题位置（在输入范围内）的附加信息的功能。 如果启用，大多数异常将被捕获并重新抛出（特别是java.io.IOExceptions可以按原样传递，因为它们被声明为可抛出）。 这很方便，因为将检查并声明所有异常，因此有更多上下文信息。 但是，有时调用应用程序可能只希望按原样传递“原始”未经检查的异常。默认情况下启用此功能。||FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS|true|确定通常具有Jackson包含的类型信息的对象与com.fasterxml.jackson.annotation.JsonUnwrapped结合使用时发生的功能。 在默认（启用）状态下，当展开的对象具有类型信息时，将引发错误。 禁用时，将解包该对象，并丢弃类型信息。默认情况下启用此功能。||WRITE_SELF_REFERENCES_AS_NULL|false|决定POJO检测到直接自引用时会发生什么情况的功能（并且未启用对象ID处理）：如果启用，则将该引用写为null； 如果禁用，则使用默认行为（它将尝试序列化，通常会导致异常）。 但是，如果启用了FAIL_ON_SELF_REFERENCES。 此属性将被忽略。||CLOSE_CLOSEABLE|false|用于确定是否在序列化后调用实现java.io.Closeable的序列化根级对象的close方法（调用了ObjectMapper的writeValue（）（或等效方法）的对象）的功能。 如果启用，则在序列化完成后（无论成功还是由于抛出异常而显示的错误）将调用close（）。 您可以将其视为某种“最终”处理。注意：仅影响根对象的行为，而不影响从根对象可访问的其他对象。 换句话说，每个“ writeValue”调用将只进行一次调用。默认情况下禁用此功能。||FLUSH_AFTER_WRITE_VALUE|true|确定是否以JsonGenerator作为参数的writeValue（）方法完成后是否调用JsonGenerator.flush（）的功能（即不影响使用其他目标的方法）; ObjectWriter中的方法相同。 这通常是有道理的； 但是在某些情况下不应该强制执行刷新：例如，在底层流进行压缩时，并且flush（）导致刷新了压缩状态（某些压缩编解码器会发生这种情况）。默认情况下启用此功能。||WRITE_DATES_AS_TIMESTAMPS|true|确定是否将Date（和日期/时间）值（以及基于Date的东西，如java.util.Calendars）序列化为数字时间戳记（true；默认值）或其他值（通常是文本表示形式）的功能。如果使用文本表示，则实际格式取决于配置设置，包括@JsonFormat批注的按属性使用，全局配置的java.text.DateFormat。对于“经典” JDK日期类型（java.util.Date，java.util.Calendar），默认格式由com.fasterxml.jackson.databind.util.StdDateFormat提供，并且对应于格式字符串“ yyyy-MM-dd” ‘T’HH：mm：ss.SSSX”（有关字符串格式的详细信息，请参见java.text.DateFormat）。此功能是否影响其他与日期相关的类型的处理取决于这些类型的处理程序，尽管理想情况下，他们应该使用此功能注意：使用WRITE_DATE_KEYS_AS_TIMESTAMPS代替此功能来控制java.util.Map密钥是否序列化为字符串。默认情况下启用功能，因此默认情况下将日期/时间序列化为时间戳。||WRITE_DATE_KEYS_AS_TIMESTAMPS|false|确定是否将用作java.util.Map键的java.util.Dates（和子类型）序列化为时间戳的功能（如果没有，则序列化为文本值）。默认值为“ false”，表示将日期值映射键序列化为文本（ISO-8601）值。默认情况下禁用此功能。||WRITE_DATES_WITH_ZONE_ID|false|用于确定日期/日期时间值是否应该序列化的功能，以便在类型本身包含时区信息的情况下，它们包括时区id。 包含此信息可能会导致兼容性问题，因为ISO-8601规范未定义包含此类信息的格式。如果启用，则应使用Java 8 DateTimeFormatter＃ISO_ZONED_DATE_TIME定义所指定的格式来包含时区ID（例如，“ 2011-12-03T10：15：30 + 01：00 [欧洲/巴黎]”）。注意：如果日期/时间值被序列化为时间戳，则该设置不相关。默认情况下，该功能处于禁用状态，因此不包含区域ID。 相反，时区偏移量用于ISO-8601兼容性（如果值中包含任何时区信息）。||WRITE_DURATIONS_AS_TIMESTAMPS|true|默认情况下，用于确定表示时间段（持续时间，时间段，范围）的时间值是否要使用数字（true）或文本（false）表示序列化的功能。 请注意，根据类型的不同，数字表示可能表示简单数字或数字数组。注意：使用WRITE_DATE_KEYS_AS_TIMESTAMPS来控制java.util.Map密钥是否序列化为字符串。默认情况下启用此功能，因此默认情况下将周期/持续时间序列化为时间戳。||WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS|false|确定char []类型如何序列化的功能：启用后，将序列化为显式JSON数组（以单字符字符串作为值）； 禁用时，默认情况下将其序列化为字符串（更为紧凑）。默认情况下禁用此功能。||WRITE_ENUMS_USING_TO_STRING|false|确定用于Enum值的标准序列化机制的功能：如果启用，则使用Enum.toString（）的返回值； 如果禁用，则使用Enum.name（）的返回值。注意：此功能通常应与DeserializationFeature.READ_ENUMS_USING_TO_STRING具有相同的值。默认情况下禁用此功能。||WRITE_ENUMS_USING_INDEX|false|确定Java Enum值是序列化为数字（true）还是文本值（false）的功能。 如果使用文本值，则还将考虑其他设置。 如果启用此功能，则Enum.ordinal（）的返回值（整数）将用作序列化。请注意，此功能的优先级高于WRITE_ENUMS_USING_TO_STRING，只有将此功能设置为false时，才考虑此功能。请注意，从2.10开始，这不适用于作为java.util.Map值的键编写的枚举，该枚举具有单独的设置WRITE_ENUM_KEYS_USING_INDEX。默认情况下禁用此功能。||WRITE_ENUM_KEYS_USING_INDEX|false|确定是否将用作java.util.Map密钥的{link Enum}序列化为使用Enum.ordinal（）的功能。 与将枚举写入常规值时使用的WRITE_ENUMS_USING_INDEX相似。默认情况下禁用此功能。||WRITE_NULL_MAP_VALUES|true|确定是否要对具有空值的Map条目进行序列化（true）或不进行序列化（false）的功能。注意：与其他SerializationFeatures不同，此功能不能在每次调用的基础上动态更改，因为在构造序列化程序和属性处理程序时会考虑其作用。默认情况下启用此功能。||WRITE_EMPTY_JSON_ARRAYS|true|确定是否将容器属性（具有声明的Collection或数组值的POJO属性；即，产生JSON数组的事物）为空（没有元素）的属性，将被序列化为空JSON数组（true），还是从输出中取消显示（false） 。请注意，这不会更改java.util.Maps或“类似集合”类型的行为。注意：与其他SerializationFeatures不同，此功能不能在每次调用的基础上动态更改，因为在构造序列化程序和属性处理程序时会考虑其作用。默认情况下启用此功能。||WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED|false|为互操作性而添加的功能，以与所谓的“ BadgerFish”约定兼容。 功能确定对单个元素java.util.Collections和数组的处理：如果启用，则仅包含一个元素的java.util.Collections和数组将被序列化，就好像该元素本身已被序列化一样。启用后，带有数组的POJO通常如下所示：{“ arrayProperty”：[1]}而是序列化为{“ arrayProperty”：1}请注意，此功能与DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY相对（即，通常两者都启用，或两者都不启用）。||WRITE_BIGDECIMAL_AS_PLAIN|false|确定是否使用java.math.BigDecimal.toPlainString（）序列化java.math.BigDecimal条目的功能，以防止使用科学计数法写入值。注意：由于此功能通常需要使用com.fasterxml.jackson.core.JsonGenerator.writeNumber（String），因此可能会导致兼容性问题，因为并非所有com.fasterxml.jackson.core.JsonGenerator实现都支持这种输出模式：通常仅文本 基于格式的格式支持它。默认情况下禁用此功能。||WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS|true|控制是否使用纳秒级时间戳写入数字时间戳值（启用）（禁用）的功能； 当且仅当数据类型支持这种分辨率时。 只有较新的数据类型（例如Java8日期/时间）才支持这种分辨率-较旧的类型（Java8之前的java.util.Date等）和Joda则不支持-并且此设置对此类类型无效。如果禁用，则假定为标准毫秒时间戳。 这与DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS对应。默认情况下启用此功能，以支持最准确的时间值。||ORDER_MAP_ENTRIES_BY_KEYS|false|确定是否在序列化之前首先按键对java.util.Map条目进行排序的功能：如果启用，则在必要时执行附加的排序步骤（对于java.util.SortedMaps不必要），如果禁用，则无需进行其他排序。默认情况下禁用此功能。||EAGER_SERIALIZER_FETCH|true|决定ObjectWriter是否应在可能的情况下热切获取必要的JsonSerializer的功能。 如果多次使用类似配置的ObjectWriter实例，则可以提高性能。 并且不会对一次性使用案例产生重大影响。请注意，通常不需要禁用此功能：仅在存在实际可察觉问题的情况下考虑。默认情况下启用此功能。||USE_EQUALITY_FOR_OBJECT_ID|false|确定是否使用对象的真实JVM级别标识（false）比较对象标识的功能； 或equals（）方法。 当使用ORM库（例如Hibernate）处理数据库绑定的对象时，后期有时会很有用。 注意对象本身是实际比较的，不是对象ID。 此功能的命名有些令人困惑，因此重要的是，要为其保留身份的对象在id之上和之外都被认为是相等的（无论如何，它们总是使用相等性进行比较）。注意：由于实现功能的方式，非常重要的是，除了覆盖Object.equals以使对象匹配（被视为“相同”）之外，还必须确保Object.hashCode（）被覆盖以产生 相等实例的值完全相同。默认情况下禁用此功能； 表示使用严格的身份，而不是equals（）| 3.2、创建自定义的序列化/反序列化器ObjectMapper类的另一个基本功能是能够注册自定义序列化器和反序列化器。 在输入或输出JSON响应的结构不同且必须对其进行序列化或反序列化的Java类的结构时，自定义序列化器和反序列化器非常有用。以下是自定义JSON序列化程序的示例： 1234567891011121314151617181920212223242526272829package com.yiyi.advanced;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.databind.SerializerProvider;import com.fasterxml.jackson.databind.ser.std.StdSerializer;import java.io.IOException;/** * @author wuxuan.chai * @date 2020/6/8 4:49 下午 */public class CustomCarSerializer extends StdSerializer&lt;Car&gt; &#123; protected CustomCarSerializer(Class&lt;Car&gt; t) &#123; super(t); &#125; public CustomCarSerializer() &#123; this(null); &#125; @Override public void serialize(Car car, JsonGenerator gen, SerializerProvider provider) throws IOException &#123; gen.writeStartObject(); gen.writeStringField(&quot;car_brand&quot;, car.getType()); gen.writeEndObject(); &#125;&#125; 此自定义序列化器可以这样调用： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yiyi.advanced;import com.fasterxml.jackson.core.Version;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 3:59 下午 */@Data@ToString@EqualsAndHashCodepublic class Car &#123; private String type; private String color; public Car(String type, String color) &#123; this.type = type; this.color = color; &#125; @SneakyThrows public static void main(String[] args) &#123; Car car = new Car(&quot;BMW&quot;, &quot;Red&quot;); String json = new ObjectMapper() .registerModule( new SimpleModule( &quot;CustomCarSerializer&quot;, new Version(1, 0, 0, null, null, null) ).addSerializer(Car.class, new CustomCarSerializer())) .writeValueAsString(car); System.out.println(json); //result:&#123;&quot;car_brand&quot;:&quot;BMW&quot;&#125; &#125;&#125; 这是自定义JSON反序列化的示例： 1234567891011121314151617181920212223242526272829303132333435363738package com.yiyi.advanced;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.core.ObjectCodec;import com.fasterxml.jackson.core.TreeNode;import com.fasterxml.jackson.databind.DeserializationContext;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.deser.std.StdDeserializer;import java.io.IOException;/** * @author wuxuan.chai * @date 2020/6/8 4:59 下午 */public class CustomCarDeserializer extends StdDeserializer&lt;Car&gt; &#123; protected CustomCarDeserializer(Class&lt;?&gt; vc) &#123; super(vc); &#125; public CustomCarDeserializer()&#123; this(null); &#125; @Override public Car deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException &#123; Car car = new Car(); ObjectCodec codec = p.getCodec(); JsonNode treeNode = codec.readTree(p); JsonNode colorNode = treeNode.get(&quot;color&quot;); String color = colorNode.asText(); car.setColor(color); return car; &#125;&#125; 此自定义反序列化器可以这样调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.advanced;import com.fasterxml.jackson.core.Version;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 3:59 下午 */@Data@ToString@EqualsAndHashCodepublic class Car &#123; private String type; private String color; public Car(String type, String color) &#123; this.type = type; this.color = color; &#125; public Car() &#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;BMW\\&quot;&quot;+ &quot; &#125;&quot;; Car car = new ObjectMapper() .registerModule( new SimpleModule( &quot;CustomCarDeserializer&quot;, new Version(1, 0, 0, null, null, null) ).addDeserializer(Car.class, new CustomCarDeserializer())) .readValue(json, Car.class); System.out.println(car); //result: Car(type=null, color=Red) &#125;&#125; 3.3、Date 格式化的处理方式java.util.Date的默认序列化产生一个数字，即纪元时间戳（自1970年1月1日起，以UTC为单位的毫秒数）。 但这不是人类可读的，并且需要进一步转换以人类可读的格式显示。 让我们使用datePurchased属性将到目前为止使用的Car实例包装在Request类中： 12345678910111213141516package com.yiyi.advanced;import lombok.Data;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 5:12 下午 */@Datapublic class Request &#123; private Car car; private Date createDate;&#125; 控制日期的字符串格式，并将其设置为例如 yyyy-MM-dd HH:mm a z，请考虑以下代码段： 12345678910111213141516171819202122232425262728293031323334353637383940package com.yiyi.advanced;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import java.text.SimpleDateFormat;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 5:12 下午 */@Datapublic class Request &#123; private Car car; private Date createDate; public Request() &#123; &#125; public Request(Car car, Date createDate) &#123; this.car = car; this.createDate = createDate; &#125; @SneakyThrows public static void main(StrinDeserializationFeatureg[] args) &#123; Car car = new Car(&quot;BMW&quot;, &quot;Red&quot;); Request request = new Request(car,new Date()); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm a z&quot;); ObjectMapper objectMapper = new ObjectMapper().setDateFormat(simpleDateFormat); String json = objectMapper.writeValueAsString(request); System.out.println(json); //result: &#123;&quot;car&quot;:&#123;&quot;type&quot;:&quot;BMW&quot;,&quot;color&quot;:&quot;Red&quot;&#125;,&quot;createDate&quot;:&quot;2020-06-08 17:16 下午 CST&quot;&#125; &#125;&#125; 更多的时间格式化的方式参考：深入学习日期格式化 3.4、集合的处理方式DeserializationFeature类提供的另一个小而有用的功能是能够根据JSON数组响应生成所需类型的集合的功能。例如，我们可以将结果生成为数组： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.yiyi.advanced;import com.fasterxml.jackson.core.Version;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 3:59 下午 */@Data@ToString@EqualsAndHashCodepublic class Car &#123; private String type; private String color; public Car(String type, String color) &#123; this.type = type; this.color = color; &#125; public Car() &#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;[\\n&quot; + &quot; &#123;\\n&quot; + &quot; \\&quot;color\\&quot;:\\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;:\\&quot;BMW\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; &#123;\\n&quot; + &quot; \\&quot;color\\&quot;:\\&quot;Black\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;:\\&quot;audi\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;]&quot;; //也可以写成： objectMapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true); ObjectMapper objectMapper = new ObjectMapper().enable(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY); Car[] cars = objectMapper.readValue(json, Car[].class); List&lt;Car&gt; carList = objectMapper.readValue(json,new TypeReference&lt;List&lt;Car&gt;&gt;()&#123;&#125;); &#125;&#125; 四、Jackson序列化是忽略属性4.1、简介本章将展示在使用Jackson 2.x将对象序列化为JSON时如何忽略某些字段。当Jackson默认值还不够，并且我们需要精确控制要序列化为JSON的内容时，这非常有用-并且有几种方法可以忽略属性。 4.2、在类级别上忽略字段我们可以使用@JsonIgnoreProperties批注并按名称指定字段，从而在类级别忽略特定字段： 123456789101112131415161718192021222324252627282930313233package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 5:32 下午 */@Data@JsonIgnoreProperties(&#123;&quot;intValue&quot;&#125;)public class MyDto &#123; private String stringValue; private int intValue; private Boolean booleanValue; public MyDto(String stringValue, int intValue, Boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDto myDto = new MyDto(&quot;wuxuan&quot;, 12, false); String json = new ObjectMapper().writeValueAsString(myDto); System.out.println(json); //result: &#123;&quot;stringValue&quot;:&quot;wuxuan&quot;,&quot;booleanValue&quot;:false&#125; &#125;&#125; 要毫无例外地忽略JSON输入中的任何未知属性，我们可以设置@JsonIgnoreProperties批注的ignoreUnknown = true。 4.3、在字段级别上忽略字段我们也可以直接通过@JsonIgnore批注直接忽略该字段： 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonIgnore;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 5:32 下午 */@Datapublic class MyDto &#123; private String stringValue; private int intValue; @JsonIgnore private Boolean booleanValue; public MyDto(String stringValue, int intValue, Boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDto myDto = new MyDto(&quot;wuxuan&quot;, 12, false); String json = new ObjectMapper().writeValueAsString(myDto); System.out.println(json); //result：&#123;&quot;stringValue&quot;:&quot;wuxuan&quot;,&quot;intValue&quot;:12&#125; &#125;&#125; 4.4、通过类型忽略所有字段最后，我们可以使用@JsonIgnoreType批注忽略指定类型的所有字段。 如果我们控制类型，那么我们可以直接注解类： 12345678910111213141516171819202122232425262728293031package com.yiyi.ignoreField;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 5:42 下午 */@Datapublic class SomeType &#123; private String type; private MyDto myDto; public SomeType(String type, MyDto myDto) &#123; this.type = type; this.myDto = myDto; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDto wuxuan = new MyDto(&quot;wuxuan&quot;, 1, false); SomeType type = new SomeType(&quot;www&quot;, wuxuan); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(type); System.out.println(json); //result:&#123;&quot;type&quot;:&quot;www&quot;&#125; &#125;&#125; 但是，我们常常无法控制类本身； 在这种情况下，我们可以充分利用Jackson的混入注解。首先，我们为要忽略的类型定义一个MixIn，然后使用@JsonIgnoreType对其进行注解： 123456789101112package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonIgnoreType;/** * @author wuxuan.chai * @date 2020/6/8 5:47 下午 */@JsonIgnoreTypepublic class MyMixinForIgnoreType &#123;&#125; 然后，我们在编组期间注册该mixin来替换（并忽略）所有String[]类型： 123456789101112package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonIgnoreType;/** * @author wuxuan.chai * @date 2020/6/8 5:47 下午 */@JsonIgnoreTypepublic class MyMixinForIgnoreType &#123;&#125; 123456789101112131415161718192021222324252627282930313233package com.yiyi.ignoreField;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 5:57 下午 */@Datapublic class MyDtoWithSpecialField &#123; private String[] stringValue; private int intValue; private boolean booleanValue; public MyDtoWithSpecialField(String[] stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDtoWithSpecialField myDtoWithSpecialField = new MyDtoWithSpecialField(new String[]&#123;&quot;1&quot;, &quot;2&quot;&#125;, 1, false); ObjectMapper objectMapper = new ObjectMapper().addMixIn(String[].class, MyMixinForIgnoreType.class); String json = objectMapper.writeValueAsString(myDtoWithSpecialField); System.out.println(json); //result: &#123;&quot;intValue&quot;:1,&quot;booleanValue&quot;:false&#125; &#125;&#125; 4.5、通过过滤器忽略字段最后，我们还可以使用过滤器来忽略Jackson中的特定字段。 首先，我们需要在Java对象上定义过滤器,去除掉name属性： 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonFilter;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 6:03 下午 */@JsonFilter(&quot;myFilter&quot;)@Datapublic class MyDtoFilter &#123; private String type; private String name; public MyDtoFilter(String type, String name) &#123; this.type = type; this.name = name; &#125; public MyDtoFilter() &#123; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDtoFilter myDtoFilter = new MyDtoFilter(&quot;BMW&quot;, &quot;x5&quot;); SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeAllExcept(&quot;name&quot;); SimpleFilterProvider myFilter = new SimpleFilterProvider().addFilter(&quot;myFilter&quot;, filter); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writer(myFilter).writeValueAsString(myDtoFilter); System.out.println(json); //result:&#123;&quot;type&quot;:&quot;BMW&quot;&#125; &#125;&#125; 五、在Jackson中忽略值为NULL的字段5.1、简介本快速章节将介绍如何在序列化Java类时设置Jackson以忽略空字段。 5.2、在类上忽略NULL字段12@JsonInclude(Include.NON_NULL)public class MyDto &#123; ... &#125; 或者-更细粒度上讲-在字段级级： 12345public class MyDto&#123; @JsonInclude(Include.NON_NULL) private String value; private int number;&#125; 4.3. 全局忽略NULL的字段Jackson还允许在ObjectMapper上全局配置此行为： 12345678public class MyDtoTest&#123; @Test public void testNullField() &#123; ObjectMapper mapper = new ObjectMapper().setSerializationInclusion(Include.NON_NULL); ... &#125; &#125; 忽略空字段是一种常见的Jackson配置，因为通常情况下，我们需要更好地控制JSON输出。 本章说明如何对类进行此操作。 但是，还有更高级的用例，例如在序列化Map时忽略空值。 六、Jackson更改字段的名称6.1、简介本快速章节说明了如何更改字段名称以在序列化时映射到另一个JSON属性。 6.2、更改要序列化的字段名称以MyDto类为例： 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.changeFieldName;import com.fasterxml.jackson.annotation.JsonProperty;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 6:18 下午 */@Datapublic class MyDto &#123; private String value; private String name; public MyDto(String value, String name) &#123; this.value = value; this.name = name; &#125; public MyDto() &#123; &#125; @JsonProperty(&quot;value_fact&quot;) public String getValue()&#123; return value; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDto myDto = new MyDto(&quot;sfsd&quot;, &quot;www&quot;); String json = new ObjectMapper().writeValueAsString(myDto); System.out.println(json); //result: &#123;&quot;name&quot;:&quot;www&quot;,&quot;value_fact&quot;:&quot;sfsd&quot;&#125; &#125;&#125; 七、Jackson用未知属性反序列化JSON7.1、简介在本章中，我们将研究Jackson 2.x的解组过程，特别是如何处理具有未知属性的JSON内容。 7.2、使用其他/未知字段反序列化JSONJSON输入有各种形态和大小-在大多数情况下，我们需要将其映射到具有一定数量字段的预定义Java对象。 目标是简单地忽略所有无法映射到现有Java字段的JSON属性。例如，假设我们需要将JSON解组到以下Java实体： 123456789101112131415161718192021222324package com.yiyi.unmarshall;import lombok.Data;/** * @author wuxuan.chai * @date 2020/6/8 6:25 下午 */@Datapublic class MyDto &#123; private String stringValue; private int intValue; private boolean booleanValue; public MyDto() &#123; &#125; public MyDto(String stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125;&#125; 7.3、未知字段上的UnrecognizedPropertyException尝试将具有未知属性的JSON反序列化到此简单Java实体将导致com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.unmarshall;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 6:25 下午 */@Datapublic class MyDto &#123; private String stringValue; private int intValue; private boolean booleanValue; public MyDto() &#123; &#125; public MyDto(String stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;stringValue\\&quot;: \\&quot;wuxuan\\&quot;,\\n&quot; + &quot; \\&quot;intValue\\&quot;: 1,\\n&quot; + &quot; \\&quot;booleanValue111\\&quot;: false\\n&quot; + &quot;&#125;&quot;; ObjectMapper objectMapper = new ObjectMapper(); MyDto myDto = objectMapper.readValue(json, MyDto.class); //throw UnrecognizedPropertyException 异常 /** * Unrecognized field &quot;booleanValue111&quot; (class com.yiyi.unmarshall.MyDto), not marked as ignorable (3 known properties: &quot;stringValue&quot;, &quot;booleanValue&quot;, &quot;intValue&quot;]) * at [Source: (String)&quot;&#123; * &quot;stringValue&quot;: &quot;wuxuan&quot;, * &quot;intValue&quot;: 1, * &quot;booleanValue111&quot;: false * &#125;&quot;; line: 4, column: 29] (through reference chain: com.yiyi.unmarshall.MyDto[&quot;booleanValue111&quot;]) */ &#125;&#125; 7.4、通过设置ObjectMapper处理未知字段的异常现在，我们可以配置完整的ObjectMapper以忽略JSON中的未知属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.yiyi.unmarshall;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 6:25 下午 */@Data@ToStringpublic class MyDto &#123; private String stringValue; private int intValue; private boolean booleanValue; public MyDto() &#123; &#125; public MyDto(String stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;stringValue\\&quot;: \\&quot;wuxuan\\&quot;,\\n&quot; + &quot; \\&quot;intValue\\&quot;: 1,\\n&quot; + &quot; \\&quot;booleanValue111\\&quot;: true\\n&quot; + &quot;&#125;&quot;; ObjectMapper objectMapper = new ObjectMapper(); //也可以写成：objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false); objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); MyDto myDto = objectMapper.readValue(json, MyDto.class); System.out.println(myDto); //result: MyDto(stringValue=wuxuan, intValue=1, booleanValue=false) // booleanValue=false 是对象的属性的默认值，因为booleanValue 是基本类型，不是包装类型，默认值为false &#125;&#125; 7.5、通过类上注解处理未知字段我们还可以将单个类标记为接受未知字段，而不是整个Jackson对象映射器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.yiyi.unmarshall;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 6:25 下午 */@Data@ToString@JsonIgnoreProperties(ignoreUnknown = true)public class MyDto &#123; private String stringValue; private int intValue; private boolean booleanValue; public MyDto() &#123; &#125; public MyDto(String stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;stringValue\\&quot;: \\&quot;wuxuan\\&quot;,\\n&quot; + &quot; \\&quot;intValue\\&quot;: 1,\\n&quot; + &quot; \\&quot;booleanValue111\\&quot;: true\\n&quot; + &quot;&#125;&quot;; ObjectMapper objectMapper = new ObjectMapper(); MyDto myDto = objectMapper.readValue(json, MyDto.class); System.out.println(myDto); //result: MyDto(stringValue=wuxuan, intValue=1, booleanValue=false) // booleanValue=false 是对象的属性的默认值，因为booleanValue 是基本类型，不是包装类型，默认值为false &#125;&#125; 八、总结初次系统的学习Jackson的使用方式，感受到了Jackson特别灵活，定制化强的特点，针对于日常的业务需求，已经足够了。更让人惊讶的是自定义的Jackson注解，更是让Jackson如虎添翼。","categories":[{"name":"详细教程","slug":"详细教程","permalink":"https://cha1yi.github.io/dist/categories/%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cha1yi.github.io/dist/tags/Java/"}],"author":"wuxuan.chai"},{"title":"SQL语句概念简单整理","slug":"SQL语句概念简单整理","date":"2021-01-17T15:44:30.693Z","updated":"2021-01-17T16:16:10.261Z","comments":true,"path":"2021/01/17/SQL语句概念简单整理/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/SQL%E8%AF%AD%E5%8F%A5%E6%A6%82%E5%BF%B5%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/","excerpt":"","text":"一、SQL语言共分为四大类 数据查询语言DQL 数据操纵语言DML 数据定义语言DDL 数据控制语言DCL。 二、简要描述这四类1、数据查询语言DQL数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：SELECT &lt;字段名表&gt;FROM &lt;表或视图名&gt;WHERE &lt;查询条件&gt; 2、数据操纵语言DML数据操纵语言DML主要有三种形式： 插入：INSERT 更新：UPDATE 删除：DELETE（删除表中的数据不删除表结构，可以回滚） 3、数据定义语言DDL CREATE：创建 ALTER：修改表结构 RENAME：修改表名或列名 DROP：删除表中的数据和结构，删除后不能回滚 TRUNCATE：删除表中的数据不删除表结构，删除后不能回滚，效率比DELETE高 4、数据控制语言DCL GRANT：授权 REVOKE ：回收权限 还有事务控制语句TCL： SAVEPOINT：保存点 ROLLBACK：回退到某点 COMMIT：提交事务","categories":[{"name":"数据库","slug":"数据库","permalink":"https://cha1yi.github.io/dist/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://cha1yi.github.io/dist/tags/SQL/"}],"author":"wuxuan.chai"},{"title":"设计模式之----工厂模式","slug":"设计模式之----工厂模式","date":"2021-01-17T15:37:18.288Z","updated":"2021-01-17T16:16:10.259Z","comments":true,"path":"2021/01/17/设计模式之----工厂模式/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B----%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式之—-工厂模式工厂模式（Factory Pattern）是java中最常用的设计模式之一，这种类型设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象是不会对客户暴露创建逻辑，并且是通过使用一个共同的接口，以此来达到解耦的目的。 下面的例子以造车为例来说明三种模式。 分类1、简单工厂模式 (Simple Factory)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class Car &#123;&#125;public enum CarType &#123; BMW, AUDI, DAZHONG;&#125;public class BmwCar extends Car&#123; public BmwCar()&#123; System.out.println(&quot;这是宝马车&quot;); &#125;&#125;public class AudiCar extends Car&#123; public AudiCar()&#123; System.out.println(&quot;这是奥迪车&quot;); &#125;&#125;public class DaZhongCar extends Car &#123; public DaZhongCar() &#123; System.out.println(&quot;这是大众车&quot;); &#125;&#125;public class CarFactory &#123; /** * 静态工厂方法 * * @param carType 车的类型 * @return 车的对象 */ public static Car createCar(CarType carType) &#123; switch (carType) &#123; case BMW: return new BmwCar(); case AUDI: return new AudiCar(); case DAZHONG: return new DaZhongCar(); default: return null; &#125; &#125; public static void main(String[] args) &#123; CarFactory.createCar(CarType.AUDI); &#125;&#125; 输出： 123这是奥迪车Process finished with exit code 0 这种工厂模式，已经完成了我们工厂模式的基本的需求，创建对象和解耦缺点：1、用户调用需要知道自己要创建的对象在工厂中的类型2、拓展很麻烦，如果新增一个产品，需要在产品的具体创建对象的实现，还需使工厂支持创建这种产品，这显然是违背开闭原则的 2、工厂方法模式（Factory Method）123456789101112131415161718192021222324252627282930313233public interface Factory &#123; /** * 生产车的方法 * @return 车的对象 */ Car createCar();&#125;public class AudiFactory implements Factory&#123; @Override public Car createCar() &#123; return new AudiCar(); &#125;&#125;public class BmwFactory implements Factory&#123; @Override public Car createCar() &#123; return new BmwCar(); &#125;&#125;public class DaZhongFactory implements Factory&#123; @Override public Car createCar() &#123; return new DaZhongCar(); &#125;&#125;//客户使用public class ConsumerTest &#123; public static void main(String[] args) &#123; final BmwFactory bmwFactory = new BmwFactory(); bmwFactory.createCar(); &#125;&#125; 输出： 123这是宝马车Process finished with exit code 0 工厂方法模式组成： 1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 方法工厂模式和简单工厂模式最大的不同，就是将实现交给了具体的工厂，核心工厂只提供产品线，具体的实现工厂只需要去实现对应的需求即可。如果新增产，只需要去实现对应的产品工厂即可，显然这种方式是符合开闭原则的 3、抽象工厂模式 (Abstract Factory)个人觉得抽象工厂模式和工厂方法模式区别不是很大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface Factory &#123; /** * 生产车的方法 * * @return 车的对象 */ Car createCar(); /** * 获取价钱 * * @return 价钱 */ double pricing();&#125;public class AudiFactory implements Factory &#123; @Override public Car createCar() &#123; return new AudiCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：20_0000&quot;); return 20_0000; &#125;&#125;public class BmwFactory implements Factory &#123; @Override public Car createCar() &#123; return new BmwCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：25_0000&quot;); return 25_0000; &#125;&#125;public class DaZhongFactory implements Factory &#123; @Override public Car createCar() &#123; return new DaZhongCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：18_0000&quot;); return 18_0000; &#125;&#125;//客户使用public class ConsumerTest &#123; public static void main(String[] args) &#123; final BmwFactory bmwFactory = new BmwFactory(); bmwFactory.createCar(); bmwFactory.pricing(); &#125;&#125; 总结：无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"wuxuan.chai"},{"title":"DO、DTO、BO、VO、POJO的定义","slug":"DO、DTO、BO、VO、POJO的定义","date":"2021-01-17T15:33:00.411Z","updated":"2021-01-17T16:16:10.255Z","comments":true,"path":"2021/01/17/DO、DTO、BO、VO、POJO的定义/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/DO%E3%80%81DTO%E3%80%81BO%E3%80%81VO%E3%80%81POJO%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"DO、DTO、BO、VO、POJO的定义分层领域模型规约DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。AO（ Application Object）：应用对象。 在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。POJO（ Plain Ordinary Java Object）：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。Query：数据查询对象，各层接收上层的查询请求。 注意超过2个参数的查询封装，禁止使用Map类来传输。 领域模型命名规约数据对象：xxxDO，xxx即为数据表名。数据传输对象：xxxDTO，xxx为业务领域相关的名称。展示对象：xxxVO，xxx一般为网页名称。POJO: 专指只有 setter / getter / toString的简单类，包括DO/DTO/BO/VO等,禁止命名成 xxxPOJO","categories":[{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"author":"wuxuan.chai"}],"categories":[{"name":"微服务","slug":"微服务","permalink":"https://cha1yi.github.io/dist/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"操作系统","slug":"操作系统","permalink":"https://cha1yi.github.io/dist/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Java","slug":"Java","permalink":"https://cha1yi.github.io/dist/categories/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"},{"name":"算法","slug":"算法","permalink":"https://cha1yi.github.io/dist/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","permalink":"https://cha1yi.github.io/dist/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Docker","slug":"Docker","permalink":"https://cha1yi.github.io/dist/categories/Docker/"},{"name":"数据仓库","slug":"数据仓库","permalink":"https://cha1yi.github.io/dist/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"},{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"开发总结","slug":"开发总结","permalink":"https://cha1yi.github.io/dist/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"详细教程","slug":"详细教程","permalink":"https://cha1yi.github.io/dist/categories/%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://cha1yi.github.io/dist/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Mac","slug":"Mac","permalink":"https://cha1yi.github.io/dist/tags/Mac/"},{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"},{"name":"算法","slug":"算法","permalink":"https://cha1yi.github.io/dist/tags/%E7%AE%97%E6%B3%95/"},{"name":"SQL","slug":"SQL","permalink":"https://cha1yi.github.io/dist/tags/SQL/"},{"name":"docker","slug":"docker","permalink":"https://cha1yi.github.io/dist/tags/docker/"},{"name":"数据仓库","slug":"数据仓库","permalink":"https://cha1yi.github.io/dist/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"},{"name":"kafka","slug":"kafka","permalink":"https://cha1yi.github.io/dist/tags/kafka/"},{"name":"CentOS","slug":"CentOS","permalink":"https://cha1yi.github.io/dist/tags/CentOS/"},{"name":"事件驱动","slug":"事件驱动","permalink":"https://cha1yi.github.io/dist/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"},{"name":"VM","slug":"VM","permalink":"https://cha1yi.github.io/dist/tags/VM/"},{"name":"SkyWalking","slug":"SkyWalking","permalink":"https://cha1yi.github.io/dist/tags/SkyWalking/"},{"name":"系统监控","slug":"系统监控","permalink":"https://cha1yi.github.io/dist/tags/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"},{"name":"maven","slug":"maven","permalink":"https://cha1yi.github.io/dist/tags/maven/"},{"name":"Arthas","slug":"Arthas","permalink":"https://cha1yi.github.io/dist/tags/Arthas/"},{"name":"Java","slug":"Java","permalink":"https://cha1yi.github.io/dist/tags/Java/"},{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]}