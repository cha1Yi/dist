{"meta":{"title":"YiDan の dada","subtitle":"","description":"","author":"wuxuan.chai","url":"https://cha1yi.github.io/dist","root":"/dist/"},"pages":[{"title":"关于","date":"2021-01-16T17:37:28.597Z","updated":"2021-01-16T17:37:28.597Z","comments":true,"path":"about/index.html","permalink":"https://cha1yi.github.io/dist/about/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2021-01-16T17:37:28.598Z","updated":"2021-01-16T17:37:28.598Z","comments":true,"path":"categories/index.html","permalink":"https://cha1yi.github.io/dist/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-01-16T17:37:28.599Z","updated":"2021-01-16T17:37:28.599Z","comments":true,"path":"tags/index.html","permalink":"https://cha1yi.github.io/dist/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记kafka启动失败","slug":"kafka错误处理解决总结","date":"2021-01-18T02:19:33.851Z","updated":"2021-01-18T02:22:01.165Z","comments":true,"path":"2021/01/18/kafka错误处理解决总结/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/kafka%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%A7%A3%E5%86%B3%E6%80%BB%E7%BB%93/","excerpt":"","text":"场景在项目开发中，需要使用到kafka，但是无论如何本地环境的kafka都无法启动，zookeeper状态是正常的，kafka就是起不来，导致项目的日志消费的任务一直阻塞。重新启动会发生异常：InconsistentClusterIdException。 异常的信息1234567ERROR Fatal error during KafkaServer startup. Prepare to shutdown (kafka.server.KafkaServer)kafka.common.InconsistentClusterIdException: The Cluster ID F-bhGf-3T1qgjuQ0c1wCRw doesn&#39;t match stored clusterId Some(FO2XIwDrSSiJSeWo4B80hQ) in meta.properties. The broker is trying to join the wrong cluster. Configured zookeeper.connect may be wrong. at kafka.server.KafkaServer.startup(KafkaServer.scala:223) at kafka.server.KafkaServerStartable.startup(KafkaServerStartable.scala:44) at kafka.Kafka$.main(Kafka.scala:82) at kafka.Kafka.main(Kafka.scala) .... 原因分析及解决方案kafka的配置日志路径，用来保存kafka的执行过程中的信息，如果kafka异常关闭，日志记录就会出现异常，会把当时的情况记录在meta.properties文件中，重启时，此文件会对启动产生影响。原因是，里面记录了borker 和cluster-id,导致的报错。 解决方式 清空日志目录【日志不重要或可以容忍日志丢失】。 调整日志目录【需要修改配置】。 删除日志目录下的meta.properties文件。","categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://cha1yi.github.io/dist/tags/kafka/"}],"author":"wuxuan.chai"},{"title":"CentOS7常用命令","slug":"CentOS7常用命令","date":"2021-01-18T02:18:08.079Z","updated":"2021-01-18T02:22:59.465Z","comments":true,"path":"2021/01/18/CentOS7常用命令/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/CentOS7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"CentOS7常用命令1、服务器之间copy文件12# 将文件spark-3.0.1-bin-hadoop2.7.tgz copy到node1机器的/home/wuxuan/package/目录下$ scp spark-3.0.1-bin-hadoop2.7.tgz wuxuan@node1:/home/wuxuan/package/ 2、防火墙相关操作123456789101112#查看防火墙状态$ firewall-cmd --state# 关闭防火墙$ systemctl stop firewalld.service# 启动防火墙$ systemctl start firewalld.service# 重启网卡$ systemctl restart network.service CentOS之间设置免密访问一、准备阶段准备两台机器：192.168.100.11 node1192.168.100.12 node2 二、设置hosts在每台机器中设置hosts 123456$ vim /etc/hosts#添加hosts192.168.100.11 node1 192.168.100.12 node2 三、每台机器设置hostname（主机名称）设置hostname 12345678# 登陆到192.168.100.11$ hostname node1# 登陆到192.168.100.12$ hostname node2 四、给每台机器生成ssh密钥1234567891011121314151617# 登陆到192.168.100.11$ cd /root/.ssh$ ssh-keygen -t rsa$ lsid_rsa id_rsa.pub# 将机器的公钥备份$ cp id_rsa.pub &gt;&gt; authorized_keys# 将文件传输给机器192.168.100.12$ scp authorized_keys root@node2:/root/.ssh/# 登陆到192.168.100.12 $ hostname node2$ cat id_rsa.pub &gt;&gt; authorized_keys 到此node2的authorized_keys包含node1和node2的公钥重复此操作，即可实现node1和node2的免密访问 测试: 12$ ssh node2Last login: Fri Nov 13 16:01:17 2020 from node1","categories":[{"name":"开发总结","slug":"开发总结","permalink":"https://cha1yi.github.io/dist/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://cha1yi.github.io/dist/tags/CentOS/"}],"author":"wuxuan.chai"},{"title":"SpringBoot自定义starter","slug":"SpringBoot自定义starter","date":"2021-01-18T01:57:06.360Z","updated":"2021-01-18T01:57:54.335Z","comments":true,"path":"2021/01/18/SpringBoot自定义starter/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/","excerpt":"","text":"SpringBoot自定义starter学习背景&nbsp;&nbsp;最近和同事在开发一个叫做数据准备的项目，用到了SpringBoot（ps：之前的项目用的是ssm，第一次正式使用SpringBoot）,现在对于这种开箱即用的SpringBoot-Starter感到无比的惊叹，需要使用某个中间件，只需引入然后附加少许配置即可投入生产。今天就开始学习一下SpringBoot的starter的开发规范。 Starter的构成1、命名创建一个工程叫做Flyway-spring-boot-starter Spring 官方对 starter 的命名是有规范的，只有官方提供的 starter, 才能命名为 spring-boot-starter-{name}, 比如 spring-boot-starter-web; 而对于非官方的，需以 {name}-spring-boot-starter 的格式命名。 2、增加Spring-Boot-AutoConfiguration依赖123456&lt;!-- 自动化配置依赖，自定义 starter 核心依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt; 3、新增自动配置类&nbsp;&nbsp;创建类 FlyWayAutoConfiguration 来实现自动配置化功能 12345678910111213141516171819202122232425package com.yidan.flyway;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author wuxuan.chai * @date 2020/10/19 5:57 下午 */@Configuration@ConditionalOnClass(SelfService.class)@EnableConfigurationProperties(SelfProperties.class)public class FlyWayAutoConfiguration &#123; @Bean @ConditionalOnMissingBean public SelfService selfService() &#123; return new SelfService(); &#125;&#125; 接下来，对上面相关注解说明一下：@Configuration: 标注类为一个配置类，让 spring 去扫描它；@ConditionalOnClass：条件注解，只有在 classpath 路径下存在指定 class 文件时，才会实例化 Bean；@EnableConfigurationProperties：使指定配置类生效；@Bean: 创建一个实例类注入到 Spring Ioc 容器中；@ConditionalOnMissingBean：条件注解，意思是，仅当 Ioc 容器不存在指定类型的 Bean 时，才会创建 Bean。 4、自定义配置类及功能实现创建自定义配置类 SelfProperties 123456789101112131415161718192021package com.yidan.flyway;import org.springframework.boot.context.properties.ConfigurationProperties;/** * @author wuxuan.chai * @date 2020/10/19 6:01 下午 */@ConfigurationProperties(prefix = &quot;flyway.self&quot;)public class SelfProperties &#123; private String message = &quot;hello flyway&quot;; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 创建SelfService业务方法 1234567891011121314151617package com.yidan.flyway;import javax.annotation.Resource;/** * @author wuxuan.chai * @date 2020/10/19 6:04 下午 */public class SelfService &#123; @Resource private SelfProperties selfProperties; public String message() &#123; return selfProperties.getMessage(); &#125;&#125; 5、创建spring.factories文件&nbsp;&nbsp;在resource目录下创建META-INF目录，在该目录下创建spring.factories文件。Spring Boot 会在启动时，自动会去查找指定文件 /META-INF/spring.factories，若有，就会根据配置的类的全路径去自动化配置。 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.yidan.flyway.FlywayAutoConfiguration 6、自定义的配置信息元数据描述我们在开发SpringBoot的项目时，在写application.properties(或application.yml)时，IDEA会自动智能提醒，key和value的值。它是如何做到的呢？在Spring的官方文档中有相对应的介绍SpringBoot自定义配置详解 在Resourse目录下的META-INF 创建:spring-configuration-metadata.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;groups&quot;: [ &#123; &quot;sourceType&quot;: &quot;com.yidan.flyway.SelfProperties&quot;, &quot;type&quot;: &quot;com.yidan.flyway.SelfProperties&quot;, &quot;name&quot;: &quot;flyway.self&quot; &#125; ], &quot;hints&quot;: [ &#123; &quot;name&quot;: &quot;flyway.self.message&quot;, &quot;values&quot;: [ &#123; &quot;value&quot;:&quot;hello flyway&quot;, &quot;description&quot;: &quot;第一个值&quot; &#125;, &#123; &quot;value&quot;: &quot;hello configuration&quot;, &quot;description&quot;: &quot;第二个值&quot; &#125; ], &quot;providers&quot;: [ &#123; &quot;name&quot;: &quot;flyway starter&quot;, &quot;parameters&quot;: &quot;123&quot; &#125; ] &#125; ], &quot;properties&quot;: [ &#123; &quot;name&quot;: &quot;flyway.self.message&quot;, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;description&quot;: &quot;自定义的配置&quot;, &quot;sourceType&quot;: &quot;com.yidan.flyway.SelfProperties&quot;, &quot;defaultValue&quot;: &quot;hello flyway&quot;, &quot;deprecation&quot;: &#123; &quot;level&quot;: &quot;warning&quot;, &quot;reason&quot;: &quot;测试忽略理由&quot;, &quot;replacement&quot;: &quot;hello configuration&quot; &#125; &#125; ]&#125; 项目使用引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.yidan&lt;/groupId&gt; &lt;artifactId&gt;flyway-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;&lt;/dependency&gt; 使用我们自动装配的bean： SelfService, 修改配置文件中：flyway.self.message=hello configuration （此时IDEA会自动提示我们自定义的key，甚至有值的推荐） 1234567891011121314151617181920212223package com.yidan.passport;import com.yidan.flyway.SelfService;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @author wuxuan.chai * @date 2020/10/19 6:08 下午 */@RestControllerpublic class TestController &#123; @Resource private SelfService selfService; @GetMapping(&quot;/get&quot;) public String message() &#123; return selfService.message(); &#125;&#125; 测试： 12$ curl http:&#x2F;&#x2F;localhost:6002&#x2F;gethello configuration 完，后续遇到再做补充！！！","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://cha1yi.github.io/dist/tags/SpringBoot/"}],"author":"wuxuan.chai"},{"title":"SpringBoot测试系统整理","slug":"SpringBoot测试系统整理","date":"2021-01-18T01:56:07.559Z","updated":"2021-01-18T01:56:46.852Z","comments":true,"path":"2021/01/18/SpringBoot测试系统整理/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/SpringBoot%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/","excerpt":"","text":"SpringBoot测试系统整理Spring boot 作为当前最流行的java后端开发框架，集成了很多非常有用的东西，今天探索：Springboot test引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 一、测试方式的整理1.1、单元测试在维基百科中的解释： 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 例如在开发过程中，我们一般都是这么做单元测试的： 12345678public class UtilsTest &#123; @Test public void testStringBuilder()&#123; String result = new StringBuilder().append(1).append(1).toString(); assert &quot;11&quot;.equals(result); &#125;&#125; 通常来说，开发每当修改一次方法，都会重新进行单元测试，以保证程序的方法是正确的。虽然单元测试在开发过程中不是必须的，但是对于开发来说是非常有必要的，属于开发自测的一种非常实用的手段，减少代码出现bug的机率。 1.2、集成测试 集成测试（有时称为集成和测试(Integration Testing)，缩写为I＆T）是软件测试的阶段，在该阶段中，将各个软件模块组合在一起并作为一个整体进行测试。集成测试中进行评估依从性的系统或部件的与指定的功能要求。[1]它发生在单元测试之后和验证测试之前。集成测试以经过单元测试的输入模块为准，将它们按较大的聚合分组，应用集成测试计划中定义的测试这些聚合，并提供集成系统作为系统测试准备就绪的输出。 集成测试和单元测试的区别在于，单元测试仅仅测试的一般是一个方法(单元)，不涉及到方法组合测试，因此集成测试将完成多个单元的组合测试，以测试在具有业务场景的逻辑下进行的测试集成，所以一般单元测试在集成测试之前。 1.3、Mock测试Mock测试属于一种特殊的测试场景，在开发的过程中，可能由于协同开发的原因，自己需要测试自己开发的业务，但是业务中又依赖了同事开发的一些功能。按照正常的测试逻辑，可能会出现无法正常的完成测试需求，甚至代码都无法执行，此时就可以使用Mock测试的方法方法。Mock测试的原理大致为：如果测试的方法依赖未知的对象时，可以通过Mock去抽象这个未知的对象，并对未知的对象的方法进行抽象返回我们想要的数据，以供我们的测试使用。以此完成我们的方法测试需求。Spring Boot的测试模块支持Mock测试和junit测试。因此我们在SpringBoot开发时，可以在引入了Springboot测试模块后直接享受Mock测试和Junit单元测试带来的便利。 二、Springboot常用的测试方法2.1、测试普通工具方法所谓普通的方法，类似于工具类中的工具方法，不依赖于任何外部环境，例如Spring上下文信息，redis template，Mysql jdbc等。那么我们可以直接使用Junit对其进行测试。 1234567public class UtilsTest &#123; @Test public void testStringBuilder()&#123; String result = new StringBuilder().append(1).append(1).toString(); assert &quot;11&quot;.equals(result); &#125;&#125; 2.3、测试业务方法在Spring中的业务方法，都是通过IOC直接注入到Spring 容器中的，简单的使用Junit是无法直接执行的，必须指定Spring的上下文信息，保证其运行时能够从Spring容器中获取到对应的依赖Bean。例如： 1234567891011121314151617@SpringBootTest@RunWith(SpringRunner.class)public class CarServiceTest &#123; @Autowired public CarService carService; @Test @Rollback @Transactional public void testAdd()&#123; Car car = new Car(); car.setType(&quot;SUV&quot;); car.setName(&quot;BMW&quot;); car = carService.add(car); System.out.println(car); &#125;&#125; 测试CarService中的一个add方法，并且注入了CarService的Bean，@Transactional 开启了该方法的事务，@Rollback的意思是，执行玩测试方法，事务回滚，即不会修改数据库的数据。@Rollback必须配合@Transactional ，也就是只有事务开启了，才会生效。 2.3、测试Restful接口在开发过程中，需要测试提供给前端的接口，一般有两种方式： postman：好处能够和对应的google插件一起配合使用，共享google浏览器的cookie信息 MockMvc的方式：好处就是纯代码测试，可以控制数据入库，也能得到更详细请求数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@SpringBootTest@RunWith(SpringRunner.class)public class CarControllerTest &#123; private MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setupMockMvc()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125; @SneakyThrows @Test public void testListCar()&#123; mockMvc.perform(get(&quot;/car/list/&quot;)).andDo(MockMvcResultHandlers.print()); &#125; @SneakyThrows @Test @Rollback @Transactional public void testAdd()&#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;name\\&quot;: \\&quot;BMW\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;SUV\\&quot;\\n&quot; + &quot;&#125;&quot;; mockMvc.perform(post(&quot;/car/&quot;).accept(MediaType.APPLICATION_JSON_VALUE).content(json).contentType(MediaType.APPLICATION_JSON_VALUE)) .andDo(MockMvcResultHandlers.print()); &#125;&#125;//测试的结果： /** * * MockHttpServletRequest: * HTTP Method = POST * Request URI = /car/ * Parameters = &#123;&#125; * Headers = [Content-Type:&quot;application/json&quot;, Accept:&quot;application/json&quot;, Content-Length:&quot;40&quot;] * Body = &lt;no character encoding set&gt; * Session Attrs = &#123;&#125; * * Handler: * Type = com.yiyi.controller.CarController * Method = com.yiyi.controller.CarController#add(Car) * * Async: * Async started = false * Async result = null * * Resolved Exception: * Type = null * * ModelAndView: * View name = null * View = null * Model = null * * FlashMap: * Attributes = null * * MockHttpServletResponse: * Status = 200 * Error message = null * Headers = [Content-Type:&quot;application/json&quot;] * Content type = application/json * Body = &#123;&quot;id&quot;:27,&quot;name&quot;:&quot;BMW&quot;,&quot;type&quot;:&quot;SUV&quot;&#125; * Forwarded URL = null * Redirected URL = null * Cookies = [] */ 在面的测试例子中，做了两件事：1、开启了Springboot的测试，初始化了Spring的上下文环境2、通过web上下文，初始化了MockMvc的Bean，便于接口的请求 2.4、特殊场景下，自定义配置的测试2.4.1、指定profile的方式新增配置文件application-test.xml将@ActiveProfiles设置为test，在运行测试时，将会按照上面的配置文件进行初始化Spring bean 12345678910111213141516171819202122232425@SpringBootTest@RunWith(SpringRunner.class)@ActiveProfiles(&quot;test&quot;)public class CarServiceTest &#123; @Autowired public CarService carService; @Value(&quot;$&#123;test.value&#125;&quot;) private int value; @Test public void testAdd()&#123; Car car = new Car(); car.setType(&quot;SUV&quot;); car.setName(&quot;BMW&quot;); car = carService.add(car); System.out.println(car); &#125; @Test public void testGetValue()&#123; assert value == 2; &#125;&#125; 2.5、Mock测试的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@SpringBootTest@RunWith(SpringRunner.class)public class MockTest &#123; @MockBean private CarService carService; public MockMvc mockMvc; @Autowired public WebApplicationContext context; @Before public void setUp()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @SneakyThrows @Test public void testAddCar()&#123; //测试添加CarController 的addCar接口，使用MockBean模拟的CarService的Bean Car car = new Car(); car.setId(111L); car.setName(&quot;BYD&quot;); car.setType(&quot;SUV&quot;); Car car1 = new Car(); //期望调用addCar方法传入一个car1返回一个car的对象，对象的数据为 id=111L，name=BYD， type=SUV Mockito.when(carService.add(car1)).thenReturn(car); String json = &quot;&#123;&#125;&quot;; mockMvc.perform(post(&quot;/car/&quot;).accept(MediaType.APPLICATION_JSON_VALUE).content(json).contentType(MediaType.APPLICATION_JSON_VALUE)) .andDo(MockMvcResultHandlers.print()); //执行结果： /** * MockHttpServletRequest: * HTTP Method = POST * Request URI = /car/ * Parameters = &#123;&#125; * Headers = [Content-Type:&quot;application/json&quot;, Accept:&quot;application/json&quot;, Content-Length:&quot;2&quot;] * Body = &lt;no character encoding set&gt; * Session Attrs = &#123;&#125; * * Handler: * Type = com.yiyi.controller.CarController * Method = com.yiyi.controller.CarController#add(Car) * * Async: * Async started = false * Async result = null * * Resolved Exception: * Type = null * * ModelAndView: * View name = null * View = null * Model = null * * FlashMap: * Attributes = null * * MockHttpServletResponse: * Status = 200 * Error message = null * Headers = [Content-Type:&quot;application/json&quot;] * Content type = application/json * Body = &#123;&quot;id&quot;:111,&quot;name&quot;:&quot;BYD&quot;,&quot;type&quot;:&quot;SUV&quot;&#125; * Forwarded URL = null * Redirected URL = null * Cookies = [] */ &#125;&#125; 在这个测试代码中，模拟了一个CarService的bean，并且模拟了CarService#add(car)的方法参数及返回的结果。所以Controller的接口调用依赖了这个模拟的方法，所以返回的结果和我们预期模拟的结果是一致的。针对于上面的例子，如果在不mock的方法的前提下调用Mock出来的CarSerVice#list()方法，结果会是什么呢？回去执行原本的Spring的代理方法操作数据库还是报错呢？ 123456789101112131415161718192021222324252627282930313233@SpringBootTest@RunWith(SpringRunner.class)public class MockTest &#123; @MockBean private CarService carService; public MockMvc mockMvc; @Autowired public WebApplicationContext context; @Before public void setUp()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void testList()&#123; Car car = new Car(); car.setName(&quot;BYD&quot;); car.setType(&quot;SUV&quot;); Car car1 = carService.add(car); System.out.println(&quot;car：&quot;+car1); List&lt;Car&gt; list = carService.list(); System.out.println(&quot;carList:&quot;+list); //result: /** * car：null * carList:[] */ &#125;&#125; 结果表明:没有执行数据库的操作，而是mock返回的是方法的默认值。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"},{"name":"Spring test","slug":"Spring-test","permalink":"https://cha1yi.github.io/dist/tags/Spring-test/"}],"author":"wuxuan.chai"},{"title":"Spring事件驱动模型","slug":"Spring事件驱动模型","date":"2021-01-18T01:52:51.420Z","updated":"2021-01-18T01:56:37.009Z","comments":true,"path":"2021/01/18/Spring事件驱动模型/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Spring%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"一、Spring 事件驱动的简介事件驱动模型，简单理解就是发布-订阅模型，Spring针对这种发布-订阅模型作出了两种解决方案，应用间的发布-订阅模型，可以使用Spring AMQP和 Spring for Apache Kafka，结合Rabbit或者kafka等消息中间件完成。应用内的发布-订阅模型，可以使用Spring 的Application上下文提供的方案解决。这篇文章主要描述Spring 的应用内的事件驱动的实现以及应用。 二、Spring 应用内的事件驱动模型示例2.1、需求背景页面埋点，收集用户访问信息，并记录到数据库，并且根据用户的PV，作出适当的商品邮件推送 2.2、需求拆解 前端需要收集用户在当前页面的访问信息，调用后端提供的埋点接口，将数据提供给后端处理。（前端功能不做示例） 后端的埋点接口，调用发布消息的方法（发布事件） 后端需要开发对应的事件订阅方法，将事件解析并持久化，以及作出适当的邮件推送2.3、代码实现1、埋点接口12345678910111213141516171819202122232425262728293031package com.yiyi;import com.yiyi.service.MyEventService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * @author wuxuan.chai * @date 2020/6/22 12:59 下午 */@RestController@RequestMapping(value = &quot;/&quot;,produces = MediaType.APPLICATION_JSON_VALUE)public class EventController &#123; private final MyEventService myEventService; @Autowired public EventController(MyEventService myEventService) &#123; this.myEventService = myEventService; &#125; @PutMapping(&quot;send/&quot;) public void sendMessage(@RequestParam String msg)&#123; myEventService.publishEvent(msg); &#125;&#125; 2、定义事件接受类12345678910111213141516171819202122232425262728package com.yiyi.event;import lombok.Getter;import org.springframework.context.ApplicationEvent;/** * @author wuxuan.chai * @date 2020/6/22 12:51 下午 */@Getterpublic class MyEvent extends ApplicationEvent &#123; //前端的埋点收集信息 private String msg; /** * Create a new &#123;@code ApplicationEvent&#125;. * * @param source the object on which the event initially occurred or with * which the event is associated (never &#123;@code null&#125;) */ public MyEvent(Object source) &#123; super(source); &#125; public MyEvent(Object source, String msg) &#123; super(source); this.msg = msg; &#125;&#125; 3、发布事件12345678910111213141516171819202122232425262728package com.yiyi.service;import com.yiyi.event.MyEvent;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;/** * @author wuxuan.chai * @date 2020/6/22 12:52 下午 */@Componentpublic class MyEventService implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; //发布事件 public void publishEvent(String msg)&#123; MyEvent myEvent = new MyEvent(this,msg); applicationContext.publishEvent(myEvent); &#125;&#125; 4.订阅事件 12345678910111213141516171819202122232425package com.yiyi.compoent;import com.yiyi.event.MyEvent;import lombok.extern.slf4j.Slf4j;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;/** * @author wuxuan.chai * @date 2020/6/22 12:55 下午 */@Component@Slf4jpublic class EventListenerComponent &#123; @EventListener public void getEvent(MyEvent myEvent) &#123; log.info(&quot;持久化用户的浏览记录：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener public void sendEmail(MyEvent myEvent) &#123; log.info(&quot;发送Email：&#123;&#125;&quot;, myEvent.getMsg()); &#125;&#125; 5、执行结果 1232020-06-22 18:01:25.599 INFO 14040 --- [nio-1234-exec-2] c.yiyi.compoent.EventListenerComponent : 持久化用户的浏览记录：查看了华为Mate40 pro2020-06-22 18:01:25.599 INFO 14040 --- [nio-1234-exec-2] c.yiyi.compoent.EventListenerComponent : 发送Email：查看了华为Mate40 pro 2.4、实现优化的思考及实现方法1、如何提高埋点的并发？答：Spring 提供了方法异步执行的功能，需要开启异步执行—–@EnableAsync。然后通过@Async开启订阅者异步消费事件，异步执行的本质，就是将方法的执行的逻辑放到一个单独的线程中去执行。示例：(1)、开启异步执行 12345678910111213141516171819202122232425262728293031323334353637383940package com.yiyi.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.AsyncConfigurer;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import java.util.concurrent.Executor;import java.util.concurrent.ThreadPoolExecutor;/** * @author wuxuan.chai * @date 2020/6/22 1:27 下午 */@Configuration@EnableAsyncpublic class AsyncListenerConfig implements AsyncConfigurer &#123; //定义一个线程池 @Override @Bean(name = &quot;taskExecutor&quot;) public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.initialize(); //设置核心线程数 executor.setCorePoolSize(10); //设置最大线程数 executor.setMaxPoolSize(20); //设置队列的大小 executor.setQueueCapacity(1000); //设置最大的线程空闲时间 executor.setKeepAliveSeconds(300); //设置线程名称 executor.setThreadNamePrefix(&quot;event-executor-&quot;); //拒绝策略 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); return new ExceptionHandlingAsyncTaskExecutor(executor); &#125;&#125; (2)、设置异步执行的任务执行器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.yiyi.config;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.core.task.AsyncTaskExecutor;import java.util.concurrent.Callable;import java.util.concurrent.Future;/** * 用独立的线程来包装，类似与@Async * @author wuxuan.chai * @date 2020/6/22 2:58 下午 */@AllArgsConstructor@NoArgsConstructor@Slf4jpublic class HandlingAsyncTaskExecutor implements AsyncTaskExecutor &#123; public AsyncTaskExecutor executor; @Override public void execute(Runnable task, long startTimeout) &#123; executor.execute(createWrappedRunnable(task), startTimeout); &#125; @Override public void execute(Runnable task) &#123; executor.execute(createWrappedRunnable(task)); &#125; @Override public Future&lt;?&gt; submit(Runnable task) &#123; return executor.submit(createWrappedRunnable(task)); &#125; @Override public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; return executor.submit(createCallable(task)); &#125; private &lt;T&gt; Callable&lt;T&gt; createCallable(final Callable&lt;T&gt; callable) &#123; return () -&gt; &#123; try &#123; return callable.call(); &#125; catch (Exception e) &#123; handle(e); throw e; &#125; &#125;; &#125; private Runnable createWrappedRunnable(Runnable task) &#123; return () -&gt; &#123; try &#123; task.run(); &#125; catch (Exception e) &#123; handle(e); throw e; &#125; &#125;; &#125; private void handle(Exception e) &#123; log.error(&quot;异步执行报错：&#123;&#125;&quot;, e.getMessage(), e); &#125;&#125; (3)、异步消费事件 12345678910111213141516171819202122232425262728package com.yiyi.compoent;import com.yiyi.event.MyEvent;import lombok.extern.slf4j.Slf4j;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;import org.springframework.scheduling.annotation.Async;/** * @author wuxuan.chai * @date 2020/6/22 12:55 下午 */@Component@Slf4jpublic class EventListenerComponent &#123; @EventListener @Async public void getEvent(MyEvent myEvent) &#123; log.info(&quot;持久化用户的浏览记录：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener @Async public void sendEmail(MyEvent myEvent) &#123; log.info(&quot;发送Email：&#123;&#125;&quot;, myEvent.getMsg()); &#125;&#125; 至此，发送邮件和持久化浏览记录都是异步执行的了，埋点接口的http链接会立即释放。对于执行埋点的接口执行来讲，能够多支持一些并发，当然可以在此基础上继续优化，例如批量持久化，批量发送email等。最大限度的利用线程。 2、如果持久化失败了，如何做到不让邮件发送？答：在之前开发的CRUD中，我们避免程序错误导致脏库，一般在做DML操作的时候，都会加入事务。与之类似，订阅者也会有事务的概念。示例：发布事件，添加事务 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.service;import com.yiyi.domain.EventDomain;import com.yiyi.domain.EventMapper;import com.yiyi.event.MyEvent;import org.springframework.beans.BeansException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;/** * @author wuxuan.chai * @date 2020/6/22 12:52 下午 */@Componentpublic class MyEventService implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Autowired private EventMapper eventMapper; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @Transactional(rollbackFor = Exception.class) public void publishEvent(String msg) throws Exception &#123; MyEvent myEvent = new MyEvent(this,msg); applicationContext.publishEvent(myEvent); EventDomain eventDomain = new EventDomain(); eventDomain.setMessage(msg); eventMapper.save(eventDomain); throw new Exception(&quot;error！&quot;); &#125;&#125; 订阅事件，给getEventSecond方法添加事务监听注解 12345678910111213141516171819202122232425262728293031323334package com.yiyi.compoent;import com.yiyi.event.MyEvent;import lombok.extern.slf4j.Slf4j;import org.springframework.context.event.EventListener;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import org.springframework.transaction.event.TransactionalEventListener;/** * @author wuxuan.chai * @date 2020/6/22 12:55 下午 */@Component@Slf4jpublic class EventListenerComponent &#123; @EventListener @Order(2) public void getEventFirst(MyEvent myEvent) &#123; log.info(&quot;我是第一个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @TransactionalEventListener @Order(1) public void getEventSecond(MyEvent myEvent) &#123; log.info(&quot;我是第二个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener @Order(3) public void getEventThird(MyEvent myEvent) &#123; log.info(&quot;我是第三个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125;&#125; 执行结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768692020-06-22 22:12:42.980 INFO 14373 --- [nio-1234-exec-3] c.yiyi.compoent.EventListenerComponent : 我是第一个收到消息：查看了华为Mate40 pro2020-06-22 22:12:42.980 INFO 14373 --- [nio-1234-exec-3] c.yiyi.compoent.EventListenerComponent : 我是第三个收到消息：查看了华为Mate40 proHibernate: select next_val as id_val from hibernate_sequence for updateHibernate: update hibernate_sequence set next_val= ? where next_val=?java.lang.Exception: error！ at com.yiyi.service.MyEventService.publishEvent(MyEventService.java:36) at com.yiyi.service.MyEventService$$FastClassBySpringCGLIB$$f3a92ba1.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) at com.yiyi.service.MyEventService$$EnhancerBySpringCGLIB$$fb19b4c8.publishEvent(&lt;generated&gt;) at com.yiyi.EventController.sendMessage(EventController.java:29) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920) at javax.servlet.http.HttpServlet.service(HttpServlet.java:663) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) 通过上述的执行结果很容易看出，@TransactionalEventListener注解所在的方法是在发布者的事务完成之后进行调用的，而且执行的顺序落后于@EventListener。除此之外，@EventListener，不管发布者事务是否提交，都会执行订阅的逻辑。:::tip订阅执行的顺序：@EventListener&gt;@EventListener+@Async&gt;@TransactionalEventListener::: 3、如何保持订阅被有序执行？答：Spring提供@Order的枚举，通过这个我们可以给订阅者设置顺序，那么在消费事件的时候，就会遵循这个顺序。示例： 1234567891011121314151617181920212223242526272829303132package com.yiyi.compoent;import com.yiyi.event.MyEvent;import lombok.extern.slf4j.Slf4j;import org.springframework.context.event.EventListener;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;/** * @author wuxuan.chai * @date 2020/6/22 12:55 下午 */@Component@Slf4jpublic class EventListenerComponent &#123; @EventListener @Order(2) public void getEventFirst(MyEvent myEvent) &#123; log.info(&quot;我是第一个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener @Order(1) public void getEventSecond(MyEvent myEvent) &#123; log.info(&quot;我是第二个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125; @EventListener @Order(3) public void getEventThird(MyEvent myEvent) &#123; log.info(&quot;我是第三个收到消息：&#123;&#125;&quot;, myEvent.getMsg()); &#125;&#125; 执行结果： 1232020-06-22 18:30:34.689 INFO 14195 --- [nio-1234-exec-1] c.yiyi.compoent.EventListenerComponent : 我是第二个收到消息：查看了华为Mate40 pro2020-06-22 18:30:34.691 INFO 14195 --- [nio-1234-exec-1] c.yiyi.compoent.EventListenerComponent : 我是第一个收到消息：查看了华为Mate40 pro2020-06-22 18:30:34.691 INFO 14195 --- [nio-1234-exec-1] c.yiyi.compoent.EventListenerComponent : 我是第三个收到消息：查看了华为Mate40 pro 三、Spring 事件驱动的原理","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"},{"name":"事件驱动","slug":"事件驱动","permalink":"https://cha1yi.github.io/dist/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"}],"author":"wuxuan.chai"},{"title":"Spring Cache 源码学习，自定义CacheManager","slug":"Spring Cache 源码学习，自定义CacheManager","date":"2021-01-18T01:48:30.711Z","updated":"2021-01-18T02:16:56.162Z","comments":true,"path":"2021/01/18/Spring Cache 源码学习，自定义CacheManager/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Spring%20Cache%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89CacheManager/","excerpt":"","text":"Spring Cache 源码学习，自定义CacheManager一、学习背景&emsp;&emsp;最近一直在学习Spring boot的框架，因为之前一直接触的都是Spring + Spring mvc + mybatis的ssm框架，对于约定大于配置的这种开发理念还是不太熟悉和上手，所以决定系统学习下Springboot。最近在看项目代码，对代码中Spring cache的一些自定义拓展很感兴趣，所以就好好整理下。（基于Spring 5.2.6-release 版本） 二、Spring Cache的源码学习2.1、Spring Cache的核心接口2.1.1、Cache123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package org.springframework.cache;import java.util.concurrent.Callable;import org.springframework.lang.Nullable;/** * 定义通用缓存操作的接口。 * * &lt;b&gt;注意：&lt;/b&gt;由于缓存的一般用法，建议实现允许存储&lt;tt&gt; null &lt;/tt&gt;值（例如，存储返回&#123;@code null&#125;的方法）。 * * @author Costin Leau * @author Juergen Hoeller * @author Stephane Nicoll * @since 3.1 */public interface Cache &#123; /** * 返回缓存的名称 */ String getName(); /** * 返回基础本机缓存提供程序。这里是指缓存实现类对象,返回类型为Class&lt;T extend Cache&gt; class */ Object getNativeCache(); /** * 返回此缓存将指定键映射到的值。 &lt;p&gt;如果缓存不包含该键的映射，则返回&#123;@code null&#125;； 否则，缓存的值（本身可能为&#123;@code null&#125;）将在&#123;@link * ValueWrapper&#125;中返回。 * @param key 要返回其关联值的key * @return 此缓存将指定键映射到的值，该值包含在&#123;@link ValueWrapper&#125;中，该值也可以保存缓存的&#123;@code null&#125;值。 直接返回&#123;@code null&#125;表示缓* 存不包含该键的映射。 * @see #get(Object, Class) * @see #get(Object, Callable) */ @Nullable ValueWrapper get(Object key); /** * 返回此缓存将指定键映射到的值，通常指定返回值将强制转换为的类型。 &lt;p&gt;注意：&#123;@code get&#125;的此变体不允许区分已缓存的&#123;@code null&#125;值和根本找不 * 到缓存条目。 为此，请使用标准的&#123;@link #get(Object）&#125;变体。 * @param key 要返回其关联值的key * @param type 需要返回值的类型（可以为&#123;@code null&#125;来绕过类型检查；如果在缓存中找到&#123;@code null&#125;值，则指定的类型无关紧要） * @return 此高速缓存将指定键映射到的值（本身可以是&#123;@code null&#125;），如果高速缓存不包含此键的映射，则还可以是&#123;@code null&#125; * @throws IllegalStateException 如果找到了高速缓存条目但未能匹配指定的类型 * @since 4.0 * @see #get(Object) */ @Nullable &lt;T&gt; T get(Object key, @Nullable Class&lt;T&gt; type); /** * 返回此缓存将指定键映射到的值，并在必要时从&#123;@code valueLoader&#125;获取该值。 此方法为常规的“如果已缓存，则返回；否则创建，缓存并返回”模式提供 * 了简单的替代方法。 &lt;p&gt;如果可能，实现应确保加载操作是同步的，以便在同时访问同一键的情况下，仅调用一次指定的&#123;@code valueLoader&#125;。 &lt;p&gt;如果 *&#123;@code valueLoader&#125;引发异常，则将其包装在&#123;@link ValueRetrievalException&#125;中 * @param key 要返回其关联值的key * @return 此缓存将指定键映射到的值 * @throws ValueRetrievalException 如果&#123;@code valueLoader&#125;抛出异常 * @since 4.3 * @see #get(Object) */ @Nullable &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader); /** * 将指定的值与此高速缓存中的指定键相关联。 &lt;p&gt;如果高速缓存先前包含此键的映射，则旧值将由指定值替换。 &lt;p&gt;可以以异步或延迟的方式执行实际注册，随 * 后的查找可能仍未看到该条目。 例如，事务性缓存装饰器可能就是这种情况。 使用&#123;@link #putIfAbsent&#125;保证立即注册。 * @param key the key with which the specified value is to be associated * @param value the value to be associated with the specified key * @see #putIfAbsent(Object, Object) */ void put(Object key, @Nullable Object value); /** * 如果尚未将指定值与该高速缓存中的指定键原子关联，则该值尚未设置。 &lt;p&gt;这等效于：&lt;pre&gt; &lt;code&gt; ValueWrapper existingValue = cache.get（key）; 如果（existingValue == null）&#123;cache.put（key，value）; 返回现存值； &lt;/ code&gt; &lt;/ pre&gt;，但该操作是原子执行的。 虽然所有开箱即用的&#123;@link CacheManager&#125;实现都可以自动执行放置，但操作也可以分两个步骤实现，例如 以非原子方式检查存在性并随后放置。 有关更多详细信息，请查看所使用的本机缓存实现的文档。 &lt;p&gt;默认实现沿着上面的代码片段委托给&#123;@link #get（Object）&#125;和&#123;@link #put（Object，Object）&#125;。 * @param key 与指定值关联的键 * @param value 与指定键关联的值 * @return 此缓存将指定键映射到的值（本身可能是&#123;@code null&#125;），如果在此调用之前缓存不包含该键的任何映射，则还为&#123;@code null&#125;。 因此，返回&#123;@code null&#125;表示给定的&#123;@code value&#125;已与密钥相关联。 * @since 4.1 * @see #put(Object, Object) */ @Nullable default ValueWrapper putIfAbsent(Object key, @Nullable Object value) &#123; ValueWrapper existingValue = get(key); if (existingValue == null) &#123; put(key, value); &#125; return existingValue; &#125; /** * 如果存在，请从此缓存中退出此键的映射。 &lt;p&gt;可以以异步或延迟的方式执行实际逐出，随后的查找可能仍会看到该条目。 例如，事务性缓存装饰器可能就是这种情况。 使用&#123;@link #evictIfPresent&#125;确保立即删除。 * @param key 要从缓存中删除其映射的键 * @see #evictIfPresent(Object) */ void evict(Object key); /** * 如果存在此键，则从此缓存中退出该键的映射，并期望该键对于后续查找立即不可见。 &lt;p&gt;默认实现委派给&#123;@link #evict（Object）&#125;，对于未确定的先前存在的键，返回&#123;@code false&#125;。 鼓励高速缓存提供者，尤其是高速缓存装饰器，如果可能的话（例如，在事务中通常延迟的高速缓存操作的情况下）执行立即驱逐并可靠地确定给定密钥的先前存在。 * @param key 要从缓存中删除其映射的键 * @return &#123;@code true&#125;（如果以前知道缓存对此键有映射），&#123;@ code false&#125;（如果没有）（或者无法确定先前的存在） * @since 5.2 * @see #evict(Object) */ default boolean evictIfPresent(Object key) &#123; evict(key); return false; &#125; /** * 通过删除所有映射来清除缓存。 &lt;p&gt;可以以异步或延迟的方式执行实际清除，随后的查找可能仍会看到条目。 例如，事务性缓存装饰器可能就是这种情况。 使用&#123;@link #invalidate（）&#125;可以确保立即删除条目。 * @see #invalidate() */ void clear(); /** * 通过删除所有映射来使缓存无效，并期望所有条目对于随后的查找立即不可见。 @return &#123;@code true&#125;（如果以前知道该缓存具有映射），&#123;@ code false&#125;（如果没有）（或者如果无法确定先前是否存在条目） * @since 5.2 * @see #clear() */ default boolean invalidate() &#123; clear(); return false; &#125; /** * 代表缓存值的（包装）对象。 */ @FunctionalInterface interface ValueWrapper &#123; /** * 返回缓存中的实际值。 */ @Nullable Object get(); &#125; /** * 如果值加载程序回调因异常而失败，则从&#123;@link #get(Object，Callable）&#125;引发包装器异常。 * @since 4.3 */ @SuppressWarnings(&quot;serial&quot;) class ValueRetrievalException extends RuntimeException &#123; @Nullable private final Object key; public ValueRetrievalException(@Nullable Object key, Callable&lt;?&gt; loader, Throwable ex) &#123; super(String.format(&quot;Value for key &#x27;%s&#x27; could not be loaded using &#x27;%s&#x27;&quot;, key, loader), ex); this.key = key; &#125; @Nullable public Object getKey() &#123; return this.key; &#125; &#125;&#125; 2.1.2、CacheManager12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.cache;import java.util.Collection;import org.springframework.lang.Nullable;/** * Spring的中央缓存管理器SPI。 * * &lt;p&gt;允许检索命名的&#123;@link Cache&#125;区域。 * * @author Costin Leau * @author Sam Brannen * @since 3.1 */public interface CacheManager &#123; /** * 获取与给定名称关联的缓存。 &lt;p&gt;请注意，如果本机提供程序支持，则缓存可能会在运行时延迟创建。 * @param name 缓存标识符（不得为&#123;@code null&#125;） * @return 关联的缓存，如果不存在或无法创建，则为&#123;@code null&#125; */ @Nullable Cache getCache(String name); /** * 获取此管理器已知的缓存名称的集合。 * @return 缓存管理器已知的所有缓存的名称 */ Collection&lt;String&gt; getCacheNames();&#125; 2.1.3、Cache相关的注解Spring cache 为了方便我们对缓存的使用，提供了五个比较有用的注解： @Cacheable @CachePut @CacheEvict @Caching @CacheConfig 2.1.3.1、@Cacheable源码注释翻译： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.concurrent.Callable;import org.springframework.core.annotation.AliasFor;/** * 标注可以缓存调用方法（或类中的所有方法）结果的注释。 * * &lt;p&gt;每次调用建议的方法时，都会应用缓存行为，检查是否已为给定参数调用了该方法。 通常默认设置只是使用方法参数来计算密钥，但是可以通过&#123;@link #key&#125;属性提供SpEL表达式，或者自定义&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125;实现可以替换 默认值之一（请参见&#123;@link #keyGenerator&#125;）。 * * &lt;p&gt;如果在高速缓存中找不到所计算键的值，则将调用目标方法，并将返回的值存储在关联的高速缓存中。 请注意，Java8的&#123;@code Optional&#125;返回类型是自动处理的，并且其内容存储在缓存中（如果存在）。 * * &lt;p&gt;此注释可用作&lt;em&gt;元注释&lt;/ em&gt;，以创建具有属性覆盖的自定义&lt;em&gt;组成的注释&lt;/ em&gt;。 * * @author Costin Leau * @author Phillip Webb * @author Stephane Nicoll * @author Sam Brannen * @since 3.1 * @see CacheConfig */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Cacheable &#123; /** * 缓存名称的别名 */ @AliasFor(&quot;cacheNames&quot;) String[] value() default &#123;&#125;; /** * 存储方法调用结果的缓存的名称。 * &lt;p&gt;名称可用于确定目标缓存（或多个缓存），与特定Bean定义的限定符值或Bean名称匹配。 * @since 4.2 * @see #value * @see CacheConfig#cacheNames */ @AliasFor(&quot;value&quot;) String[] cacheNames() default &#123;&#125;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String key() default &quot;&quot;; /** * 要使用的自定义&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125;的bean名称。 &lt;p&gt;与&#123;@link #key&#125;属性互斥。 * @see CacheConfig#keyGenerator */ String keyGenerator() default &quot;&quot;; /** * 自定义&#123;@link org.springframework.cache.CacheManager&#125;的bean名称，用于创建默认的&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;（如果尚未设置）。 * &lt;p&gt;与&#123;@link #cacheResolver&#125;属性互斥。 * @see org.springframework.cache.interceptor.SimpleCacheResolver * @see CacheConfig#cacheManager */ String cacheManager() default &quot;&quot;; /** * 要使用的定制&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;的bean名称。 * @see CacheConfig#cacheResolver */ String cacheResolver() default &quot;&quot;; /** * Spring表达式语言（SpEL）表达式，用于使方法缓存成为条件。 * &lt;p&gt;默认值为&#123;@code“”&#125;，这意味着方法结果始终被缓存。 * &lt;p&gt; SpEL表达式根据提供以下元数据的专用上下文进行评估：&lt;ul&gt; * &lt;li&gt; &#123;@ code＃root.method&#125;，&#123;@ code＃root.target&#125;和&#123;@code #root。 缓存&#125;，分别引用&#123;@link java.lang.reflect.Method方法&#125;，目标对象和受影响的缓存。&lt;/li&gt; * &lt;li&gt;方法名称的快捷方式（&#123;@code＃root.methodName &#125;）和目标类别（&#123;@code＃root.targetClass&#125;）也可用。 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args [1]&#125;，&#123;@ code＃p1&#125;或&#123;@code＃a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; &lt;/ ul&gt; */ String condition() default &quot;&quot;; /** * Spring表达式语言（SpEL）表达式用于否决方法缓存。 * &lt;p&gt;与&#123;@link #condition&#125;不同，此表达式是在调用方法后求值的，因此可以引用&#123;@code result&#125;。 * &lt;p&gt;默认值为&#123;@code“”&#125;，表示永远不会否决缓存。 * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; * @since 3.2 */ String unless() default &quot;&quot;; /** * 如果多个线程试图为同一键加载值，则同步基础方法的调用。 同步带来了两个限制： * &lt;ol&gt; * &lt;li&gt;不支持&#123;@link #unless（）&#125;&lt;/li&gt; * &lt;li&gt;只能指定一个缓存&lt;/li&gt; * &lt;li&gt;不能合并其他与缓存相关的操作&lt;/li&gt; * &lt;/ol&gt; * 这实际上是一个提示，您正在使用的实际缓存提供程序可能不以同步方式支持它。 检查您的提供程序文档，以获取有关实际语义的更多详细信息。 * @since 4.3 * @see org.springframework.cache.Cache#get(Object, Callable) */ boolean sync() default false;&#125; 主要参数 描述 用法 value cacheNames 的别名 @Cacheable(“mysqlCache”) cacheNames 缓存的名称 @Cacheable(cacheNames = MysqlCache.NAME) key 缓存的key，支持Spring EL 表达式 @Cacheable(cacheNames = MysqlCache.NAME, key = “‘CacheDemoService-get’+ args[0]”) @Cacheable(cacheNames = MysqlCache.NAME, key = “‘CacheDemoService-get’+ #p0”) @Cacheable(cacheNames = MysqlCache.NAME, key = “‘CacheDemoService-get’+ #a0”) keyGenerator key的构造器，和key属性互斥 需要定义一个customerKeyGenerator的bean @Cacheable(cacheNames = MysqlCache.NAME, keyGenerator = “customerKeyGenerator”) cacheManager 指定CacheManager，需要先定义CacheManager的bean，指定后则不能指定cacheResolver，两者互斥，如不指定，则使用注入的默认的CacheManagerBean @Cacheable(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”） cacheResolver 指定cacheResolver的bean的名称，和cacheManager互斥 暂时未做测试 condition 是否使用方法缓存条件，默认“”，是否去取方法缓存，在方法执行之前计算条件结果 @Cacheable(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,condition=“#a0 == ‘xx’”) unless 否决方法的结果缓存，默认“”，始终缓存方法，如果条件不成立则不缓存方法结果，在方法执行结果后计算条件结果 @Cacheable(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,unless=“#a0 == ‘xx’”) sync 多线程访问方法，是否同步缓存，默认值为false，使用有三个限制，不支持unless，只能指定一个缓存，不能与@Caching一起使用 @Cacheable(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,sync=false) 2.1.3.2、@CachePut源码注释翻译： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;/** * 指示方法（或类中的所有方法）触发&#123;@link org.springframework.cache.Cache＃put(Object，Object）cache put&#125;操作的注释。 * * &lt;p&gt;与&#123;@link Cacheable @Cacheable&#125;注释相反，此注释不会导致建议的方法被跳过。 而是，它总是使方法被调用并将其结果存储在关联的缓存中。 请注意，Java8的&#123;@code Optional&#125;返回类型是自动处理的，并且其内容存储在缓存中（如果存在）。 * * &lt;p&gt;此注释可用作&lt;em&gt;元注释&lt;/ em&gt;，以创建具有属性覆盖的自定义&lt;em&gt;组成的注释&lt;/ em&gt;。 * * @author Costin Leau * @author Phillip Webb * @author Stephane Nicoll * @author Sam Brannen * @since 3.1 * @see CacheConfig */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CachePut &#123; /** * 别名&#123;@link #cacheNames&#125;. */ @AliasFor(&quot;cacheNames&quot;) String[] value() default &#123;&#125;; /** * 用于缓存放置操作的缓存名称。 * &lt;p&gt;名称可以用来确定目标缓存（或多个缓存），与特定bean定义的限定符值或bean名称匹配。 * @since 4.2 * @see #value * @see CacheConfig#cacheNames */ @AliasFor(&quot;value&quot;) String[] cacheNames() default &#123;&#125;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String key() default &quot;&quot;; /** * 要使用的自定义&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125;的bean名称。 &lt;p&gt;与&#123;@link #key&#125;属性互斥。 * @see CacheConfig#keyGenerator */ String keyGenerator() default &quot;&quot;; /** * 自定义&#123;@link org.springframework.cache.CacheManager&#125;的bean名称，用于创建默认的&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;（如果尚未设置）。 * &lt;p&gt;与&#123;@link #cacheResolver&#125;属性互斥。 * @see org.springframework.cache.interceptor.SimpleCacheResolver * @see CacheConfig#cacheManager */ String cacheManager() default &quot;&quot;; /** * 要使用的定制&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;的bean名称。 * @see CacheConfig#cacheResolver */ String cacheResolver() default &quot;&quot;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String condition() default &quot;&quot;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String unless() default &quot;&quot;;&#125; 主要参数 描述 注释 value 同Cacheable @CachePut(“mysqlCache”) cacheNames 同Cacheable @CachePut(cacheNames=”mysqlCache”) key 同Cacheable @CachePut(cacheNames=”mysqlCache”,key=”#a1”) keyGenerator 同Cacheable @CachePut(cacheNames=”mysqlCache”,keyGenerator=”customKeyGenerator”) cacheManager 同Cacheable @CachePut(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”) cacheResolver() 同Cacheable 暂未测试 condition 同Cacheable @CachePut(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,condition=”#a1 == ‘xxx’”) unless 同Cacheable @CachePut(cacheNames = MysqlCache.NAME, cacheManager=”mysqlCacheManager”,keyGenerator = “customerKeyGenerator”,unless=”#a1 == ‘xxx’”) 2.1.3.3、@CacheEvict源码注释翻译： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;/** * 表示方法（或类中的所有方法）触发&#123;@link org.springframework.cache.Cache＃evict（Object）cache evict&#125;操作的注释。 * * &lt;p&gt;此注释可用作&lt;em&gt;元注释&lt;/ em&gt;，以创建具有属性覆盖的自定义&lt;em&gt;组成的注释&lt;/ em&gt;。 * * @author Costin Leau * @author Stephane Nicoll * @author Sam Brannen * @since 3.1 * @see CacheConfig */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CacheEvict &#123; /** * 别名 &#123;@link #cacheNames&#125;. */ @AliasFor(&quot;cacheNames&quot;) String[] value() default &#123;&#125;; /** * 用于缓存逐出操作的缓存名称。 &lt;p&gt;名称可用于确定目标缓存（或多个缓存），与特定Bean定义的限定符值或Bean名称匹配。 * @since 4.2 * @see #value * @see CacheConfig#cacheNames */ @AliasFor(&quot;value&quot;) String[] cacheNames() default &#123;&#125;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String key() default &quot;&quot;; /** * 自定义key生成器的bean名字&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125; * to use. * &lt;p&gt;与 &#123;@link #key&#125; 互斥 * @see CacheConfig#keyGenerator */ String keyGenerator() default &quot;&quot;; /** * 自定义&#123;@link org.springframework.cache.CacheManager&#125;的bean名称，用于创建默认的&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;（如果尚未设置）。 * &lt;p&gt;与&#123;@link #cacheResolver&#125; 互斥. * @see org.springframework.cache.interceptor.SimpleCacheResolver * @see CacheConfig#cacheManager */ String cacheManager() default &quot;&quot;; /** * 自定义的bean的名称&#123;@link org.springframework.cache.interceptor.CacheResolver&#125; * to use. * @see CacheConfig#cacheResolver */ String cacheResolver() default &quot;&quot;; /** * 用于动态计算键的Spring表达式语言(SpEL)表达式。 * * 默认值是&#123;@code &quot;&quot;&#125;，意味着所有的方法参数都会被考虑作为一个key，除非自定义的key生成器生效。 &#123;@link #keyGenerator&#125; * * spring el表达式的计算取决于上小文提供的元数据： * 包含&#123;@code #root.method&#125;, &#123;@code #root.target&#125;, and &#123;@code #root.caches&#125; 引用&#123;@link java.lang.reflect.Method method&#125;，目标对象，和受影响的缓存。还提供了(&#123;@code #root.methodName&#125;) 方法名称 (&#123;@code #root.targetClass&#125;)目标类名称的快捷方式 * 方法参数可以作为关联索引 * &lt;li&gt;方法参数可以通过索引访问。 例如，可以通过&#123;@code＃root.args[1]&#125;，&#123;@ code #p1&#125;或&#123;@code #a1&#125;访问第二个自变量。 如果该信息可用，也可以按名称访问参数。&lt;/li&gt; */ String condition() default &quot;&quot;; /** * 是否删除缓存内的所有条目。 * &lt;p&gt;默认情况下，仅删除关联键下的值。 * &lt;p&gt;请注意，不允许将此参数设置为&#123;@code true&#125;并指定&#123;@link #key&#125;。 */ boolean allEntries() default false; /** * 在调用该方法之前是否应该收回。 * &lt;p&gt;将此属性设置为&#123;@code true&#125;，将导致驱逐发生，而与方法结果无关（即，是否引发异常）。 * &lt;p&gt;默认值为&#123;@code false&#125;，这意味着将在成功调用建议的方法后（即仅在调用未引发异常的情况下）&lt;/ em&gt;进行缓存逐出操作。 */ boolean beforeInvocation() default false;&#125; 主要参数 描述 用法 value 同Cacheable @CacheEvict(“mysqlCache”) cacheNames 同Cacheable @CacheEvict(cacheNames=”mysqlCache”) key 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”#a1”) keyGenerator 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”customKeyGenerator”) cacheManager 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”customKeyGenerator”,cacheManager=”customCacheManager”) cacheResolver 同Cacheable 暂时未测试 condition 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”#a1”,condition=”#a1 == true”) unless 同Cacheable @CacheEvict(cacheNames=”mysqlCache”,key=”#a1”,unless=”#a1 == true”) allEntries 是否删除该缓存实例下的所有缓存的信息，默认值：false，当值为true时，则与属性key互斥 @CacheEvict(cacheNames=”mysqlCache”,allEntries = false beforeInvocation 在调用该方法之前是否移除缓存，默认为false，如果为true时，则移除缓存和方法是否执行异常无关 @CacheEvict(cacheNames=”mysqlCache”,key=”#a1”,unless=”#a1 == true”,beforeInvocation = true) 2.1.3.4、@Caching源码注释翻译： 1234567891011121314151617181920212223242526272829303132package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 多个（不同或相同类型的）缓存注释的组注释。 * * &lt;p&gt;此注释可用作&lt;em&gt;元注释&lt;/ em&gt;，以创建具有属性覆盖的自定义&lt;em&gt;组成的注释&lt;/ em&gt;。 * * @author Costin Leau * @author Chris Beams * @since 3.1 */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Caching &#123; Cacheable[] cacheable() default &#123;&#125;; CachePut[] put() default &#123;&#125;; CacheEvict[] evict() default &#123;&#125;;&#125; 2.1.3.5、@CacheConfig源码注释翻译: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package org.springframework.cache.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * &#123;@code @CacheConfig&#125;提供了一种在类级别共享与缓存相关的常见设置的机制。 * * &lt;p&gt;当给定类上存在此批注时，它将为该类中定义的任何缓存操作提供一组默认设置。 * * @author Stephane Nicoll * @author Sam Brannen * @since 4.1 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CacheConfig &#123; /** * 要为带注释的类中定义的缓存操作考虑的默认缓存的名称。 * &lt;p&gt;如果在操作级别未设置任何值，则将使用这些值而不是默认值。 * &lt;p&gt;可用于确定目标缓存（或多个缓存），与 * 限定符值或特定bean定义的bean名称。 */ String[] cacheNames() default &#123;&#125;; /** * 默认&#123;@link org.springframework.cache.interceptor.KeyGenerator&#125;的bean名 * &lt;p&gt;如果在操作级别未设置任何值，则使用该值代替默认值。 * &lt;p&gt;密钥生成器与自定义密钥互斥。 当这样的钥匙是 * 为操作定义的，此密钥生成器的值将被忽略。 */ String keyGenerator() default &quot;&quot;; /** * 自定义&#123;@link org.springframework.cache.CacheManager&#125;的bean名称，用于创建默认&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;（如果尚未设置）。 * &lt;p&gt;如果在操作级别未设置解析器和缓存管理器，并且未通过&#123;@link #cacheResolver&#125;设置缓存解析器，则使用该解析器而不是默认值。 @see org.springframework.cache.interceptor.SimpleCacheResolver */ String cacheManager() default &quot;&quot;; /** * 要使用的定制&#123;@link org.springframework.cache.interceptor.CacheResolver&#125;的bean名称。 * &lt;p&gt;如果在操作级别未设置解析器和缓存管理器，则使用该解析器而不是默认值。 */ String cacheResolver() default &quot;&quot;;&#125; 该注解只能使用在类上，为该类中的@Cacheable、@CachePut、@CacheEvict提供cacheNames、cacheManager、keyGenerator、cacheResolver默认的设置。不难发现这些值都是Spring 的bean的实例名称。 主要参数 描述 用法 cacheNames 缓存名称的bean的名称,默认值：“”，则以实际的设置为准 @CacheConfig(cacheNames=”mysqlCache”) cacheManager 缓存管理器的bean的名称,默认值：“”，则以实际的设置为准 @CacheConfig(cacheManager=”customCacheManager”) keyGenerator key生成器的bean的名称,默认值：“”，则以实际的设置为准 @CacheConfig(keyGenerator=”customKeyGnenrator”) cacheResolver 缓存实现的bean的名称,默认值：“”，则以实际的设置为准 @CacheConfig(cacheResolver=”customCacheResolver”) 三、Spring Cache的实现原理3.1、基本实现原理&emsp;&emsp;Spring的缓存实现，依赖于Spring AOP，通过获取上面讲述的五个注解的切点位置，来实现对应的功能。&emsp;&emsp;那么意味着如果要使用缓存或者缓存生效前提，所有的缓存方法调用实例都必须是Spring 代理的Bean。否则的话就无法使用。 3.2、核心实现类Spring Cache的核心类的依赖关系图： Spring Cache的执行逻辑： 3.3、Spring Cache 注解失效的场景在开发的过程中，可能会发现缓存没有生效，原因可能如下： 1、方法所在的Bean没有注入到Spring的容器2、方法是私有的或者是final修饰的3、方法的调用对象为非Spring的代理类，类似于this.method()方式调用 四、自定义Spring Cache在学习的过程中，做了一个简单的小demo拓展了一个Cache方式，尝试将缓存存储到Mysql的数据表中。 4.1、准备阶段 技术选型 版本 java 1.8.0_241 Spring boot 2.3.0.release Spring jpa 2.3.0.release 数据库 Mysql 5.x Spring boot test 2.3.0.release 实体类加强工具 lombok 4.2、创建缓存表的CRUD123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.yiyi.cache.cache.entity;import lombok.Data;import javax.persistence.*;import java.time.LocalDateTime;/** * @author wuxuan.chai * @date 2020/6/4 1:42 下午 */@Data@Entity(name = &quot;t_cache&quot;)public class CacheObject &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @Column(name = &quot;cache_key&quot;,nullable = false) private String cacheKey; @Column(name = &quot;cache_value&quot;,nullable = false) private String cacheValue; @Column(name = &quot;create_date&quot;,nullable = false) private LocalDateTime createDate;&#125;package com.yiyi.cache.cache.entity;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.transaction.annotation.Transactional;/** * @author wuxuan.chai * @date 2020/6/4 4:07 下午 */public interface CacheObjectMapper extends JpaRepository&lt;CacheObject,String&gt; &#123; CacheObject getByCacheKey(String cacheKey); @Modifying @Transactional void deleteCacheObjectByCacheKey(String cacheKey);&#125;package com.yiyi.cache.cache.entity;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.SneakyThrows;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;import java.time.LocalDateTime;/** * @author wuxuan.chai * @date 2020/6/4 4:08 下午 */@Servicepublic class CacheObjectService &#123; @Resource private CacheObjectMapper cacheObjectMapper; public String getValue(String key)&#123; CacheObject cacheObject = cacheObjectMapper.getByCacheKey(key); if (cacheObject == null)&#123; return null; &#125; return cacheObject.getCacheValue(); &#125; @SneakyThrows @Transactional(rollbackFor = Exception.class) public void putValue(String key, String value) &#123; CacheObject oldCacheObject = cacheObjectMapper.getByCacheKey(key); if (oldCacheObject != null)&#123; cacheObjectMapper.delete(oldCacheObject); &#125; CacheObject cacheObject = new CacheObject(); cacheObject.setCacheKey(key); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(value); cacheObject.setCacheValue(json); cacheObject.setCreateDate(LocalDateTime.now()); cacheObjectMapper.save(cacheObject); &#125; public void evict(String key) &#123; cacheObjectMapper.deleteCacheObjectByCacheKey(key); &#125; @Transactional public void clear() &#123; cacheObjectMapper.deleteAll(); &#125;&#125; 4.3、Spring Cache的拓展4.3.1、定义CacheManager12345678910111213141516171819202122232425262728293031323334353637package com.yiyi.cache.cache.manager;import org.springframework.cache.Cache;import org.springframework.cache.CacheManager;import java.util.Collection;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;/** * @author wuxuan.chai * @date 2020/6/4 3:52 下午 */public class CustomCacheManager implements CacheManager &#123; //定义存储Cache的存储器，所有拓展并且实例化的Cache对象都会存到这里面 private final static ConcurrentMap&lt;String,Cache&gt; cacheMap = new ConcurrentHashMap&lt;&gt;(); //通过名称，获取Cache实例化对象，我们定义Cacheable的注解用到的CacheNames属性的值，所标注的名称获取Cache实例就是这个方法提供的 @Override public Cache getCache(String name) &#123; return cacheMap.get(name); &#125; //获取所有的cache实例化对象的名称 @Override public Collection&lt;String&gt; getCacheNames() &#123; return cacheMap.keySet(); &#125; //创建Cache实例 public void createCache(Cache cache)&#123; cacheMap.put(cache.getName(),cache); &#125;&#125; 4.3.2、定义Cache1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.yiyi.cache.cache.manager;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializerProvider;import com.yiyi.cache.cache.entity.CacheObjectService;import com.yiyi.cache.cache.serializer.CustomSerializerImpl;import lombok.SneakyThrows;import org.springframework.beans.BeansException;import org.springframework.cache.Cache;import org.springframework.cache.support.SimpleValueWrapper;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import java.util.concurrent.Callable;/** * @author wuxuan.chai * @date 2020/6/4 4:02 下午 */@Componentpublic class MysqlCache implements Cache, ApplicationContextAware &#123; public final static String NAME = &quot;MYSQL&quot;; private ApplicationContext applicationContext; @Override public String getName() &#123; return NAME; &#125; @Override public Object getNativeCache() &#123; return this; &#125; @Override public ValueWrapper get(Object key) &#123; String value = applicationContext.getBean(CacheObjectService.class).getValue(key.toString()); return value != null ? new SimpleValueWrapper(fromStoreValue(value)) : null; &#125; @SneakyThrows @Override public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) &#123; String value = applicationContext.getBean(CacheObjectService.class).getValue(key.toString()); return (T) fromStoreValue(value); &#125; @SneakyThrows @Override public &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader) &#123; String value = applicationContext.getBean(CacheObjectService.class).getValue(key.toString()); return (T) fromStoreValue(value); &#125; @Override public void put(Object key, Object value) &#123; String cacheValue = toStoreValue(value); applicationContext.getBean(CacheObjectService.class).putValue(key.toString(), cacheValue); &#125; @Override public void evict(Object key) &#123; applicationContext.getBean(CacheObjectService.class).evict(key.toString()); &#125; @Override public void clear() &#123; applicationContext.getBean(CacheObjectService.class).clear(); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @SneakyThrows private String toStoreValue(Object value)&#123; CustomSerializerImpl customSerializer = new CustomSerializerImpl(); return customSerializer.serialize(value); &#125; @SneakyThrows private Object fromStoreValue(String value)&#123; CustomSerializerImpl customSerializer = new CustomSerializerImpl(); return customSerializer.deserialize(value); &#125;&#125; 4.3.3、配置Cache1234567891011121314151617181920212223242526272829303132package com.yiyi.cache.cache.config;import com.yiyi.cache.cache.manager.CustomCacheManager;import com.yiyi.cache.cache.manager.MysqlCache;import org.springframework.cache.CacheManager;import org.springframework.cache.concurrent.ConcurrentMapCache;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.annotation.Resource;/** * @author wuxuan.chai * @date 2020/6/4 3:40 下午 */@Configurationpublic class CacheConfig &#123; @Resource private MysqlCache mysqlCache; //定义了两个Cache：一个自己实现的MysqlCache（Mysql） 还有一个就是Spring Cache默认实现了的基于并发包ConcurrentMap实现的的ConcurrentMapCache (LOCAL) @Bean public CacheManager cacheManager()&#123; CustomCacheManager customCacheManager = new CustomCacheManager(); customCacheManager.createCache(mysqlCache); ConcurrentMapCache local = new ConcurrentMapCache(&quot;LOCAL&quot;); customCacheManager.createCache(local); return customCacheManager; &#125;&#125; 4.4.4、Cache的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.yiyi.cache.cache.service;import com.yiyi.cache.cache.entity.User;import com.yiyi.cache.cache.manager.MysqlCache;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.Cacheable;import org.springframework.cache.annotation.Caching;import org.springframework.stereotype.Service;/** * @author wuxuan.chai * @date 2020/6/4 2:46 下午 */@Servicepublic class CacheDemoService &#123; @Cacheable(cacheNames = MysqlCache.NAME, key = &quot;&#x27;CacheDemoService-get&#x27;+ args[0]&quot;) public String get(String name) &#123; return name; &#125; @Cacheable(cacheNames = MysqlCache.NAME, keyGenerator = &quot;customKeyGenerator&quot;) public User keyGenerator(String name, String value) &#123; User user = new User(); user.setUsername(name+value); return user; &#125; @Cacheable(cacheNames = MysqlCache.NAME, key = &quot;&#x27;CacheDemoService-getUser&#x27;+ args[0]&quot;) public User getUser(String name) &#123; User user = new User(); user.setUsername(name); return user; &#125; @Cacheable(cacheNames = &quot;LOCAL&quot;, key = &quot;&#x27;CacheDemoService-get&#x27;+ args[0]&quot;) public String getLocalCache(String name) &#123; return name; &#125; @Caching(evict = &#123; @CacheEvict(cacheNames = &#123;MysqlCache.NAME&#125;, key = &quot;&#x27;CacheDemoService-get&#x27;+ args[0]&quot;), @CacheEvict(cacheNames = MysqlCache.NAME, key = &quot;&#x27;CacheDemoService-getUser&#x27;+ args[0]&quot;) &#125;) public void clearCache(String name) &#123; &#125;&#125; 测试用例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.yiyi.cache.SpringCacheApplication;import com.yiyi.cache.cache.entity.User;import com.yiyi.cache.cache.service.CacheDemoService;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.annotation.Resource;/** * @author wuxuan.chai * @date 2020/6/4 2:49 下午 */@SpringBootTest(classes = &#123;SpringCacheApplication.class&#125;)public class CacheDemoServiceTest &#123; @Resource private CacheDemoService cacheDemoService; @Test public void testGet()&#123; String name = &quot;1231231&quot;; String s = cacheDemoService.get(name); System.out.println(s); System.out.println(cacheDemoService.get(&quot;1231&quot;).equals(&quot;1231&quot;)); &#125; @Test public void testGetUser()&#123; String name = &quot;1231231&quot;; User user = cacheDemoService.getUser(name); System.out.println(user.getUsername().equals(name)); &#125; @Test public void testGetLocalCache()&#123; String name = &quot;1231231&quot;; String s = cacheDemoService.getLocalCache(name); System.out.println(s); System.out.println(cacheDemoService.getLocalCache(&quot;1231&quot;).equals(&quot;1231&quot;)); &#125; @Test public void testClearCache()&#123; cacheDemoService.clearCache(&quot;1231231&quot;); &#125; @Test public void testKeyGenerator()&#123; User wuxuan = cacheDemoService.keyGenerator(&quot;wuxuan&quot;, &quot;123456&quot;); System.out.println(wuxuan); &#125;&#125; 五、总结&emsp;&emsp;通过阅读Spring Cache的源码后，感觉收获到了很多，首先从心理上认识到，源码也并没有那么的难。其次，Spring 能够受到广大Java开发人员的追捧也并非偶然，Spring的源码从思路上以及设计上还是非常的优秀的，从中能够学到很多。以后再接再厉，多多尝试Discover Why 而不 Ask Why。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://cha1yi.github.io/dist/tags/SpringCache/"}],"author":"wuxuan.chai"},{"title":"Mac的VM中设置虚拟机静态ip","slug":"Mac的VM中设置虚拟机静态ip","date":"2021-01-17T16:13:21.416Z","updated":"2021-01-18T02:22:42.868Z","comments":true,"path":"2021/01/18/Mac的VM中设置虚拟机静态ip/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Mac%E7%9A%84VM%E4%B8%AD%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%99%E6%80%81ip/","excerpt":"","text":"Mac的VM中设置虚拟机静态ip闲来无事，想学习下spark相关的知识，于是需要几台服务器，无奈囊中羞涩双十一都买不起一台服务器，只能借助2015款的mac pro帮助虚拟几台服务器来暂时用用。 准备过程FinalShell 一款国产的mac上可用的shell命令工具VMware Fusion mac上用来安装虚拟机的工具centos7 的最简版镜像 设置VMware Fusion第一步：修改vmware 配置网卡的配置文件只更改Vnet8 的网卡 1234567891011121314151617181920$ vim /Library/Preferences/VMware\\ Fusion/networkingVERSION=1,0answer VNET_1_DHCP yesanswer VNET_1_DHCP_CFG_HASH EC13F23285B5086AFF5BDFFA85E8DE0338C2AF74answer VNET_1_HOSTONLY_NETMASK 255.255.255.0answer VNET_1_HOSTONLY_SUBNET 172.16.208.0answer VNET_1_VIRTUAL_ADAPTER yes#关闭dhcpanswer VNET_8_DHCP noanswer VNET_8_DHCP_CFG_HASH 13FB4A1FC14575A20209A2C7C8C2E5EED98C6665# 子网掩码answer VNET_8_HOSTONLY_NETMASK 255.255.255.0#设置ip段answer VNET_8_HOSTONLY_SUBNET 192.168.100.0answer VNET_8_NAT yesanswer VNET_8_VIRTUAL_ADAPTER yes# vmnet8 的IPanswer VNET_8_VIRTUAL_ADAPTER_ADDR 192.168.100.1 第二步：设置网关1234567#配置nat.conf 这个文件vim /Library/Preferences/VMware\\ Fusion/vmnet8/nat.conf #设定nat网管和子网# NAT gateway addressip = 192.168.100.2netmask = 255.255.255.0 第三步： 重启vmnet8网卡1234567# 查看网卡状态$ sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --status # 关闭网卡$ sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --stop# 启动网卡$ sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --start ～～～～中间省去在vm中创建centos的虚拟机步骤～～～～ 第四步：设置centos网卡1、配置网卡1234567891011121314151617181920212223242526272829 $ vi /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=no# 设置静态的ip，而不是dhcp方式BOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=74ad3dd0-742d-422b-b165-6f0d0b6e2f6dDEVICE=ens33# 设置网卡开机启动ONBOOT=yes# 设置当前centos的ip地址IPADDR=192.168.100.15# 设置网关GATEWAY=192.168.100.2# 设置子网掩码NETMASK=255.255.255.0#设置dnsDNS1=119.29.29.29DNS2=182.254.116.116 2、重启centos网卡123456#重启网卡systemctl restart network # 查看网卡ip addr 2、测试12345678910111213141516171819$ ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:dd:bc:55 brd ff:ff:ff:ff:ff:ff inet 192.168.100.15/24 brd 192.168.100.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::a3c4:b923:6d37:e7aa/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::3427:d5be:210e:dce2/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::3f6a:22ae:8bdd:e0ac/64 scope link noprefixroute valid_lft forever preferred_lft forever 测试发现ens33的ip地址已经变成了我们设置的ip了. 测试访问外网 1234567891011$ ping www.baidu.comPING www.a.shifen.com (180.101.49.12) 56(84) bytes of data.64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq=1 ttl=128 time=17.9 ms64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq=2 ttl=128 time=117 ms64 bytes from 180.101.49.12 (180.101.49.12): icmp_seq=4 ttl=128 time=26.7 ms^C--- www.a.shifen.com ping statistics ---4 packets transmitted, 3 received, 25% packet loss, time 3004msrtt min/avg/max/mdev = 17.996/54.184/117.813/45.134 ms 大工告成，开始happy！！！","categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://cha1yi.github.io/dist/tags/CentOS/"},{"name":"VM","slug":"VM","permalink":"https://cha1yi.github.io/dist/tags/VM/"}],"author":"wuxuan.chai"},{"title":"Apache SkyWalking 单机版测试","slug":"Apache SkyWalking 单机版测试","date":"2021-01-17T16:11:29.586Z","updated":"2021-01-18T02:21:54.194Z","comments":true,"path":"2021/01/18/Apache SkyWalking 单机版测试/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/Apache%20SkyWalking%20%E5%8D%95%E6%9C%BA%E7%89%88%E6%B5%8B%E8%AF%95/","excerpt":"","text":"Apache SkyWalking 单机版测试一、部署SkyWalking学习之前，最好先浏览一下SkyWalking的设计原理：分布式追踪 &amp; APM 系统 SkyWalking 源码分析 —— Collector 存储 Trace 数据 1、下载SkyWalkingSkyWalking官方下载地址 2、解压tar.gz得到类似的目录： 3、启动SkyWalkingSkyWalking启动分两步进行：webApp、OapServer 1234567891011121314localhost:bin wuxuan.chai$ pwd/Users/wuxuan.chai/Documents/application/skywalking/apache-skywalking-apm-bin-es7/binlocalhost:bin wuxuan.chai$ ls -l-rwxr-xr-x 1 wuxuan.chai staff 1352 12 24 14:10 oapService.bat-rwxr-xr-x 1 wuxuan.chai staff 1599 12 24 14:10 oapService.sh-rwxr-xr-x 1 wuxuan.chai staff 1364 12 24 14:10 oapServiceInit.bat-rwxr-xr-x 1 wuxuan.chai staff 1597 12 24 14:10 oapServiceInit.sh-rwxr-xr-x 1 wuxuan.chai staff 1367 12 24 14:10 oapServiceNoInit.bat-rwxr-xr-x 1 wuxuan.chai staff 1616 12 24 14:10 oapServiceNoInit.sh-rwxr-xr-x 1 wuxuan.chai staff 941 12 24 14:10 startup.bat-rwxr-xr-x 1 wuxuan.chai staff 934 12 24 14:10 startup.sh-rwxr-xr-x 1 wuxuan.chai staff 1426 12 24 14:10 webappService.bat-rwxr-xr-x 1 wuxuan.chai staff 1630 12 24 14:10 webappService.shlocalhost:bin wuxuan.chai$ bin目录里面包含了三个部分：oap服务、oap服务初始化、webappService webappService服务的作用：提供SkyWalking的web服务 oap服务初始化：初始化oap服务所需要的环境初始化，例如：DataStorage的初始化,读取配置中心配置等 oap服务：相当于监控数据的收集（collecter）和持久化 如果配置完成，可以直接执行 sh startup.sh,启动整个项目 4、SkyWalking相关的配置4.1、oap收集数据存储位置配置12345# 打开配置文件~ vim ./config/application.yml# 查看storage配置项的支持，SkyWalking支持将数据落地到：elasticsearch、elasticsearch7、h2# 根据实际需求设置响应的配置信息 4.2、设置配置中心SkyWalking支持的配置中心有apollo、nacos、zookeeper、etcd、consul 123# 打开配置文件~ vim ./config/application.yml# 根据实际需求设置响应的配置信息 4.3、服务端口的设置1234# 打开配置文件~ vim ./webapp/webapp.yml# 修改web端口，server.port=9090 默认为8080# cellector服务的调用地址 修改listOfServers，多个服务用‘,’隔开 4.4、Agent的配置1234567# 打开配置文件～ vim ./agent/config/agent.config# oapservice的后端服务，用于应用订阅（默认值127.0.0.1:11800）collector.backend_service=xxx# 是否追踪sql的参数plugin.mysql.trace_sql_parameters=true/false 配置完成这些基本配置之后，就可以直接执行 sh startup.sh,启动整个项目了 5、将应用加入到SkyWalking的监控代理中5.1、springboot项目springboot应用：启动springboot的demo应用， 1234567891011#!/usr/bin/env sh# SkyWalking Agent 配置export SW_AGENT_NAME=demo-application # 配置 Agent 名字。一般来说，我们直接使用 Spring Boot 项目的 `spring.application.name` 。export SW_AGENT_COLLECTOR_BACKEND_SERVICES=127.0.0.1:11800 # 配置 Collector 地址。export SW_AGENT_SPAN_LIMIT=2000 # 配置链路的最大 Span 数量。一般情况下，不需要配置，默认为 300 。主要考虑，有些新上 SkyWalking Agent 的项目，代码可能比较糟糕。export JAVA_AGENT=-javaagent:/Users/wuxuan.chai/Documents/application/skywalking/apache-skywalking-apm-bin-es7/agent/skywalking-agent.jar # SkyWalking Agent jar 地址。# Jar 启动java -jar $JAVA_AGENT -jar lab-39-demo-2.2.2.RELEASE.jar 执行启动脚本，即可在SkyWalking的拓扑图中看到对应的服务监控信息 5.2、传统的ssm项目，使用tomcat/jetty等容器发布的工程需要在启动的参数中加入 1234-DSW_AGENT_NAME=xxx-DSW_AGENT_COLLECTOR_BACKEND_SERVICES=127.0.0.1:11800-DSW_AGENT_SPAN_LIMIT=2000-javaagent:/Users/wuxuan.chai/Documents/application/skywalking/apache-skywalking-apm-bin-es7/agent/skywalking-agent.jar 启动tomcat/jetty，即可。 效果如图：","categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"SkyWalking","slug":"SkyWalking","permalink":"https://cha1yi.github.io/dist/tags/SkyWalking/"},{"name":"系统监控","slug":"系统监控","permalink":"https://cha1yi.github.io/dist/tags/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"}],"author":"wuxuan.chai"},{"title":"Maven常用命令","slug":"maven相关命令","date":"2021-01-17T16:10:41.139Z","updated":"2021-01-18T02:22:42.870Z","comments":true,"path":"2021/01/18/maven相关命令/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/maven%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","excerpt":"","text":"maven常用命令一、上传包到maven中央仓库命令： 1mvn deploy:deploy-file -DgroupId=com.aliyun -DartifactId=taobao-sdk-java-auto -Dversion=202011-release -Dpackaging=jar -Dfile=/Users/wuxuan.chai/Downloads/dingtalk-sdk-java/taobao-sdk-java-auto_1479188381469-20201126.jar -Durl=http://ci.yunat.com:8091/nexus/content/repositories/thirdparty/ -DrepositoryId=nexus 参数解释:deploy:deploy-file：发布，发布文件到远程，和install的区别在于，install的意思是将jar安装到本地maven仓库groupId、artifactId、version：表示maven的坐标file：发布的文件的本地地址url：远程仓库的地址repositoryId：本地maven配置文件的仓库id，配置这个的话他会去找配置文件中的对应仓库的访问鉴权所需的账户和密码","categories":[{"name":"开发总结","slug":"开发总结","permalink":"https://cha1yi.github.io/dist/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://cha1yi.github.io/dist/tags/maven/"}],"author":"wuxuan.chai"},{"title":"项目版本管理的最佳实践","slug":"项目版本管理的最佳实践","date":"2021-01-17T16:06:38.488Z","updated":"2021-01-18T02:23:25.567Z","comments":true,"path":"2021/01/18/项目版本管理的最佳实践/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/18/%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"项目版本管理的最佳实践一、Git设置1、添加公钥 1234567891011121314151617打开 git bash (mac 下直接打开终端即可)#: ssh-keygen -t rsa -C &quot;邮箱&quot;#: cat ~/.ssh/id_rsa.pub会生成：以ssh-rsa 开头的字符串，复制，贴到git公钥管理里面测试是否可以通过公钥，免密拉取上传代码#: ssh -T git@gitee.com （我这里用的gitee，对应的域名请自行切换）成功：Hi 柴梧炫 (DeployKey)! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access.Note: Perhaps the current use is DeployKey.Note: DeployKey only supports pull/fetch operations失败：The authenticity of host &#x27;gitlab.com (172.65.251.78)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:HbW3g8zUjNSksFbqTiUWPWg2Bq1x8xdGUrliXFzSnUw. 二、项目版本在web开发的过程中，maven 除了作为项目的依赖管理之外，还处理着项目的版本控制 1、maven 的多项目的标准结构1.1、如何组织项目123456789101112131415161718[MavenMultiProject] ├── module-1 │ ├── pom.xml │ └── src ├── module-2 │ ├── pom.xml │ └── src ├── module-3 │ ├── pom.xml │ ├── module-3-1 │ ├── pom.xml │ └── src │ ├── module-3-2 │ ├── pom.xml │ └── src ├── pom.xml ├── README.en.md ├── README.md 其中子模块也可以有其子模块 1.2、POM文件中的内容1.2.1、parent pom.xml父模块的pom文件一般存放公用的信息，以及定义标准，打包的格式：pom 除了上述的信息，一般不要引入其他的元素，因为一旦引入，子模块就会继承这些依赖，导致子模块的依赖被污染 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!-- 属性定义--&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; ....&lt;/properties&gt;&lt;!-- 仓库的定义 --&gt;&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;local nexus&lt;/id&gt; &lt;name&gt;local nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;local nexus&lt;/id&gt; &lt;name&gt;local nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt;&lt;!-- 软件配置管理（项目git地址信息）如果git需要权限，则需要加入公钥，免密访问--&gt;&lt;scm&gt; &lt;connection&gt; scm:git:https://gitee.com/wuxuanchai_admin/m-v.git &lt;/connection&gt; &lt;developerConnection&gt; scm:git:https://gitee.com/wuxuanchai_admin/m-v.git &lt;/developerConnection&gt; &lt;url&gt; https://gitee.com/liang.liang/version-mangement-best-practices &lt;/url&gt; &lt;tag&gt;HEAD&lt;/tag&gt;&lt;/scm&gt;&lt;!--开发者--&gt;&lt;developers&gt; &lt;developer&gt; &lt;name&gt;wuxuan.chai&lt;/name&gt; &lt;email&gt;wuxuan.chai@gmail.com&lt;/email&gt; &lt;organizationUrl&gt;www.shuyun.com&lt;/organizationUrl&gt; &lt;/developer&gt;&lt;/developers&gt;&lt;!--模块定义--&gt;&lt;moudles&gt; &lt;moudle&gt;../moudle1&lt;/moudle&gt;&lt;/moudles&gt;&lt;build&gt; &lt;!--插件定义--&gt; &lt;pluginManagement&gt; &lt;/pluginManagement&gt;&lt;/build&gt;&lt;!--依赖定义--&gt;&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt; pom文件中可被继承的元素： 可继承的POM元素如下： groupId：项目组ID，项目坐标的核心元素 version：项目版本，项目坐标的核心因素 description：项目的描述信息 organization：项目的组织信息 inceptionYear：项目的创始年份 url：项目的URL地址 developers：项目的开发者信息 contributors：项目的贡献者信息 distributionManagement：项目的部署配置 issueManagement：项目的缺陷跟踪系统信息 ciManagement：项目的持续集成系统信息 scm：项目的版本控制系统西溪 malilingLists：项目的邮件列表信息 properties：自定义的Maven属性 dependencies：项目的依赖配置 dependencyManagement：项目的依赖管理配置 repositories：项目的仓库配置 build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等 reporting：包括项目的报告输出目录配置、报告插件配置等 1.2.2、子模块子模块是具体依赖的配置，一般以jar包的格式提供服务（使用springboot后，war包格式会被打成jar） 在子模块中，所有的version都不应该存在，要放在parent.pom 中进行统一管理 模块本身：version 继承父模块的versoin 所有依赖version，在父模块的dependencyManagement 元素中进行定义 12345678910111213141516171819&lt;!-- 父模块的坐标--&gt;&lt;parent&gt; &lt;/parent&gt;&lt;!-- 当前模块的坐标，不需要写版本信息，会继承父模块的版本号--&gt;&lt;artifactId&gt;com.example&lt;/artifactId&gt;&lt;name&gt;demo&lt;/name&gt;&lt;!-- 模块描述--&gt;&lt;description&gt;xxx&lt;/description&gt;&lt;!-- 模块依赖列表--&gt;&lt;dependencies&gt;&lt;/dependencies&gt;&lt;!-- 模块的构建所需要的插件--&gt;&lt;build&gt;&lt;/build&gt; 1.3、语义化的版本号（Semantic Versioning）1.3.1、版本号的格式版本号的格式： 主版本号.次版本号.修订号 版本号的递增的规则： 1、主版本号：当你做了不兼容的API修改 2、次版本号：当你做了向下兼容的功能性新增 3、修订号：当你做了向下兼容的问题修正 先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 也就是说可以支持这种版本号： 4.7.5.202005 4 主版本号 7 次版本号 5 修订号 202005 编译元数据-编译日期 其他的语义描述： Alpha：内测版 Beta：公测版 Gamma：比较成熟的测试版，与即将发行的正式版相差无几 RC：是 Release Candidate 的缩写，意思是发布倒计时，候选版本 Stable：稳定版 1.4、版本性质： Snapshot 与Release1.4.1、概念Snapshot：快照，他是一个不稳定的版本，处于开发中的，经常变化的版本 Release：发行版，功能稳定的版本，将停止代码的更新，用于发行到生产环境 1.4.2、理想的流程日常的开发基于Snapshot的版本进行开发，snapshot版本会有一些特性 执行 mvn complie 时会去仓库中尝试拉最新打包，因为他可以被多次构建，使用时必须保证最新 可以被重复构建 版本发布在发布版本的时候，我们需要做以下的几件事： 1、创建Tag分支，tag/v版本号（例如：tag/v0.0.1） 2、在仓库中构建发布包（release 的jar） 3、创建新的开发分支，升级本地pom文件版本，根据实际的需求提升版本号 如果hotfix发布，则：x.y.z -&gt; x.y.z+1 例如：4.7.5 &gt; 4.7.6 次版本发布， 则： x.y.z -&gt; x.y+1.0 例如：4.7.5 &gt; 4.8.0 大版本更新，则：x.y.z -&gt; x+1.0.0 例如：4.7.5 &gt; 5.0.0 4、非hotfix版本发布，还需要创建hotfix分支，用于以后修复 现有的项目如何做？插件管理：maven-release-plugin 插件地址：http://maven.apache.org/maven-release/maven-release-plugin/ parent pom配置文件配置： 1234567891011121314151617181920212223242526272829&lt;scm&gt; &lt;!-- git项目地址可以用SSH 也可以用 HTTPS的--&gt; &lt;connection&gt;scm:git:https://gitee.com/wuxuanchai_admin/m-v.git&lt;/connection&gt; &lt;!-- #git项目地址可以用SSH 也可以用 HTTPS的--&gt; &lt;developerConnection&gt;scm:git:https://gitee.com/wuxuanchai_admin/m-v.git&lt;/developerConnection&gt; &lt;!-- #git项目浏览器里的地址--&gt; &lt;url&gt;https://gitee.com/liang.liang/version-mangement-best-practices&lt;/url&gt; &lt;tag&gt;HEAD&lt;/tag&gt;&lt;/scm&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- tag分支的名称，project.version只包含版本，不包含SNAPSHOT后缀 --&gt; &lt;tagNameFormat&gt;v@&#123;project.version&#125;&lt;/tagNameFormat&gt; &lt;!-- 升级子模块 --&gt; &lt;autoVersionSubmodules&gt;true&lt;/autoVersionSubmodules&gt; &lt;!-- 跳过单元测试 --&gt; &lt;arguments&gt;-DskipTests&lt;/arguments&gt; &lt;!-- 执行目标，此句可省 --&gt; &lt;goals&gt;-f pom.xml deploy&lt;/goals&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如何使用？？1) release:branch（创建分支 ）创建的分支是用于hotfix修复的基础分支，在第一次创建次要版本是，要一并创建，以后的修改都基于此分支，后续如果有需要的hotfix来修复问题，则基于此分支创建一个新的分支hotfix-xxx，然后提交代码后，将release一个hotfix的版本：x.y.z+1(z表示当前的修订号) 命令： 1mvn release:branch -DbranchName=0.2.x -DupdateBranchVersions=true -DupdateWorkingCopyVersions=false 命令含义： -DbranchName=0.2.x：创建一个叫 0.2.x 的分支 -DupdateBranchVersions=true ：分支会升级版本号，如果当前的版本号为0.0.1-snapshot，则新的分支版本号为： 0.0.2-snapshot DupdateWorkingCopyVersions=false 当前工作空间的pom文件不做更改，方便后面的release操作 2) release:prepare(预处理，升级pom-version)预处理阶段，release插件会： 执行一次打包过程 在git仓库里面创建好Tag分支 升级pom文件版本，并提交到本地仓库（此处不会更改远程仓库的分支） 1mvn release:prepare 在默认的情况下，他是一个交互式的命令，有如下问题需要确认： 1234567What is the release version for &quot;mvc-test&quot;? (com.fruits.mvc:mvc-test) 0.1.15: :What is SCM release tag or label for &quot;mvc-test&quot;? (com.fruits.mvc:mvc-test) v0.1.15: :What is the new development version for &quot;mvc-test&quot;? (com.fruits.mvc:mvc-test) 0.1.16-SNAPSHOT: :&#x2F;&#x2F;要发布的版本是哪一个？默认当前版本&#x2F;&#x2F;要打的tag叫什么？现在的样子 &#x2F;&#x2F;创建一个新的开发版本吗？默认当前版本+1 修订（此处我们可以手工改成 子版本号更新） 执行了 release:prepare命令后，在git仓库中，我们可以看到一个叫：v0.1.15的tag被创建，这操作是可以回滚的，插件在项目里面创建了一个，pom.xml.releaseBackup的文件，用于回滚pom.xml，同时还会生成：release.properties 里面会记录release版本的属性 3) release:rollback(回滚)Release:prepare 阶段都是进行了本地的提交，因此可以进行回滚，但tag分支必须手工删除，插件不能帮你删除已经创建好的本地Tag 除此之外，可以还行发布预览： 1mvn release:prepare -DdryRun=true 干跑会生成预览文件： pom.xml.nextpom.xml.releaseBackuppom.xml.tagrelease.properties 但是不会提交。 4) release:perform (执行)执行命令，会在release仓库里面构建发布包 可能碰到的问题 release:rollback不会回滚git的tag，需要手动删除tag maven配置的优先级(idea下) pom.xml&gt;.m2/setting.xml&gt;setting.xml pom.xml 发生改变，无法执行release:prepare 私服的设置和maven的配置文件如果配置不正确，无法执行命令 效果私服中release的jar： 私服中的snapshot的jar： git中的tag：发布release后创建的tag分支","categories":[{"name":"开发总结","slug":"开发总结","permalink":"https://cha1yi.github.io/dist/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://cha1yi.github.io/dist/tags/maven/"}],"author":"wuxuan.chai"},{"title":"Arthas诊断神器","slug":"Arthas诊断神器","date":"2021-01-17T15:59:56.357Z","updated":"2021-01-18T02:21:54.192Z","comments":true,"path":"2021/01/17/Arthas诊断神器/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/Arthas%E8%AF%8A%E6%96%AD%E7%A5%9E%E5%99%A8/","excerpt":"","text":"一、快速入门1.1、Arthas简介Arthas 是Alibaba开源的Java诊断工具。可以安装在系统所在服务器，也可以远程诊断其他服务器的服务。可以帮助开发人员或者运维人员查找问题，分析性能，bug追踪。 1.2、Arthas的快速入门下载地址： 1wget https://alibaba.github.io/arthas/arthas-boot.jar 应用程序：可以自己启一个java服务 1.3、启动Arthas1java -jar arthas-boot.jar 执行arthas程序的用户要和应用程序的执行用户为相同的权限。比如：应用程序使用admin用户来执行，那么arthas的启动：sudo su admin &amp;&amp; java -jar arthas-boot.jar 或者 sudo -u admin -EH java -jar arthas-boot.jarjava -jar arthas-boot.jar -h 打印更多的信息 开始启动： 123456789101112localhost:Downloads wuxuan.chai$ java -jar arthas-boot.jar [INFO] arthas-boot version: 3.3.3[INFO] Process 84742 already using port 3658[INFO] Process 84742 already using port 8563[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.* [1]: 84742 com.yiyi.Application [2]: 84898 arthas-boot.jar [3]: 1572 kafka.Kafka [4]: 981 org.apache.zookeeper.server.quorum.QuorumPeerMain [5]: 84726 org.codehaus.plexus.classworlds.launcher.Launcher [6]: 83691 [7]: 84010 org.jetbrains.idea.maven.server.RemoteMavenServer36 可以看到我们通过wuxuan.chai用户启动了7个java进程（pid）： 1234567* [1]: 84742 com.yiyi.Application [2]: 84898 arthas-boot.jar [3]: 1572 kafka.Kafka [4]: 981 org.apache.zookeeper.server.quorum.QuorumPeerMain [5]: 84726 org.codehaus.plexus.classworlds.launcher.Launcher [6]: 83691 [7]: 84010 org.jetbrains.idea.maven.server.RemoteMavenServer36 选择应用的java进程：这里我们选择我们的测试app，1输入1，再回车/enter，arthas会attach到目标进程： 123456789101112131415161718192021222324252627282930313233localhost:Downloads wuxuan.chai$ java -jar arthas-boot.jar [INFO] arthas-boot version: 3.3.3[INFO] Process 84742 already using port 3658[INFO] Process 84742 already using port 8563[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.* [1]: 84742 com.yiyi.Application [2]: 84898 arthas-boot.jar [3]: 1572 kafka.Kafka [4]: 981 org.apache.zookeeper.server.quorum.QuorumPeerMain [5]: 84726 org.codehaus.plexus.classworlds.launcher.Launcher [6]: 83691 [7]: 84010 org.jetbrains.idea.maven.server.RemoteMavenServer361[INFO] arthas home: /Users/wuxuan.chai/.arthas/lib/3.3.6/arthas[INFO] The target process already listen port 3658, skip attach.[INFO] arthas-client connect 127.0.0.1 3658 ,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \\ | .--. &#x27;&#x27;--. .--&#x27;| &#x27;--&#x27; | / O \\ &#x27; .-&#x27; | .-. || &#x27;--&#x27;.&#x27; | | | .--. || .-. |`. `-. | | | || |\\ \\ | | | | | || | | |.-&#x27; | `--&#x27; `--&#x27;`--&#x27; &#x27;--&#x27; `--&#x27; `--&#x27; `--&#x27;`--&#x27; `--&#x27;`-----&#x27; wiki https://alibaba.github.io/arthas tutorials https://alibaba.github.io/arthas/arthas-tutorials version 3.3.6 pid 84742 time 2020-07-06 10:46:47 [arthas@84742]$ 1.4、Arthas的基本操作Arthas的入门基本操作：Dashboard/thread/jad/watch，来查看一些最基本的指标信息，比如，资源占用，线程，类信息，方法执行信息。 1.4.1、查看Dashboard123456789101112131415161718192021222324252627282930313233[arthas@84742]$ dashboard ID NAME GROUP PRIORITY STATE %CPU TIME INTERRUPTED DAEMON 149 Timer-for-arthas-dashboard-3bf90e35- system 10 RUNNABLE 51 0:0 false true 113 Catalina-utility-1 main 1 TIMED_WAITI 14 0:0 false false 116 http-nio-7070-BlockPoller main 5 RUNNABLE 14 0:0 false true 127 http-nio-7070-ClientPoller main 5 RUNNABLE 13 0:0 false true 114 Catalina-utility-2 main 1 WAITING 5 0:0 false false 131 Attach Listener system 9 RUNNABLE 0 0:0 false true 130 DestroyJavaVM main 5 RUNNABLE 0 0:1 false false 3 Finalizer system 8 WAITING 0 0:0 false true 2 Reference Handler system 10 WAITING 0 0:0 false true 4 Signal Dispatcher system 9 RUNNABLE 0 0:0 false true 136 arthas-shell-server system 9 TIMED_WAITI 0 0:0 false true 137 arthas-shell-server system 9 TIMED_WAITI 0 0:0 false true 133 arthas-timer system 9 WAITING 0 0:0 false true 141 as-command-execute-daemon system 10 TIMED_WAITI 0 0:0 false true 115 container-0 main 5 TIMED_WAITI 0 0:0 false false Memory used total max usage GC heap 169M 370M 3641M 4.66% gc.ps_scavenge.count 4 ps_eden_space 140M 183M 1344M 10.46% gc.ps_scavenge.time(ms) 37 ps_survivor_space 0K 10752K 10752K 0.00% gc.ps_marksweep.count 2 ps_old_gen 29M 176M 2731M 1.07% gc.ps_marksweep.time(ms) 118 nonheap 53M 57M -1 92.98% code_cache 5M 7M 240M 2.17% metaspace 42M 44M -1 95.78% Runtime os.name Mac OS X os.version 10.14.6 java.version 1.8.0_241 java.home /Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre systemload.average 3.25 processors 8 uptime 上半部分是程序的线程信息，中间是内存使用情况，这里可以查看gc的次数，下面是当前程序运行的环境信息 1.4.2、thread命令查看进程1234567[arthas@84742]$ thread 115 &quot;container-0&quot; Id=115 TIMED_WAITING at java.lang.Thread.sleep(Native Method) at org.apache.catalina.core.StandardServer.await(StandardServer.java:570) at org.springframework.boot.web.embedded.tomcat.TomcatWebServer$1.run(TomcatWebServer.java:197)Affect(row-cnt:0) cost in 1 ms. 查看线程的具体信息，调用对象，状态等。。。 1.4.3、jad反编译class类通过jad反编译springboot的启动类： 12345678910111213141516171819202122232425262728[arthas@84742]$ jad com.yiyi.ApplicationClassLoader: +-sun.misc.Launcher$AppClassLoader@4e25154f +-sun.misc.Launcher$ExtClassLoader@2ef1e4fa Location: /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/target/classes/ /* * Decompiled with CFR. */package com.yiyi;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@SpringBootApplication@ComponentScan(value=&#123;&quot;com.yiyi&quot;&#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;Affect(row-cnt:2) cost in 181 ms.[arthas@84742]$ 1.4.4、watch查看函数的返回值通过watch命令查看方法的返回值，查看获取微信的accessToken的方法返回值： 1234[arthas@84742]$ watch com.yiyi.api.WeixinSupportApi getAccessToken Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 38 ms, listenerId: 3 执行命令后，Arthas会监听该方法的执行，每次调用，都会将执行结果打印出来,例如： 12345ts=2020-07-06 11:26:17; [cost=3.13107ms] result=@ArrayList[ @Object[][isEmpty=false;size=2], @WeixinSupportApi[com.yiyi.api.WeixinSupportApi@14cb7037], @String[i9c7LCIqY8cJuneYN9C9q4kN-FZoo7YZFVxEpgT3ugMmeX1KJ5HuVgSLK5IkJW7JF_adbkmjGrGdu9aw9XFhrMBLBMC9eFm82ICpst1-UVGujAvdUMcPRkUNcgb7I7MmxHk2ZVIpZzLKxf-3zw1-oE-wfhETKjRrjRhoP7z7g9UD4OS-cctNJBUJk8XfcE2cW_S2GUuj-tm2vyvVNK9oDQ],] 二、进阶使用2.1、基础命令2.1.1、所有命令的集合 NAME DESCRIPTION help 展示Arthas帮助 keymap 展示所有指定的连接的可用的快捷键 sc 搜索所有被jvm加载类 sm 搜索所有被jvm加载的类的方法 classloader 展示类加载器的信息 jad 类反编译 getstatic 展示一个类的静态的属性字段 monitor 监控方法执行的数据，例如：合计/成功/失败的数值，实时平均值失败比率等 stack 展示指定类和方法的调用栈信息 thread 展示线程信息和调用栈 trace 指定方法调用栈的执行时间 watch 展示指定方法的调用过程中，输入/输出的参数，结果返回值，异常抛出等 tt 时间隧道 jvm 展示目标jvm的信息 perfcounter 展示性能计数器的信息 ognl 执行ognl表达式 mc 内存编译器，将java文件在内存中编译成字节码和内存中的类文件 redefine 重新定义类，参考Instrumentation#redefineClasses(ClassDefinition…) dashboard 预览目标jvm的线程，gc，环境变量，tomcat信息 dump 从jvm中转存类的字节码 heapdump 堆转存 options 查看和更改各种Arthas选项 cls 清理屏幕 reset 重置所有的增强类 version 展示Arthas版本 session 展示当前会话的信息 sysprop 展示，修改系统的配置 sysenv 展示系统环境变量 vmoption 展示修改vm诊断选项 logger 打印日志信息，修改日志级别 history 展示历史命令 cat 连接并打印文件内容，类似linux的cat命令 echo 将参数写入标准输出 pwd 返回工作目录名称 mbean 显示mbean信息 grep 用于管道的grep命令 tee 管道的tee命令 profiler 异步分析工具https://github.com/jvm-profiling-tools/async-profiler stop 停止/关闭Arthas服务器并退出控制台 2.1.2、redefine命令，替换指定源class文件redefine后的原来的类不能恢复，redefine也有可能失败（比如新增了field），reset命令对redefine无效，如果想重置，需要redefine原始的字节码。不允许新增加field/method。正在执行的函数，没有退出不能生效。 示例，替换接口的返回值： 123456789@RestController@RequestMapping(value = &quot;/weixin&quot;, produces = MediaType.APPLICATION_JSON_VALUE)@Slf4jpublic class WeixinSupportApi &#123; @GetMapping(&quot;/test/&quot;) public String test() &#123; return &quot;这是正牌的接口结果&quot;; &#125;&#125; 请求接口会返回一个字符串：“这是正牌的接口结果”。接下来通过arthas的redifine命令替换成接口返回成一个：“hello” 1234567891011121314@RestController@RequestMapping(value = &quot;/weixin&quot;, produces = MediaType.APPLICATION_JSON_VALUE)@Slf4jpublic class WeixinSupportApi &#123; @GetMapping(&quot;/test/&quot;) public String test() &#123; return &quot;hello&quot;; &#125;&#125;``` 方式一、 将上述的java文件编译成class文件,上传到服务器，使用redefine命令,开始替换：```shellredefine weixin/WeixinSupportApi.class 方式二、 12345678910111213//通过jad将class 文件编译成java文件jad --source-only com.yiyi.api.WeixinSupportApi &gt; weixin/src/main/java/com/yiyi/api/WeixinSupportApi.java//通过vim对文件进行编辑，实现我们想要的一个逻辑vim weixin/src/main/java/com/yiyi/api/WeixinSupportApi.java//通过mc 内存编译，将上面的java文件编译成class 代码mc weixin/src/main/java/com/yiyi/api/WeixinSupportApi.java -d weixin-&gt;输出编译后的class 文件地址：Memory compiler output:/Users/wuxuan.chai/Documents/project/springboot-learn/weixin/com/yiyi/api/WeixinSupportApi.classAffect(row-cnt:1) cost in 1467 ms.//redefine 替换内存中的class文件为刚才编译的class 文件redefine /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/com/yiyi/api/WeixinSupportApi.class即可实现对源class 的编辑，并且进行热部署。。 2.1.3、headdump命令dump java heap，类似jmap命令的heap dump功能 123456//dump到指定的文件heapdump ./dump.hprof//只dump live对象heapdump --live ./dump.hprof//dump到临时文件heapdump 2.1.4、classloader的命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//按类加载类型查看统计信息[arthas@89977]$ classloader name numberOfInstances loadedCountTotal sun.misc.Launcher$AppClassLoader 1 4440 BootstrapClassLoader 1 2932 com.taobao.arthas.agent.ArthasClassloader 1 2095 lombok.launch.ShadowClassLoader 1 242 sun.reflect.DelegatingClassLoader 77 77 sun.misc.Launcher$ExtClassLoader 1 4 javax.management.remote.rmi.NoCallStackClassLoader 2 2 sun.reflect.misc.MethodUtil 1 1 Affect(row-cnt:8) cost in 5 ms.//按类加载实例查看统计信息[arthas@89977]$ classloader -l name loadedCount hash parent BootstrapClassLoader 2932 null null com.taobao.arthas.agent.ArthasClassloader@3c708a1d 2095 3c708a1d sun.misc.Launcher$ExtClassLoader@770c2e6b javax.management.remote.rmi.NoCallStackClassLoader@1060b431 1 1060b431 null javax.management.remote.rmi.NoCallStackClassLoader@63440df3 1 63440df3 null lombok.launch.ShadowClassLoader@1756d9eb 242 1756d9eb sun.misc.Launcher$AppClassLoader@18b4aac2 sun.misc.Launcher$AppClassLoader@18b4aac2 4440 18b4aac2 sun.misc.Launcher$ExtClassLoader@770c2e6b sun.misc.Launcher$ExtClassLoader@770c2e6b 4 770c2e6b null sun.reflect.misc.MethodUtil@2c109df9 1 2c109df9 sun.misc.Launcher$AppClassLoader@18b4aac2 Affect(row-cnt:8) cost in 5 ms.// 查看classloader的继承树[arthas@89977]$ classloader -t+-BootstrapClassLoader +-javax.management.remote.rmi.NoCallStackClassLoader@1060b431 +-javax.management.remote.rmi.NoCallStackClassLoader@63440df3 +-sun.misc.Launcher$ExtClassLoader@770c2e6b +-com.taobao.arthas.agent.ArthasClassloader@3c708a1d +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-lombok.launch.ShadowClassLoader@1756d9eb +-sun.reflect.misc.MethodUtil@2c109df9 Affect(row-cnt:8) cost in 5 ms.//查看URLClassloader的实际urls[arthas@89977]$ classloader -c 770c2e6bfile:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/sunec.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/nashorn.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/cldrdata.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/jfxrt.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/dnsns.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/localedata.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk16-143.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk15-135.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/jaccess.jar file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/zipfs.jar file:/System/Library/Java/Extensions/MRJToolkit.jar Affect(row-cnt:84) cost in 5 ms.//尝试查找类的class文件[arthas@89977]$ classloader -c 770c2e6b -r java/lang/String.class jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/rt.jar!/java/lang/String.class Affect(row-cnt:1) cost in 4 ms.//使用classloader加载类[arthas@89977]$ classloader -c 2c109df9 --load com.yiyi.api.WeixinSupportApiload class success. class-info com.yiyi.api.WeixinSupportApi code-source /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/target/classes/ name com.yiyi.api.WeixinSupportApi isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name WeixinSupportApi modifier public annotation org.springframework.web.bind.annotation.RestController,org.springframework.web.bind.annotation.RequestMapping interfaces super-class +-java.lang.Object class-loader +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-sun.misc.Launcher$ExtClassLoader@770c2e6b classLoaderHash 18b4aac2 //使用classloader去查找resource[arthas@89977]$ classloader -c 2c109df9 -r META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk16-143.jar!/META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk15-135.jar!/META-INF/MANIFEST.MF jar:file:/System/Library/Java/Extensions/MRJToolkit.jar!/META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/charsets.jar!/META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/deploy.jar!/META-INF/MANIFEST.MF jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/ext/bcprov-jdk15-135.jar!/META-INF/MANIFEST.MF 2.1.4、getstatic获取类中的静态属性1234[arthas@89977]$ getstatic com.yiyi.api.WeixinSupportApi CORP_IDfield: CORP_ID@String[ww91156f2c9067a7ba]Affect(row-cnt:1) cost in 4 ms. 如果对象是一个复杂的对象，可以使用OGNL表达式进行遍历,过滤 2.1.5、tt命令，记录调用记录方法执行记录的隧道，记录指定方法每次调用的入参和返回的信息，并能对这些不同时间下的调用进行观测。 tt的调用方式：|选项|描述||-|-||-d,–delete|删除索引指定的时间片段||–delete-all|删除所有的时间片段||-x,–expand value|展开对象级别(默认为1)||-h,–help|命令使用指南||-i,–index value|展示指定的时间片段的相信信息||-n,–limits value|执行时间阈值||-l,–list|展示所有的时间片段的信息||–listenerId value|指定监听id||-p,–play|重放由索引指定的时间片段||-E,–regex|启用正则表达式匹配(默认情况下为通配符匹配)||–replay-interval value|选项r大于1的tt的回放间隔||–replay-times value|执行tt时的次数||-s,–search-express value|搜索表达式，用ognl表达式搜索时间片段。|||advice的结构类似条件式表达||-M,–sizeLimit value|结果的字节上限(默认为1010241024)||-t,–time-tunnel|在时间片段内记录方法调用||-w,–watch-express value&gt;|观看ognlexpress的时间片段||class-pattern|模式匹配的路径和类名||method-pattern|模式匹配法||condition-express|ognl风格的条件表达式| 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//记录调用[arthas@89977]$ tt -t com.yiyi.api.WeixinSupportApi test Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 129 ms, listenerId: 1 INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD -------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1000 2020-07-06 17:21:20 0.531715 true false 0x437d2cf WeixinSupportApi test 1001 2020-07-06 17:21:24 0.026004 true false 0x437d2cf WeixinSupportApi test 1002 2020-07-06 17:21:27 0.027567 true false 0x437d2cf WeixinSupportApi test 1003 2020-07-06 17:21:28 0.064779 true false 0x437d2cf WeixinSupportApi test //展示时间片列表[arthas@89977]$ tt -l INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD -------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1000 2020-07-06 17:21:20 0.531715 true false 0x437d2cf WeixinSupportApi test 1001 2020-07-06 17:21:24 0.026004 true false 0x437d2cf WeixinSupportApi test 1002 2020-07-06 17:21:27 0.027567 true false 0x437d2cf WeixinSupportApi test 1003 2020-07-06 17:21:28 0.064779 true false 0x437d2cf WeixinSupportApi test Affect(row-cnt:4) cost in 1 ms.//展示时间片的具体信息[arthas@89977]$ tt -i 1000 INDEX 1000 GMT-CREATE 2020-07-06 17:21:20 COST(ms) 0.531715 OBJECT 0x437d2cf CLASS com.yiyi.api.WeixinSupportApi METHOD test IS-RETURN true IS-EXCEPTION false RETURN-OBJ @String[hello] Affect(row-cnt:1) cost in 1 ms.//重新调用索引为1000的调用[arthas@89977]$ tt -i 1000 -p RE-INDEX 1000 GMT-REPLAY 2020-07-06 17:22:10 OBJECT 0x437d2cf CLASS com.yiyi.api.WeixinSupportApi METHOD test IS-RETURN true IS-EXCEPTION false COST(ms) 0.260785 RETURN-OBJ @String[hello] Time fragment[1000] successfully replayed 1 times.[arthas@89977]$ 表格字段 字段解释 INDEX 时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。 TIMESTAMP 方法执行的本机时间，记录了这个时间片段所发生的本机时间 COST(ms) 方法执行的耗时 IS-RET 方法是否以正常返回的形式结束 IS-EXP 方法是否以抛异常的形式结束 OBJECT 执行对象的hashCode()，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体 CLASS 执行的类名 METHOD 执行的方法名 使用OGNL表达式，对调用参数进行过滤监听。 12345678910111213141516171819202122232425262728[arthas@89977]$ tt -t com.yiyi.api.WeixinSupportApi sendMessage &#x27;params[0].text.content==&quot;test&quot;&#x27;Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 72 ms, listenerId: 5 INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD -------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1004 2020-07-06 17:33:42 354.578854 true false 0x437d2cf WeixinSupportApi sendMessage [arthas@89977]$ tt -i 1004 INDEX 1004 GMT-CREATE 2020-07-06 17:33:42 COST(ms) 354.578854 OBJECT 0x437d2cf CLASS com.yiyi.api.WeixinSupportApi METHOD sendMessage IS-RETURN true IS-EXCEPTION false PARAMETERS[0] @SendMessageVO[ touser=@String[Feng], msgtype=@String[text], agentid=@Integer[1000036], text=@Text[com.yiyi.model.SendMessageVO$Text@504511d7], safe=@Integer[0], ] RETURN-OBJ @WeixinResponse[ errcode=@Integer[0], errmsg=@String[ok], invaliduser=@String[], ] Affect(row-cnt:1) cost in 1 ms. 2.1.6、使用sc查看jvm已加载的类信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//模糊匹配，查看某个包下面的类加载信息[arthas@89977]$ sc com.yiyi.*com.yiyi.Applicationcom.yiyi.Application$$EnhancerBySpringCGLIB$$7f85004ecom.yiyi.WebConfigcom.yiyi.WebConfig$$EnhancerBySpringCGLIB$$bf76c934com.yiyi.api.WeixinSupportApicom.yiyi.api.WeixinSupportApi$$Lambda$451/966754950com.yiyi.api.WeixinSupportApi$$Lambda$467/1545239474com.yiyi.api.WeixinSupportApi$$Lambda$468/1304820993com.yiyi.model.AccessTokenVocom.yiyi.model.SendMessageVOcom.yiyi.model.SendMessageVO$Textcom.yiyi.model.WeixinResponseAffect(row-cnt:12) cost in 15 ms.//指定类的详细信息[arthas@89977]$ sc -d com.yiyi.api.WeixinSupportApi class-info com.yiyi.api.WeixinSupportApi code-source /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/target/classes/ name com.yiyi.api.WeixinSupportApi isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name WeixinSupportApi modifier public annotation org.springframework.web.bind.annotation.RestController,org.springframework.web.bind.annotation.RequestMapping interfaces super-class +-java.lang.Object class-loader +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-sun.misc.Launcher$ExtClassLoader@770c2e6b classLoaderHash 18b4aac2 Affect(row-cnt:1) cost in 8 ms.// 指定类的加载信息以及属性字段的信息[arthas@89977]$ sc -d -f com.yiyi.api.WeixinSupportApi class-info com.yiyi.api.WeixinSupportApi code-source /Users/wuxuan.chai/Documents/project/springboot-learn/weixin/target/classes/ name com.yiyi.api.WeixinSupportApi isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name WeixinSupportApi modifier public annotation org.springframework.web.bind.annotation.RestController,org.springframework.web.bind.annotation.RequestMapping interfaces super-class +-java.lang.Object class-loader +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-sun.misc.Launcher$ExtClassLoader@770c2e6b classLoaderHash 18b4aac2 fields name log type org.slf4j.Logger modifier final,private,static value Logger[com.yiyi.api.WeixinSupportApi] name response type javax.servlet.http.HttpServletResponse modifier private annotation javax.annotation.Resource name CORP_ID type java.lang.String modifier final,private,static value ww91156f2c9067a7ba name APP_SECRET type java.lang.String modifier final,private,static value r5ifq9RFqtsL34sdWXmrzMytY7KYksz5cAimzoH1jeg name ACCESS_TOKEN_CACHE type com.google.common.cache.Cache modifier final,private,static value com.google.common.cache.LocalCache$LocalManualCache@39373908 Affect(row-cnt:1) cost in 10 ms. 2.1.7、mc，内存编译Memory Compiler/内存编译器，编译.java 生成.class文件 1mc /tmp/Test.java 可以通过-c指定classloader： 1mc -c 327a647b /tmp/Test.java 可以通过-d指定输出的class文件的目录 1mc -d /tmp/output /tmp/ClassA.java /tmp/ClassB.java 编译成的.class文件后，可以结合redefine命令实现热更新代码 注意，mc命令有可能失败。如果编译失败可以在本地编译好.class文件，再上传到服务器。 2.1.8、查看方法的stack12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[arthas@89977]$ stack com.yiyi.api.WeixinSupportApi getAccessToken Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 43 ms, listenerId: 8ts=2020-07-06 17:50:49;thread_name=http-nio-7070-exec-2;id=83;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@2fc07784 @com.yiyi.api.WeixinSupportApi.getAccessToken() at com.yiyi.api.WeixinSupportApi.sendMessage(WeixinSupportApi.java:68) at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) 也可以使用OGNL表达式，对请求参数进行过滤，或者使用执行时间进行过滤 2.2.1、Springboot集成arthas引入arthas的依赖 12345678910&lt;properties&gt; &lt;arthas.version&gt;3.3.6&lt;/arthas.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.taobao.arthas&lt;/groupId&gt; &lt;artifactId&gt;arthas-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;arthas.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 应用配置：application.properties 1234//指定arthas的agentIdarthas.agentId=weixin//arthas tunnel server 的websocket的地址arthas.tunnel-server=ws://localhost:7777/ws 重启应用 2.2.2、通过浏览器连接arthas第一步：下载arthas tunnel serverwget https://github.com/alibaba/arthas/releases/download/arthas-all-3.3.6/arthas-tunnel-server-3.3.6.jar第二步：启动arthas tunnel server 1java -jar arthas-tunnel-server.jar -server.port=8888 启动并指定web的端口 这个服务有两个socket连接方式，一个正常的http，用的端口是我们指定的8888，还有一个就是供显示服务器的命令行的websocket连接，端口7777第三步：访问arthas tunnel server ，我是本机测试，所以就是localhost:8888,如图： 连接指定的应用： 默认情况下，连接地址为本地，websocket的端口为7777 三、总结Arthas贵为java应用诊断神器，对于应用的资源占用，性能分析，jvm监控都有很大的支持帮助。除此之外，在排查线上问题时，可以监听对应的方法的调用，以及动态修改class类，很湿，很方便。而且Arthas对docker的java进程，以及k8s都有很好的支持，后续用到的时候在做学习。","categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Arthas","slug":"Arthas","permalink":"https://cha1yi.github.io/dist/tags/Arthas/"}],"author":"wuxuan.chai"},{"title":"通过Jackson玩转Json","slug":"通过Jackson玩转Json","date":"2021-01-17T15:46:42.338Z","updated":"2021-01-18T01:52:30.328Z","comments":true,"path":"2021/01/17/通过Jackson玩转Json/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/%E9%80%9A%E8%BF%87Jackson%E7%8E%A9%E8%BD%ACJson/","excerpt":"","text":"一、Jackson 注解示例1.1、简介在本章中，我们将深入探讨Jackson注解。我们将看到如何使用现有的注解，如何创建自定义注解，最后-如何禁用它们。 1.2、maven 依赖首先，将jackson-databind依赖项添加到pom.xml： 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 或者 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 此依赖项还将在类路径中可传递地添加以下库： jackson-annotations-2.9.8.jar jackson-core-2.9.8.jar jackson-databind-2.9.8.jar 1.3、Jackson序列化注解首先，我们来看看序列化注解。 1.3.1、@JsonAnyGetter{@JsonAnyGetter } 注解允许灵活地使用Map字段作为标准属性。这是一个简单的示例– ExtendableBean实体具有name属性和一组以键/值对形式的可扩展属性,我们还可以使用启用为false的可选参数来禁用@JsonAnyGetter()。 在这种情况下，Map将转换为JSON，并在序列化后显示在properties变量下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonAnyGetter;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.collect.Maps;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import java.util.Map;/** * @author wuxuan.chai * @date 2020/6/8 9:44 上午 */@Getter@Setter@NoArgsConstructorpublic class ExtendableBean &#123; private String name; private Map&lt;String,Object&gt; properties; private Map&lt;String,Object&gt; properties1; public String getName() &#123; return name; &#125; @JsonAnyGetter(enabled = false) public Map&lt;String, Object&gt; getProperties() &#123; return properties; &#125; @JsonAnyGetter public Map&lt;String,Object&gt; getProperties1()&#123; return properties1; &#125; public static void main(String[] args) throws JsonProcessingException &#123; ExtendableBean extendableBean = new ExtendableBean(); extendableBean.setName(&quot;wuxuan&quot;); Map&lt;String, Object&gt; map = Maps.newHashMap(); map.put(&quot;age&quot;,11); map.put(&quot;sex&quot;,&quot;male&quot;); extendableBean.setProperties(map); Map&lt;String, Object&gt; map1 = Maps.newHashMap(); map1.put(&quot;work&quot;,&quot;java pg&quot;); map1.put(&quot;no&quot;,1); extendableBean.setProperties1(map1); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(extendableBean); System.out.println(json); // result: &#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;properties&quot;:&#123;&quot;sex&quot;:&quot;male&quot;,&quot;age&quot;:11&#125;,&quot;no&quot;:1,&quot;work&quot;:&quot;java pg&quot;&#125; &#125;&#125; 1.3.1、@JsonGetter@JsonGetter注解是@JsonProperty注解的替代方法将方法标记为getter方法。在以下示例中，我们将方法getTheName() 指定为MyBeanentity的name属性的getter方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonGetter;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.naming.Name;/** * @author wuxuan.chai * @date 2020/6/8 10:06 上午 */@Setter@NoArgsConstructorpublic class MyBean &#123; private int id; private String name; @JsonGetter(&quot;name&quot;) public String getTheName()&#123; return this.name; &#125; public int getId()&#123; return this.id; &#125; public static void main(String[] args) throws JsonProcessingException &#123; MyBean myBean = new MyBean(); myBean.setId(1); myBean.setName(&quot;wuxuan&quot;); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(myBean); System.out.println(json); //result: &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125; &#125;&#125; 1.3.3、@JsonPropertyOrder我们可以使用@JsonPropertyOrder批注指定序列化属性的顺序。让我们为MyBean实体的属性设置自定义顺序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonGetter;import com.fasterxml.jackson.annotation.JsonPropertyOrder;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.naming.Name;/** * @author wuxuan.chai * @date 2020/6/8 10:06 上午 */@Setter@NoArgsConstructor@JsonPropertyOrder(&#123;&quot;name&quot;,&quot;id&quot;&#125;)public class MyBean &#123; private int id; private String name; @JsonGetter(&quot;name&quot;) public String getTheName()&#123; return this.name; &#125; public int getId()&#123; return this.id; &#125; public static void main(String[] args) throws JsonProcessingException &#123; MyBean myBean = new MyBean(); myBean.setId(1); myBean.setName(&quot;wuxuan&quot;); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(myBean); System.out.println(json); //result: &#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;id&quot;:1&#125; &#125;&#125; 我们还可以使用@JsonPropertyOrder（alphabetic = true）按字母顺序对属性进行排序。 在这种情况下，序列化的输出将是： 1&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125; 1.3.4、@JsonRawValue@JsonRawValue批注可以指示Jackson完全按原样序列化属性。在以下示例中，我们使用@JsonRawValue嵌入一些自定义JSON作为实体的值： 123456789101112131415161718192021222324252627282930313233package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonRawValue;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 10:15 上午 */@Getter@Setterpublic class RawBean &#123; public String name; @JsonRawValue(false) public String json; @SneakyThrows public static void main(String[] args) &#123; RawBean rawBean = new RawBean(); rawBean.setName(&quot;wuxuan&quot;); rawBean.setJson(&quot;&#123;\\&quot;raw\\&quot;:false&#125;&quot;); String json = new ObjectMapper().writeValueAsString(rawBean); System.out.println(json); //@JsonRawValue result: &#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;json&quot;:&#123;&quot;raw&quot;:false&#125;&#125; //@JsonRawValue(false) result: &#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;json&quot;:&quot;&#123;\\&quot;raw\\&quot;:false&#125;&quot;&#125; &#125;&#125; 我们还可以使用可选的布尔参数值来定义此注解是否处于活动状态。 1.3.5、@JsonValue@JsonValue表示库将用于序列化整个实例的单个方法。例如，在一个枚举中，我们用@JsonValue注解getName，以便任何这样的实体都通过其名称序列化： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonValue;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.AllArgsConstructor;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 10:23 上午 */@AllArgsConstructorpublic enum TypeEnumWithValue &#123; /** * 测试枚举序列化 */ TYPE1(1, &quot;wuxuan&quot;), TYPE2(2, &quot;yiyi&quot;); private final Integer id; private final String name; public Integer getId()&#123; return id; &#125; @JsonValue public String getName()&#123; return name; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = new ObjectMapper().writeValueAsString(TYPE1); System.out.println(json); //result: &quot;wuxuan&quot; &#125;&#125; 1.3.6、@JsonRootName如果启用了包装，则使用@JsonRootName批注指定要使用的根包装的名称。包装意味着不要将用户序列化为以下内容： 1234&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;wuxuan&quot;&#125; 而是序列化为： 123456&#123; &quot;user&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;wuxuan&quot; &#125;&#125; 因此，让我们看一个示例–我们将使用@JsonRootName批注指示此潜在包装实体的名称： 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonRootName;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 10:30 上午 */@JsonRootName(&quot;user&quot;)@Getter@Setterpublic class UserWithRoot &#123; private Integer id; private String name; @SneakyThrows public static void main(String[] args) &#123; UserWithRoot userWithRoot = new UserWithRoot(); userWithRoot.setId(1); userWithRoot.setName(&quot;wuxuan&quot;); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.enable(SerializationFeature.WRAP_ROOT_VALUE); String json = objectMapper.writeValueAsString(userWithRoot); System.out.println(json); //result: &#123;&quot;user&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125;&#125; &#125;&#125; 默认情况下，包装器的名称将为类– UserWithRoot。 通过使用注解，我们得到了看上去更干净的用户： 123456&#123; &quot;user&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;wuxuan&quot; &#125;&#125; 从Jackson 2.4开始，新的可选参数名称空间可用于XML之类的数据格式。 如果添加它，它将成为标准名称的一部分： 12345678910111213141516171819202122232425262728293031323334353637383940package com.yiyi.entity;import com.fasterxml.jackson.annotation.JsonRootName;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import com.fasterxml.jackson.dataformat.xml.XmlMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 10:30 上午 */@JsonRootName(value = &quot;user&quot;,namespace = &quot;users&quot;)@Getter@Setterpublic class UserWithRoot &#123; private Integer id; private String name; @SneakyThrows public static void main(String[] args) &#123; UserWithRoot userWithRoot = new UserWithRoot(); userWithRoot.setId(1); userWithRoot.setName(&quot;wuxuan&quot;); XmlMapper xmlMapper = new XmlMapper(); xmlMapper.enable(SerializationFeature.WRAP_ROOT_VALUE); String xml = xmlMapper.writeValueAsString(userWithRoot); System.out.println(xml);// result:// &lt;user xmlns=&quot;users&quot;&gt;// &lt;id xmlns=&quot;&quot;&gt;1&lt;/id&gt;// &lt;name xmlns=&quot;&quot;&gt;wuxuan&lt;/name&gt;// &lt;/user&gt; &#125;&#125; 序列化的xmlMapper结果为： 1234&lt;user xmlns=&quot;users&quot;&gt; &lt;id xmlns=&quot;&quot;&gt;1&lt;/id&gt; &lt;name xmlns=&quot;&quot;&gt;wuxuan&lt;/name&gt;&lt;/user&gt; 1.3.6、@JsonSerialize@JsonSerialize表示在编组实体时要使用的自定义序列化程序。让我们看一个简单的例子。 我们将使用@JsonSerialize通过CustomDateSerializer序列化eventDate属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yiyi.entity;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.annotation.JsonSerialize;import com.yiyi.annotation.support.CustomDateSerializer;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import java.text.SimpleDateFormat;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 10:45 上午 */@Getter@Setterpublic class Event &#123; public String name; @JsonSerialize(using = CustomDateSerializer.class) public Date eventDate; @SneakyThrows public static void main(String[] args) &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;dd-MM-yyy hh:mm:ss&quot;); Event event = new Event(); event.setName(&quot;wuxuan coming&quot;); Date eventDate = new Date(); event.setEventDate(eventDate); System.out.println(simpleDateFormat.format(eventDate)); String json = new ObjectMapper().writeValueAsString(event); System.out.println(json); //result: 08-06-2020 10:54:12 //result: &#123;&quot;name&quot;:&quot;wuxuan coming&quot;,&quot;eventDate&quot;:&quot;08-06-2020 10:52:37&quot;&#125; &#125;&#125; 1.4、Jackson 反序列化的注解接下来，开始探索Jackson的反序列化的注解 1.4.1、@JsonCreator我们可以使用@JsonCreator批注来调整反序列化中使用的构造函数/工厂。 当我们需要反序列化某些与我们需要获取的目标实体不完全匹配的JSON时，这非常有用。看下面的例子，我们需要反序列化这个json： 1234&#123; &quot;id&quot;: 1, &quot;the name&quot;: &quot;wuxuan&quot;&#125; 但是，我们的目标实体中没有TheName字段-只有一个name字段。 现在，我们不想更改实体本身-我们只需要对解组过程进行更多控制-通过使用@JsonCreator注解构造函数并同时使用@JsonProperty注解： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JsonProperty;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 11:04 上午 */@Getter@Setter@ToStringpublic class BeanWithCreator &#123; private int id; private String name; public BeanWithCreator(@JsonProperty(&quot;id&quot;) int id,@JsonProperty(&quot;the name&quot;) String name) &#123; this.id = id; this.name = name; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot;\\&quot;id\\&quot;: 1,\\n&quot; + &quot;\\&quot;the name\\&quot;: \\&quot;wuxuan\\&quot;\\n&quot; + &quot;&#125;&quot;; BeanWithCreator value = new ObjectMapper().readerFor(BeanWithCreator.class).readValue(json); System.out.println(value.toString()); //result: BeanWithCreator(id=1, name=wuxuan) &#125;&#125; 1.4.2. @JacksonInject@JacksonInject指示属性将从注入而不是从JSON数据获取其值。 1234567891011121314151617181920212223242526272829303132package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JacksonInject;import com.fasterxml.jackson.databind.InjectableValues;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 11:15 上午 */@Getter@Setterpublic class BeanWithInject &#123; @JacksonInject private int id; private String name; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\&quot;name\\&quot;: \\&quot;wuxuan\\&quot;&#125;&quot;; InjectableValues.Std std = new InjectableValues.Std().addValue(int.class, 1); BeanWithInject beanWithInject = new ObjectMapper().reader(std).forType(BeanWithInject.class).readValue(json); System.out.println(beanWithInject.id == 1); //result: true &#125;&#125; 1.4.3. @JsonAnySetter@JsonAnySetter使我们可以灵活地使用Map作为标准属性。 反序列化时，JSON的属性将被简单地添加到Map中。让我们看看它是如何工作的–我们将使用@JsonAnySetter反序列化实体ExtendableBean，将下列的json反序列化： 12345&#123; &quot;name&quot;:&quot;My bean&quot;, &quot;attr2&quot;:&quot;val2&quot;, &quot;attr1&quot;:&quot;val1&quot;&#125; 如何使用@JsonAnySetter注解： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JsonAnySetter;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import lombok.ToString;import java.util.HashMap;import java.util.Map;/** * @author wuxuan.chai * @date 2020/6/8 11:21 上午 */@Getter@Setter@ToStringpublic class ExtendableBean &#123; private String name; private Map&lt;String,Object&gt; properties = new HashMap&lt;&gt;(); @JsonAnySetter public void setProperties(String key,String value)&#123; properties.put(key,value); &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;name\\&quot;:\\&quot;My bean\\&quot;,\\n&quot; + &quot; \\&quot;attr2\\&quot;:\\&quot;val2\\&quot;,\\n&quot; + &quot; \\&quot;attr1\\&quot;:\\&quot;val1\\&quot;\\n&quot; + &quot;&#125;&quot;; ExtendableBean extendableBean = new ObjectMapper().readerFor(ExtendableBean.class).readValue(json); System.out.println(extendableBean.toString()); //result: ExtendableBean(name=My bean, properties=&#123;attr2=val2, attr1=val1&#125;) &#125;&#125; 1.4.4. @JsonSetter@JsonSetter是@JsonProperty的替代方法––将方法标记为设置方法。当我们需要读取一些JSON数据但目标实体类与数据不完全匹配时，这非常有用，因此我们需要调整过程以使其适合。在以下示例中，我们将在MyBeanentity中将setTheName()方法指定为name属性的设置方法： 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JsonSetter;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 11:36 上午 */@Getterpublic class MyBean &#123; @Setter private int id; private String theName; @JsonSetter(&quot;name&quot;) public void setTheName(String name)&#123; this.theName = name; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;id\\&quot;: 1,\\n&quot; + &quot; \\&quot;name\\&quot;: \\&quot;wuxuan\\&quot;\\n&quot; + &quot;&#125;&quot;; MyBean myBean = new ObjectMapper().readerFor(MyBean.class).readValue(json); System.out.println(myBean.getTheName().equals(&quot;wuxuan&quot;)); &#125;&#125; 1.4.5. @JsonDeserialize@JsonDeserialize指示使用自定义解串器。让我们看一下效果如何–我们将使用@JsonDeserialize通过CustomDateDeserializer反序列化eventDate属性： 12345678910111213141516171819202122232425262728293031323334353637package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.annotation.JsonDeserialize;import com.yiyi.annotation.support.CustomDateDeserializer;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import java.text.SimpleDateFormat;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 11:41 上午 */@Getter@Setterpublic class Event &#123; private String name; @JsonDeserialize(using = CustomDateDeserializer.class) private Date eventDate; @SneakyThrows public static void main(String[] args) &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;dd-MM-yyy hh:mm:ss&quot;); Date parse = simpleDateFormat.parse(&quot;08-06-2020 10:52:37&quot;); String json = &quot;&#123;\\&quot;name\\&quot;:\\&quot;wuxuan coming\\&quot;,\\&quot;eventDate\\&quot;:\\&quot;08-06-2020 10:52:37\\&quot;&#125;&quot;; Event event = new ObjectMapper().readerFor(Event.class) .readValue(json); System.out.println(parse.equals(event.eventDate)); //result: true &#125;&#125; 1.4.6. @JsonAlias@JsonAlias在反序列化期间为属性定义一个或多个备用名称。 让我们用一个简单的例子来看看这个注解是如何工作的： 12345678910111213141516171819202122232425262728293031323334package com.yiyi.annotation.deseizlize;import com.fasterxml.jackson.annotation.JsonAlias;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 11:52 上午 */@Getter@Setterpublic class AliasBean &#123; @JsonAlias(&#123;&quot;f_name&quot;,&quot;fName&quot;&#125;) private String firstName; private String secondName; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;f_name\\&quot;: \\&quot;chai\\&quot;,\\n&quot; + &quot; \\&quot;secondName\\&quot;: \\&quot;wuxuan\\&quot;\\n&quot; + &quot;&#125;&quot;; AliasBean aliasBean= new ObjectMapper().readerFor(AliasBean.class).readValue(json); System.out.println(aliasBean.getFirstName().equals(&quot;chai&quot;)); //result: true &#125;&#125; 1.5、Jackson多态类型处理注解接下来–让我们看一下Jackson的多态类型处理注解： @JsonTypeInfo - 指示要在序列化中包含哪些类型信息的详细信息 @JsonSubTypes - 指示带注解类型的子类型 @JsonTypeName - 定义用于注解类的逻辑类型名称让我们看一个更复杂的示例，并使用全部三个@ JsonTypeInfo，@ JsonSubTypes和@JsonTypeName来序列化/反序列化实体Zoo： 123456789101112131415161718192021222324252627282930package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 12:54 下午 */@Getter@Setterpublic class Zoo &#123; public Animal animal; @SneakyThrows public static void main(String[] args) &#123; Dog dog = new Dog(); dog.setName(&quot;wangwang&quot;); dog.setBackVolume(2.0); Zoo zoo = new Zoo(); zoo.setAnimal(dog); String json = new ObjectMapper().writeValueAsString(zoo); System.out.println(json); //result: &#123;&quot;animal&quot;:&#123;&quot;type&quot;:&quot;dog&quot;,&quot;name&quot;:&quot;wangwang&quot;,&quot;backVolume&quot;:2.0&#125;&#125; &#125;&#125; 12345678910111213141516171819package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.annotation.JsonSubTypes;import com.fasterxml.jackson.annotation.JsonTypeInfo;import lombok.Getter;import lombok.Setter;/** * @author wuxuan.chai * @date 2020/6/8 12:54 下午 */@Getter@Setter@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;type&quot;)@JsonSubTypes(&#123;@JsonSubTypes.Type(value = Dog.class, name = &quot;dog&quot;), @JsonSubTypes.Type(value = Cat.class, name = &quot;cat&quot;)&#125;)public class Animal &#123; private String name;&#125; 1234567891011121314151617package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.annotation.JsonTypeName;import lombok.Getter;import lombok.Setter;/** * @author wuxuan.chai * @date 2020/6/8 12:54 下午 */@Getter@Setter@JsonTypeName(&quot;dog&quot;)public class Dog extends Animal &#123; public double backVolume;&#125; 1234567891011121314151617package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.annotation.JsonTypeName;import lombok.Getter;import lombok.Setter;/** * @author wuxuan.chai * @date 2020/6/8 12:56 下午 */@Getter@Setter@JsonTypeName(&quot;cat&quot;)public class Cat extends Animal&#123; private boolean likesCream; private int lives;&#125; 现在测试反序列化： 12345678&#123; &quot;animal&quot;: &#123; &quot;type&quot;:&quot;dog&quot;, &quot;name&quot;:&quot;wangwang&quot;, &quot;backVolume&quot;:2.0 &#125;&#125; 1234567891011121314151617181920212223242526272829package com.yiyi.annotation.polymorphic;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 12:54 下午 */@Getter@Setter@ToStringpublic class Zoo &#123; public Animal animal; @SneakyThrows public static void main(String[] args) &#123; String dJson = &quot;&#123;\\&quot;animal\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;dog\\&quot;,\\&quot;name\\&quot;:\\&quot;wangwang\\&quot;,\\&quot;backVolume\\&quot;:2.0&#125;&#125;&quot;; Zoo zoo1 = new ObjectMapper().readerFor(Zoo.class).readValue(dJson); System.out.println(zoo1); //result: Zoo(animal=Dog(backVolume=2.0)) &#125;&#125; 1.6、Jackson一般的注解接下来，一起讨论一些jackson的一般注解 1.6.1、@JsonProperty我们可以添加@JsonProperty注解去表示在json中的属性名称，在处理非标准的getter和setter时，让我们使用@JsonProperty对属性名称进行序列化/反序列化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonProperty;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 1:47 下午 */public class MyBean &#123; @Getter @Setter private Integer id; private String theName; @JsonProperty(&quot;name&quot;) public void setTheName(String name) &#123; this.theName = name; &#125; @JsonProperty(&quot;name&quot;) public String getTheName() &#123; return theName; &#125; @SneakyThrows public static void main(String[] args) &#123; MyBean myBean = new MyBean(); myBean.setId(1); myBean.setTheName(&quot;wuxuan&quot;); String json = new ObjectMapper().writeValueAsString(myBean); System.out.println(json); MyBean myBean1 = new ObjectMapper().readerFor(MyBean.class).readValue(json); System.out.println(myBean1.theName.equals(myBean.theName)); //reasult: //&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125; //true &#125;&#125; 1.6.2、@JsonFormat@JsonFormat批注指定序列化日期/时间值时的格式。在下面的示例中，我们使用@JsonFormat来控制属性eventDate的格式： 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonFormat;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.*;import java.text.SimpleDateFormat;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 1:53 下午 */@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Event &#123; private String name; @JsonFormat(shape = JsonFormat.Shape.STRING,pattern = &quot;dd-MM-yyyy hh:mm:ss&quot;) private Date eventDate; @SneakyThrows public static void main(String[] args) &#123; Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;dd-MM-yyyy hh:mm:ss&quot;); String format = simpleDateFormat.format(date); Event event = new Event(&quot;wuxuan comming&quot;, date); String json = new ObjectMapper().writeValueAsString(event); assert json.contains(format); &#125;&#125; 1.6.3、@JsonUnWrapped@JsonUnwrapped定义应展开/展平的值序列化/反序列化时。让我们看看它是如何工作的； 我们将使用注解解开属性名称： 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonUnwrapped;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 2:01 下午 */@Datapublic class UnwappedUser &#123; private int id; @JsonUnwrapped(prefix = &quot;n_&quot;,suffix = &quot;_o&quot;,enabled = true) private Name name; @Data public static class Name&#123; private String firstName; private String lastName; &#125; @SneakyThrows public static void main(String[] args) &#123; Name name = new Name(); name.setFirstName(&quot;chai&quot;); name.setLastName(&quot;wuxuan&quot;); UnwappedUser unwappedUser = new UnwappedUser(); unwappedUser.setName(name); String json = new ObjectMapper().writeValueAsString(unwappedUser); System.out.println(json); //result: &#123;&quot;id&quot;:0,&quot;n_firstName_o&quot;:&quot;chai&quot;,&quot;n_lastName_o&quot;:&quot;wuxuan&quot;&#125; &#125;&#125; 1.6.4、@JsonView@JsonView指示将在其中包含属性以进行序列化/反序列化的View。一个示例将确切显示其工作原理-我们将使用@JsonView序列化Item实体的实例。 让我们从视图开始： 123456789101112131415161718192021222324252627282930package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonView;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.AllArgsConstructor;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 2:08 下午 */@Data@AllArgsConstructorpublic class Item &#123; @JsonView(Views.Public.class) private Integer id; @JsonView(Views.Public.class) private String itemName; @JsonView(Views.internal.class) private String ownerName; @SneakyThrows public static void main(String[] args) &#123; Item item = new Item(1, &quot;wuxuan&quot;, &quot;wuxuan111&quot;); String json = new ObjectMapper().writerWithView(Views.Public.class).writeValueAsString(item); System.out.println(json); &#125;&#125; 1.6.5. @JsonManagedReference, @JsonBackReference@JsonManagedReference和@JsonBackReference注解可以处理父/子关系并解决循环。在以下示例中–我们使用@JsonManagedReference和@JsonBackReference序列化我们的ItemWithRefentity： 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonManagedReference;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.collect.Lists;import lombok.AllArgsConstructor;import lombok.Data;import lombok.SneakyThrows;import java.util.List;/** * @author wuxuan.chai * @date 2020/6/8 2:18 下午 */@Data@AllArgsConstructorpublic class ItemWithRef &#123; private int id; private String itemName; @JsonManagedReference public UserWithRef owner; @SneakyThrows public static void main(String[] args) &#123; UserWithRef userWithRef = new UserWithRef(1,&quot;wuxuan&quot;,null); ItemWithRef itemWithRef = new ItemWithRef(1, &quot;wwww&quot;, null); List&lt;ItemWithRef&gt; itemWithRefs = Lists.newArrayList(); itemWithRefs.add(itemWithRef); userWithRef.setUserItems(itemWithRefs); String json = new ObjectMapper().writeValueAsString(userWithRef); System.out.println(json); //result: &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;wuxuan&quot;&#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonBackReference;import com.google.common.collect.Lists;import lombok.AllArgsConstructor;import lombok.Data;import java.util.List;/** * @author wuxuan.chai * @date 2020/6/8 2:19 下午 */@Data@AllArgsConstructorpublic class UserWithRef &#123; public int id; private String name; @JsonBackReference public List&lt;ItemWithRef&gt; userItems; public List&lt;ItemWithRef&gt; addItem(ItemWithRef itemWithRef) &#123; if (userItems == null)&#123; userItems = Lists.newArrayList(); userItems.add(itemWithRef); return userItems; &#125; userItems.add(itemWithRef); return userItems; &#125;&#125; 处理循环调用的场景 1.6.6. @JsonIdentityInfo@JsonIdentityInfo指示在对值进行序列化/反序列化时应使用对象标识，例如，以处理无限递归类型的问题。在以下示例中–我们有一个ItemWithIdentity实体，它与UserWithIdentity实体具有双向关系： 1234567891011121314151617181920212223242526272829303132333435363738package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonIdentityInfo;import com.fasterxml.jackson.annotation.ObjectIdGenerators;import com.google.common.collect.Lists;import lombok.Data;import java.util.List;/** * @author wuxuan.chai * @date 2020/6/8 2:30 下午 */@Data@JsonIdentityInfo( generator= ObjectIdGenerators.PropertyGenerator.class, property = &quot;id&quot;)public class UserWithIdentity &#123; private Integer id; private String name; private List&lt;ItemWithIdentity&gt; userItems; public UserWithIdentity(Integer id, String name) &#123; this.id = id; this.name = name; &#125; public void addItem(ItemWithIdentity item) &#123; if (userItems == null)&#123; userItems = Lists.newArrayList(); userItems.add(item); return; &#125; userItems.add(item); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonIdentityInfo;import com.fasterxml.jackson.annotation.ObjectIdGenerators;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 2:29 下午 */@JsonIdentityInfo( generator = ObjectIdGenerators.PropertyGenerator.class, property = &quot;id&quot;)@Datapublic class ItemWithIdentity &#123; private Integer id; private String itemName; private UserWithIdentity owner; public ItemWithIdentity(Integer id, String itemName, UserWithIdentity owner) &#123; this.id = id; this.itemName = itemName; this.owner = owner; &#125; @SneakyThrows public static void main(String[] args) &#123; UserWithIdentity user = new UserWithIdentity(1, &quot;John&quot;); ItemWithIdentity item = new ItemWithIdentity(2, &quot;book&quot;, user); user.addItem(item); String json = new ObjectMapper().writeValueAsString(item); System.out.println(json); //result: &#123;&quot;id&quot;:2,&quot;itemName&quot;:&quot;book&quot;,&quot;owner&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;userItems&quot;:[2]&#125;&#125; &#125;&#125; 1.6.7. @JsonFilter@JsonFilter批注指定在序列化期间使用的过滤器。让我们看一个例子； 首先，我们定义实体，然后指向过滤器： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yiyi.annotation.generate;import com.fasterxml.jackson.annotation.JsonFilter;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 2:47 下午 */@JsonFilter(&quot;myFilter&quot;)@Datapublic class BeanWithFilter &#123; private Integer id; private String name; public BeanWithFilter(Integer id, String name) &#123; this.id = id; this.name = name; &#125; @SneakyThrows public static void main(String[] args) &#123; BeanWithFilter beanWithFilter = new BeanWithFilter(1, &quot;Wuxuuan&quot;); String json = new ObjectMapper() .writer(new SimpleFilterProvider() .addFilter(&quot;myFilter&quot;, SimpleBeanPropertyFilter.filterOutAllExcept(&quot;name&quot;))) .writeValueAsString(beanWithFilter); System.out.println(json); //result: &#123;&quot;name&quot;:&quot;Wuxuuan&quot;&#125; &#125;&#125; 1.7、自定义Jackson注解接下来，我们一起学习如何创建一个Jackson自定义注解，我们可以使用@JacksonAnnotationsInside注解： 123456789101112131415161718192021222324package com.yiyi.annotation.customAnnotation;import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.annotation.JsonPropertyOrder;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * @author wuxuan.chai * @date 2020/6/8 2:54 下午 * * 运行时注解 * json包含非空 * json排序 */@Retention(RetentionPolicy.RUNTIME)@JacksonAnnotationsInside@JsonInclude(JsonInclude.Include.NON_NULL)@JsonPropertyOrder(&#123;&quot;name&quot;,&quot;id&quot;,&quot;datteCreated&quot;&#125;)public @interface CustomAnnotation &#123;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.annotation.customAnnotation;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 2:56 下午 */@CustomAnnotation@Datapublic class BeanWithCustomAnnotation &#123; private Integer id; private String name; private Date dateCreated; public BeanWithCustomAnnotation(Integer id, String name, Date dateCreated) &#123; this.id = id; this.name = name; this.dateCreated = dateCreated; &#125; @SneakyThrows public static void main(String[] args) &#123; BeanWithCustomAnnotation bean = new BeanWithCustomAnnotation(1, &quot;wuxuan&quot;, new Date()); String json = new ObjectMapper().writeValueAsString(bean); System.out.println(json); //result：&#123;&quot;name&quot;:&quot;wuxuan&quot;,&quot;id&quot;:1,&quot;dateCreated&quot;:1591599545147&#125; &#125;&#125; 1.8、Jackson 混入注解接下来，让我们一起看看如何使用Jackson的混入注解，让我们用混入注解举个例子 - 忽略User类中的属性： 12345678910111213package com.yiyi.annotation.mixln;import lombok.Data;/** * @author wuxuan.chai * @date 2020/6/8 3:05 下午 */@Datapublic class User &#123; private String sex;&#125; 123456789101112package com.yiyi.annotation.mixln;import com.fasterxml.jackson.annotation.JsonIgnoreType;/** * @author wuxuan.chai * @date 2020/6/8 3:06 下午 */@JsonIgnoreTypepublic class MyMixinForIgnoreType &#123;&#125; 12345678910111213141516171819202122232425262728293031323334353637package com.yiyi.annotation.mixln;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 3:04 下午 */@Datapublic class Item &#123; private Integer id; private String itemName; private User owner; public Item(Integer id, String itemName, User owner) &#123; this.id = id; this.itemName = itemName; this.owner = owner; &#125; @SneakyThrows public static void main(String[] args) &#123; Item item = new Item(1, &quot;ccc&quot;, null); String json = new ObjectMapper().writeValueAsString(item); //检查是否序列化了User类型 assert json.contains(&quot;owner&quot;); ObjectMapper objectMapper = new ObjectMapper().addMixIn(User.class, MyMixinForIgnoreType.class); String json1 = objectMapper.writeValueAsString(item); //检查是否忽略了User类型 assert !json1.contains(&quot;owner&quot;); &#125;&#125; 1.9、禁用 Jackson 注解最后，我们一起看看如何禁用所有的jackson注解，我们可以通过禁用MapperFeature.USE_ANNOTATIONS来实现此目的，如以下示例所示： 12345678910111213141516171819202122232425262728293031323334353637package com.yiyi.annotation.disabledJson;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.annotation.JsonPropertyOrder;import com.fasterxml.jackson.databind.MapperFeature;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 3:13 下午 */@Data@JsonInclude(JsonInclude.Include.NON_NULL)@JsonPropertyOrder(&#123;&quot;name&quot;,&quot;id&quot;&#125;)public class MyBean &#123; private String id; private String name; public MyBean(String id, String name) &#123; this.id = id; this.name = name; &#125; @SneakyThrows public static void main(String[] args) &#123; MyBean wuxuan = new MyBean(&quot;1&quot;, &quot;wuxuan&quot;); String json = new ObjectMapper().disable(MapperFeature.USE_ANNOTATIONS).writeValueAsString(wuxuan); System.out.println(json); //期望，非空校验和排序注解都失效 //result：&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;wuxuan&quot;&#125; &#125;&#125; 二、Jackson ObjectMapper 的简介2.1、简介本章着重于理解Jackson ObjectMapper类，以及如何将Java对象序列化为JSON以及如何将JSON字符串反序列化为Java对象。 2.2、使用ObjectMapper读和写让我们从基本的读写操作开始。ObjectMapper的简单readValue API是一个很好的入口点。 我们可以使用它来将JSON内容解析或反序列化为Java对象。同样，在编写方面，我们可以使用writeValue API将任何Java对象序列化为JSON输出。在本章中，我们将使用以下带有两个字段的Car类作为对象进行序列化或反序列化： 1234567891011121314package com.yiyi.objectMapper.using;import lombok.Data;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Datapublic class Car &#123; private String color; private String type;&#125; 2.2.1、Java对象序列化成json让我们一起学习第一个序列化例子，用ObjectMapper类的writeValue将java转换成json 1234567891011121314151617181920212223242526272829package com.yiyi.objectMapper.using;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import java.io.File;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Datapublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; @SneakyThrows public static void main(String[] args) &#123; Car car = new Car(&quot;red&quot;, &quot;BMW&quot;); new ObjectMapper().writeValue(new File(&quot;/Users/wuxuan.chai/Documents/project/springboot-learn/Jackson/src/main/java/com/yiyi/objectMapper/using/Car.json&quot;),car); &#125;&#125; 运行结果： 1234生成一个Car.json文件内容：&#123;&quot;color&quot;:&quot;red&quot;,&quot;type&quot;:&quot;BMW&quot;&#125; ObjectMapper类的writeValueAsString和writeValueAsBytes方法从Java对象生成JSON，并以字符串或字节数组形式返回生成的JSON： 12345678910111213141516171819202122232425262728293031323334package com.yiyi.objectMapper.using;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import java.io.File;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Datapublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; @SneakyThrows public static void main(String[] args) &#123; Car car = new Car(&quot;red&quot;, &quot;BMW&quot;); String json = new ObjectMapper().writeValueAsString(car); System.out.println(json); byte[] bytes = new ObjectMapper().writeValueAsBytes(car); String bytesStr = new String(bytes); System.out.println(json.equals(bytesStr)); &#125;&#125; 运行结果： 12&#123;&quot;color&quot;:&quot;red&quot;,&quot;type&quot;:&quot;BMW&quot;&#125;true 2.2.2、Json转换成Java对象以下是使用ObjectMapper类将JSON字符串转换为Java对象的简单示例： 1&#123;&quot;color&quot;:&quot;red&quot;,&quot;type&quot;:&quot;BMW&quot;&#125; readValue（）函数还接受其他形式的输入，例如包含JSON字符串的文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.objectMapper.using;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import java.io.File;import java.net.URL;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Data@EqualsAndHashCodepublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; public Car()&#123; &#125; @SneakyThrows public static void main(String[] args) &#123; Car car = new Car(&quot;red&quot;, &quot;BMW&quot;); String json = &quot;&#123;\\&quot;color\\&quot;:\\&quot;red\\&quot;,\\&quot;type\\&quot;:\\&quot;BMW\\&quot;&#125;&quot;; Car car1 = new ObjectMapper().readValue(json, Car.class); System.out.println(car1.equals(car)); Car car2 = new ObjectMapper().readValue(new File(&quot;/Users/wuxuan.chai/Documents/project/springboot-learn/Jackson/src/main/java/com/yiyi/objectMapper/using/Car.json&quot;), Car.class); System.out.println(car2.equals(car)); //result： // true // true &#125;&#125; 2.2.3、Json转换成Jackson的Json节点另外，可以将JSON解析为JsonNode对象，并用于从特定节点检索数据： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.yiyi.objectMapper.using;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import java.io.File;import java.net.URL;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Data@EqualsAndHashCodepublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; public Car()&#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\&quot;color\\&quot;:\\&quot;red\\&quot;,\\&quot;type\\&quot;:\\&quot;BMW\\&quot;&#125;&quot;; JsonNode jsonNode = new ObjectMapper().readTree(json); String type = jsonNode.get(&quot;type&quot;).asText(); System.out.println(type.equals(&quot;BMW&quot;)); //result: true &#125;&#125; 2.2.4、从Json数组字符串中创建Java集合我们可以使用TypeReference将数组形式的JSON解析为Java对象列表： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.yiyi.objectMapper.using;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;import java.util.List;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Data@EqualsAndHashCode@ToStringpublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; public Car()&#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String jsonArray = &quot;[\\n&quot; + &quot; &#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;BMW\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; &#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Black\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;audi\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;]&quot;; List&lt;Car&gt; cars = new ObjectMapper().readValue(jsonArray, new TypeReference&lt;List&lt;Car&gt;&gt;()&#123;&#125;); System.out.println(cars); //result: [Car(color=Red, type=BMW), Car(color=Black, type=audi)] &#125;&#125; 2.2.5、从json中创建Java Map同样，我们可以将JSON解析为Java Map： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.objectMapper.using;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;import java.util.List;import java.util.Map;/** * @author wuxuan.chai * @date 2020/6/8 3:23 下午 */@Data@EqualsAndHashCode@ToStringpublic class Car &#123; private String color; private String type; public Car(String color, String type) &#123; this.color = color; this.type = type; &#125; public Car()&#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;BMW\\&quot;\\n&quot; + &quot;&#125;&quot;; Map&lt;String, String&gt; javaMap = new ObjectMapper().readValue(json, new TypeReference&lt;Map&lt;String, String&gt;&gt;() &#123;&#125;); System.out.println(javaMap); //result: &#123;color=Red, type=BMW&#125; &#125;&#125; 三、高级功能Jackson库的最大优势之一是高度可定制的序列化和反序列化过程。在本部分中，我们将介绍一些高级功能，其中输入或输出JSON响应可能不同于生成或使用响应的对象。 3.1、 配置 Serialization / Deserialization 功能在将JSON对象转换为Java类时，如果JSON字符串具有一些新字段，则默认过程将导致异常： 12345&#123; &quot;color&quot;: &quot;Red&quot;, &quot;type&quot;: &quot;BMW&quot;, &quot;year&quot;: &quot;2020&quot;&#125; 上面示例中的默认解析过程中，针对Car类的Java对象的JSON字符串将导致UnrecognizedPropertyException异常。通过configure方法，我们可以扩展默认过程以忽略新字段： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yiyi.advanced;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 3:59 下午 */@Data@ToString@EqualsAndHashCodepublic class Car &#123; private String type; private String color; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;BMW\\&quot;,\\n&quot; + &quot; \\&quot;year\\&quot;: \\&quot;2020\\&quot;\\n&quot; + &quot; &#125;&quot;; // 也可以这么写： new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false); ObjectMapper objectMapper = new ObjectMapper().disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); Car car = objectMapper.readValue(json, Car.class); System.out.println(car); JsonNode jsonNode = objectMapper.readTree(json); String year = jsonNode.get(&quot;year&quot;).asText(); System.out.println(year); &#125;&#125; 对于DeserializationFeature枚举中中的设置的描述： 配置 默认值 作用描述 USE_BIG_DECIMAL_FOR_FLOATS false 如果只有通用类型描述（Object或Number或未类型化的java.util.Map或java.util.Collection上下文中）可用，此功能确定是否将JSON浮点数反序列化为java.math.BigDecimals。 如果启用，则将这些值反序列化为java.math.BigDecimals;。 如果禁用，将反序列化为Doubles。默认情况下，此功能为禁用状态，这意味着默认情况下，“未类型化”的浮点数将反序列化为Doubles（出于性能考虑，选择-BigDecimals慢于Doubles）。 USE_BIG_INTEGER_FOR_INTS false 确定是否将JSON整数（非浮点数）数字反序列化为java.math.BigIntegers的功能（如果只有通用类型描述（Object或Number或在无类型的java.util.Map或java.util.Collection上下文中） ）可用。 如果启用，则将这些值反序列化为java.math.BigIntegers;。 如果禁用，则将反序列化为“最小”可用类型，根据类型的数目，可以是Integer，Long或java.math.BigInteger。默认情况下，此功能是禁用的，这意味着默认情况下，将使用最紧凑的整数类型对“未类型化”的整数进行反序列化，以优化效率。 USE_LONG_FOR_INTS false 当目标类型被松散地键入为Object或Number（或在其中）时，用于确定如何绑定“小” JSON整数（非浮点数）（适合32位有符号整数（int））的功能 未类型化的java.util.Map或java.util.Collection上下文）。 如果启用，则这些值将反序列化为Long； 如果禁用，它们将反序列化为“最小”可用类型，整数。 此外，如果启用了该选项，则尝试绑定不适合Long的值将引发com.fasterxml.jackson.core.JsonProcessingException。注意：如果启用USE_BIG_INTEGER_FOR_INTS，它将优先于此设置，并强制对所有整数值使用java.math.BigInteger。该功能默认情况下处于禁用状态，这意味着如果值合适，默认情况下将使用Integer反序列化“无类型”整数。 USE_JAVA_ARRAY_FOR_JSON_ARRAY false 绑定“无类型”对象（标称类型为java.lang.Object的对象）时确定JSON数组是映射到Object[]还是List的功能。 如果为true，则绑定为Object[]; 如果为false，则为List。默认情况下，功能是禁用的，这意味着JSON数组绑定为java.util.Lists。 FAIL_ON_UNKNOWN_PROPERTIES true 确定遇到未知属性（不映射到属性，并且没有“任何setter”或处理程序的处理程序）的功能是否会导致失败（通过抛出JsonMappingException）。 仅在尝试了其他所有用于未知属性的处理方法并且该属性保持未处理状态后，此设置才生效。 默认情况下启用此功能（这意味着如果遇到未知属性，将抛出JsonMappingException）。 FAIL_ON_NULL_FOR_PRIMITIVES false 反序列化为Java基本类型（如“ int”或“ double”）时，确定是否遇到JSON null的错误的功能。 如果是，则抛出JsonProcessingException来表明这一点。 如果不是，则使用默认值（0表示“ int”，0.0表示double，与JVM使用的默认值相同）。默认情况下禁用此功能。 FAIL_ON_NUMBERS_FOR_ENUMS false 确定JSON整数是否是用于反序列化Java枚举值的有效值的功能。 如果设置为“ false”，则数字是可接受的，并用于映射到匹配枚举值的ordinal（）； 如果为“ true”，则不允许数字，并且将引发JsonMappingException。 如果担心可能会发生从整数值到枚举的意外映射（并且枚举始终序列化为JSON字符串的情况），那么后者的行为就很有意义。默认情况下禁用此功能。 FAIL_ON_INVALID_SUBTYPE true 确定无法找到（丢失）或解决（丢失）类名称（例如，无效的类名，不可映射的id）的多态值的类型（例如，由com.fasterxml.jackson.annotation.JsonTypeInfo指示）时发生的情况的功能； 如果启用，则引发异常； 如果为false，则使用null值。默认情况下启用功能，以便因缺少类型信息或无效类型信息而引发异常。 FAIL_ON_READING_DUP_TREE_KEY false 该功能确定在将JSON内容读入树（com.fasterxml.jackson.core.TreeNode）并遇到重复键（已为JSON对象看到的属性名称）时发生什么情况。 如果启用，将抛出JsonMappingException； 如果禁用，则不会引发异常，并且新的（较新的）值将覆盖较早的值。请注意，此属性不会影响数据绑定的其他方面。 也就是说，不对POJO属性或java.util.Map键进行检测。 可以添加新功能来控制其他情况。默认情况下，功能是禁用的，因此不会引发异常。 FAIL_ON_IGNORED_PROPERTIES false 确定在输入中遇到显式标记为可忽略的属性时将发生什么的功能：如果启用了功能，则抛出JsonMappingException； 如果为false，则默默地跳过属性。 默认情况下，功能是禁用的，因此不会引发异常。 FAIL_ON_UNRESOLVED_OBJECT_IDS true 确定遇到的对象ID引用不引用具有该ID的实际对象（“未解决的对象ID”）的情况时发生的功能：抛出异常（true），或者使用空对象代替（false） 。 请注意，如果将其设置为false，则不会进行进一步处理； 具体来说，如果引用是通过setter方法定义的，则不会调用该方法。默认情况下启用此功能，以便在反序列化结束时，未知的对象ID将导致引发异常。 FAIL_ON_MISSING_CREATOR_PROPERTIES false 该功能确定一个或多个创建者属性（绑定到创建者方法（构造函数或静态工厂方法）的参数的属性）缺少要从内容绑定到的值时发生的情况。 如果启用，则此类缺少的值会导致抛出JsonMappingException并附带第一个（按索引）缺少的属性的信息。 如果禁用，并且未将属性标记为必需，则缺少的Creator属性将由反序列化器为参数类型提供的空值填充（通常对于Object类型为null，对于基元为默认值；但可通过自定义反序列化器重新定义）。注意，具有可注射的值算作“不丢失”。默认情况下，该功能为禁用状态，因此除非缺少将创建者属性值明确标记为“必需”的属性，否则不会引发任何异常。 FAIL_ON_NULL_CREATOR_PROPERTIES false 该功能可确定如果将一个或多个Creator属性（绑定到Creator方法（构造方法或静态工厂方法）的参数的属性）绑定到null值（来自JSON或作为默认值）时会发生什么。 如果要避免代码库中为null，则这很有用，如果对非强制性字段使用Java或Scala可选参数，则这特别有用。 默认情况下，该功能为禁用状态，因此除非缺少将创建者属性值明确标记为“必需”的属性，否则不会引发任何异常。 FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY true 该功能确定缺少使用com.fasterxml.jackson.annotation.JsonTypeInfo.As.EXTERNAL_PROPERTY注解的属性但用的关联类型ID时发生的情况。 如果启用，则总是在缺少属性值时（如果类型ID确实存在）抛出JsonMappingException； 如果禁用，则仅在将属性标记为“必需”时抛出异常。默认情况下启用功能，以便在缺少子类型属性时引发异常。 FAIL_ON_TRAILING_TOKENS false 绑定根值后确定数据绑定行为的功能。 如果启用了功能，则再次调用com.fasterxml.jackson.core.JsonParser.nextToken以确保找不到更多令牌（如果找到了更多令牌，则抛出com.fasterxml.jackson.databind.exc.MismatchedInputException ）; 如果禁用，则不进行进一步检查。该功能也可以称为READ_FULL_STREAM，因为它可以有效地验证输入流仅包含绑定完整值所需的数据，而仅包含其他内容（可能的可忽略空格或注解，如果数据格式支持，则除外）。由于向后兼容的原因，默认情况下功能是禁用的（因此不检查可能的尾随令牌）。 WRAP_EXCEPTIONS true 确定杰克逊代码是否应捕获并包装异常（但绝不要出错！）以添加有关问题位置（在输入范围内）的附加信息的功能。 如果启用，大多数异常将被捕获并重新抛出（特别是java.io.IOExceptions可以按原样传递，因为它们被声明为可抛出）。 这很方便，因为将检查并声明所有异常，因此有更多上下文信息。 但是，有时调用应用程序可能只希望按原样传递“原始”未经检查的异常。默认情况下启用此功能。 ACCEPT_SINGLE_VALUE_AS_ARRAY false 确定强制将非数组（JSON）值强制用于Java集合（数组，java.util.Collection）类型的功能。 如果启用，集合反序列化器将尝试处理非数组值，就像它们对JSON数组具有“隐式”一样。 此功能旨在出于兼容性/互操作性原因而使用，以与在数组中只有单个元素的情况下忽略JSON数组的程序包（例如XML到JSON转换器）一起使用。默认情况下禁用此功能。 UNWRAP_SINGLE_VALUE_ARRAYS false 确定将单个值数组（在JSON中）的值强制转换为相应值类型是否可接受的功能。 这基本上与ACCEPT_SINGLE_VALUE_AS_ARRAY功能相反。 如果在数组中找到多个值，则抛出JsonMappingException。默认情况下禁用功能 UNWRAP_ROOT_VALUE false 允许“解包”根级JSON值以匹配用于序列化的SerializationFeature.WRAP_ROOT_VALUE的设置。 将验证根JSON值是一个JSON对象，并且它具有具有预期根名的单个属性。 如果不是，则抛出JsonMappingException。 否则，包装属性的值将被反序列化，就好像它是根值一样。默认情况下禁用此功能。 ACCEPT_EMPTY_STRING_AS_NULL_OBJECT false 可以启用此功能以允许将POJO和其他结构化值（java.util.Maps，java.util.Collections）的JSON空字符串值（“”）绑定为“ null”。 如果禁用，则只能从JSONnull或JSON对象绑定标准POJO（标准含义是未定义任何自定义反序列化器或构造函数；这两种都可以添加对其他种类JSON值的支持）； 如果启用，则可以将空JSON字符串等效为JSON null。注意：这不适用于标量值，例如布尔值和数字； 是否可以强制使用它们取决于MapperFeature.ALLOW_COERCION_OF_SCALARS。默认情况下禁用此功能。 ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT false 可以启用此功能，以允许将空JSON数组值（即[]）绑定为POOL（以及2.9，还包含其他值）为“ null”。 如果禁用，则只能从JSONnull或JSON对象绑定标准POJO（标准含义是未定义任何自定义反序列化器或构造函数；这两种都可以添加对其他种类JSON值的支持）； 如果启用，则将使用空JSON数组等效于JSON null。默认情况下禁用此功能。 ACCEPT_FLOAT_AS_INT true 确定是否强制转换为从JSON浮点数（任何带命令（.）或指数部分（e /E&#39;））到期望的整数（int，long，java.lang .integer，java.lang.Long，java.math.BigDecimal是否允许。 如果启用，强制将截断值； 如果禁用，将抛出JsonMappingException。默认情况下启用此功能。 READ_ENUMS_USING_TO_STRING false 确定用于Enum值的标准反序列化机制的功能：如果启用，则假定Enums已使用Enum.toString（）的返回值进行了序列化； 如果禁用，则假定已使用Enum.name（）的返回值。注意：此功能通常应与SerializationFeature.WRITE_ENUMS_USING_TO_STRING具有相同的值。默认情况下禁用此功能。 READ_UNKNOWN_ENUM_VALUES_AS_NULL false 允许将未知的Enum值解析为空值的功能。 如果禁用，未知的Enum值将引发异常。请注意，在某些情况下，这基本上会忽略未知的Enum值； 这是java.util.EnumMap的键的键和java.util.EnumSet的值的（因为在这些情况下不接受null）。默认情况下禁用此功能。 READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE false 该功能允许忽略未知的Enum值，并通过@JsonEnumDefaultValue批注指定预定义值。 如果禁用，未知的Enum值将引发异常。 如果启用，但未指定预定义的默认Enum值，则也会引发异常。 默认情况下禁用此功能。 READ_DATE_TIMESTAMPS_AS_NANOSECONDS true 当且仅当数据类型支持这种分辨率时，此功能可控制是否应使用（启用）或不使用（禁用）纳秒级时间戳写入数字时间戳值。 只有较新的数据类型（例如Java8日期/时间）才支持这种分辨率-较旧的类型（Java8之前的java.util.Date等）和Joda则不支持-并且此设置对此类类型无效。如果禁用，则假定为标准毫秒时间戳。 这与SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS相对应。默认情况下启用此功能，以支持最准确的时间值。 ADJUST_DATES_TO_CONTEXT_TIME_ZONE true 该功能指定上下文提供的java.util.TimeZone（DeserializationContext.getTimeZone（）是否应用于在反序列化时调整日期/时间值，即使值本身包含时区信息也是如此。 如果禁用，则仅当值本身不包含任何TimeZone信息时才使用它。请注意，确切的行为取决于所讨论的日期/时间类型。 特别是JDK类型的java.util.Date没有内置时区信息，因此此设置无效。 此外，尽管java.util.Calendar确实具有此信息，但是基本JDK java.text.SimpleDateFormat无法保留已解析的区域信息，因此，无论此设置如何，java.util.Calendar始终将获得上下文时区调整。考虑到上述因素，只有Joda和Java 8日期/文字数据类型的扩展模块才支持此功能。 EAGER_DESERIALIZER_FETCH true 决定ObjectReader是否应在可能的情况下热切获取必要的JsonDeserializer的功能。 如果多次使用类似配置的ObjectReader实例，则可以提高性能。 并且不会对一次性使用案例产生重大影响。请注意，通常不需要禁用此功能：仅在存在实际可察觉问题的情况下考虑。 默认情况下启用此功能。 对于SerializationFeature枚举中的设置进行描述： |配置|默认值|作用描述||-|-||WRAP_ROOT_VALUE|false|可以启用以使根值（通常为JSON对象，但可以是任何类型）包装在单个属性JSON对象中的功能，其中键为“根名”，由注释内省者确定（对于使用@XmlRootElement的JAXB尤其如此） .name）或后备广告（非合格的类名）。 功能主要是为了与JAXB兼容。默认情况下禁用此功能。||INDENT_OUTPUT|false|该功能允许使用为ObjectMapper（以及从mapper创建的ObjectWriters）配置的默认漂亮打印机为基础生成器启用（或禁用）缩进。请注意，仅当未为生成器或ObjectWriter配置显式com.fasterxml.jackson.core.PrettyPrinter时，才使用默认的漂亮打印机。默认情况下禁用此功能。||FAIL_ON_EMPTY_BEANS|true|该功能用于确定在找不到类型的访问器时会发生什么情况（并且没有注释指示它打算被序列化）。 如果启用（默认），则将引发异常以指示这些类型为不可序列化的类型； 如果禁用，它们将被序列化为空对象，即没有任何属性。请注意，此功能仅对那些没有任何可识别注释的“空” bean（例如，@JsonSerialize）起作用的空类型：具有注释的那些不会导致抛出异常。默认情况下启用此功能。||FAIL_ON_SELF_REFERENCES|true|决定POJO检测到直接自我引用时会发生什么情况的功能（并且未启用对象ID处理）：抛出JsonMappingException（如果为true），或者通常对引用进行处理（false）。默认情况下启用功能||WRAP_EXCEPTIONS|true|确定Jackson代码是否应捕获并包装异常（但绝不要出错！）以添加有关问题位置（在输入范围内）的附加信息的功能。 如果启用，大多数异常将被捕获并重新抛出（特别是java.io.IOExceptions可以按原样传递，因为它们被声明为可抛出）。 这很方便，因为将检查并声明所有异常，因此有更多上下文信息。 但是，有时调用应用程序可能只希望按原样传递“原始”未经检查的异常。默认情况下启用此功能。||FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS|true|确定通常具有Jackson包含的类型信息的对象与com.fasterxml.jackson.annotation.JsonUnwrapped结合使用时发生的功能。 在默认（启用）状态下，当展开的对象具有类型信息时，将引发错误。 禁用时，将解包该对象，并丢弃类型信息。默认情况下启用此功能。||WRITE_SELF_REFERENCES_AS_NULL|false|决定POJO检测到直接自引用时会发生什么情况的功能（并且未启用对象ID处理）：如果启用，则将该引用写为null； 如果禁用，则使用默认行为（它将尝试序列化，通常会导致异常）。 但是，如果启用了FAIL_ON_SELF_REFERENCES。 此属性将被忽略。||CLOSE_CLOSEABLE|false|用于确定是否在序列化后调用实现java.io.Closeable的序列化根级对象的close方法（调用了ObjectMapper的writeValue（）（或等效方法）的对象）的功能。 如果启用，则在序列化完成后（无论成功还是由于抛出异常而显示的错误）将调用close（）。 您可以将其视为某种“最终”处理。注意：仅影响根对象的行为，而不影响从根对象可访问的其他对象。 换句话说，每个“ writeValue”调用将只进行一次调用。默认情况下禁用此功能。||FLUSH_AFTER_WRITE_VALUE|true|确定是否以JsonGenerator作为参数的writeValue（）方法完成后是否调用JsonGenerator.flush（）的功能（即不影响使用其他目标的方法）; ObjectWriter中的方法相同。 这通常是有道理的； 但是在某些情况下不应该强制执行刷新：例如，在底层流进行压缩时，并且flush（）导致刷新了压缩状态（某些压缩编解码器会发生这种情况）。默认情况下启用此功能。||WRITE_DATES_AS_TIMESTAMPS|true|确定是否将Date（和日期/时间）值（以及基于Date的东西，如java.util.Calendars）序列化为数字时间戳记（true；默认值）或其他值（通常是文本表示形式）的功能。如果使用文本表示，则实际格式取决于配置设置，包括@JsonFormat批注的按属性使用，全局配置的java.text.DateFormat。对于“经典” JDK日期类型（java.util.Date，java.util.Calendar），默认格式由com.fasterxml.jackson.databind.util.StdDateFormat提供，并且对应于格式字符串“ yyyy-MM-dd” ‘T’HH：mm：ss.SSSX”（有关字符串格式的详细信息，请参见java.text.DateFormat）。此功能是否影响其他与日期相关的类型的处理取决于这些类型的处理程序，尽管理想情况下，他们应该使用此功能注意：使用WRITE_DATE_KEYS_AS_TIMESTAMPS代替此功能来控制java.util.Map密钥是否序列化为字符串。默认情况下启用功能，因此默认情况下将日期/时间序列化为时间戳。||WRITE_DATE_KEYS_AS_TIMESTAMPS|false|确定是否将用作java.util.Map键的java.util.Dates（和子类型）序列化为时间戳的功能（如果没有，则序列化为文本值）。默认值为“ false”，表示将日期值映射键序列化为文本（ISO-8601）值。默认情况下禁用此功能。||WRITE_DATES_WITH_ZONE_ID|false|用于确定日期/日期时间值是否应该序列化的功能，以便在类型本身包含时区信息的情况下，它们包括时区id。 包含此信息可能会导致兼容性问题，因为ISO-8601规范未定义包含此类信息的格式。如果启用，则应使用Java 8 DateTimeFormatter＃ISO_ZONED_DATE_TIME定义所指定的格式来包含时区ID（例如，“ 2011-12-03T10：15：30 + 01：00 [欧洲/巴黎]”）。注意：如果日期/时间值被序列化为时间戳，则该设置不相关。默认情况下，该功能处于禁用状态，因此不包含区域ID。 相反，时区偏移量用于ISO-8601兼容性（如果值中包含任何时区信息）。||WRITE_DURATIONS_AS_TIMESTAMPS|true|默认情况下，用于确定表示时间段（持续时间，时间段，范围）的时间值是否要使用数字（true）或文本（false）表示序列化的功能。 请注意，根据类型的不同，数字表示可能表示简单数字或数字数组。注意：使用WRITE_DATE_KEYS_AS_TIMESTAMPS来控制java.util.Map密钥是否序列化为字符串。默认情况下启用此功能，因此默认情况下将周期/持续时间序列化为时间戳。||WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS|false|确定char []类型如何序列化的功能：启用后，将序列化为显式JSON数组（以单字符字符串作为值）； 禁用时，默认情况下将其序列化为字符串（更为紧凑）。默认情况下禁用此功能。||WRITE_ENUMS_USING_TO_STRING|false|确定用于Enum值的标准序列化机制的功能：如果启用，则使用Enum.toString（）的返回值； 如果禁用，则使用Enum.name（）的返回值。注意：此功能通常应与DeserializationFeature.READ_ENUMS_USING_TO_STRING具有相同的值。默认情况下禁用此功能。||WRITE_ENUMS_USING_INDEX|false|确定Java Enum值是序列化为数字（true）还是文本值（false）的功能。 如果使用文本值，则还将考虑其他设置。 如果启用此功能，则Enum.ordinal（）的返回值（整数）将用作序列化。请注意，此功能的优先级高于WRITE_ENUMS_USING_TO_STRING，只有将此功能设置为false时，才考虑此功能。请注意，从2.10开始，这不适用于作为java.util.Map值的键编写的枚举，该枚举具有单独的设置WRITE_ENUM_KEYS_USING_INDEX。默认情况下禁用此功能。||WRITE_ENUM_KEYS_USING_INDEX|false|确定是否将用作java.util.Map密钥的{link Enum}序列化为使用Enum.ordinal（）的功能。 与将枚举写入常规值时使用的WRITE_ENUMS_USING_INDEX相似。默认情况下禁用此功能。||WRITE_NULL_MAP_VALUES|true|确定是否要对具有空值的Map条目进行序列化（true）或不进行序列化（false）的功能。注意：与其他SerializationFeatures不同，此功能不能在每次调用的基础上动态更改，因为在构造序列化程序和属性处理程序时会考虑其作用。默认情况下启用此功能。||WRITE_EMPTY_JSON_ARRAYS|true|确定是否将容器属性（具有声明的Collection或数组值的POJO属性；即，产生JSON数组的事物）为空（没有元素）的属性，将被序列化为空JSON数组（true），还是从输出中取消显示（false） 。请注意，这不会更改java.util.Maps或“类似集合”类型的行为。注意：与其他SerializationFeatures不同，此功能不能在每次调用的基础上动态更改，因为在构造序列化程序和属性处理程序时会考虑其作用。默认情况下启用此功能。||WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED|false|为互操作性而添加的功能，以与所谓的“ BadgerFish”约定兼容。 功能确定对单个元素java.util.Collections和数组的处理：如果启用，则仅包含一个元素的java.util.Collections和数组将被序列化，就好像该元素本身已被序列化一样。启用后，带有数组的POJO通常如下所示：{“ arrayProperty”：[1]}而是序列化为{“ arrayProperty”：1}请注意，此功能与DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY相对（即，通常两者都启用，或两者都不启用）。||WRITE_BIGDECIMAL_AS_PLAIN|false|确定是否使用java.math.BigDecimal.toPlainString（）序列化java.math.BigDecimal条目的功能，以防止使用科学计数法写入值。注意：由于此功能通常需要使用com.fasterxml.jackson.core.JsonGenerator.writeNumber（String），因此可能会导致兼容性问题，因为并非所有com.fasterxml.jackson.core.JsonGenerator实现都支持这种输出模式：通常仅文本 基于格式的格式支持它。默认情况下禁用此功能。||WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS|true|控制是否使用纳秒级时间戳写入数字时间戳值（启用）（禁用）的功能； 当且仅当数据类型支持这种分辨率时。 只有较新的数据类型（例如Java8日期/时间）才支持这种分辨率-较旧的类型（Java8之前的java.util.Date等）和Joda则不支持-并且此设置对此类类型无效。如果禁用，则假定为标准毫秒时间戳。 这与DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS对应。默认情况下启用此功能，以支持最准确的时间值。||ORDER_MAP_ENTRIES_BY_KEYS|false|确定是否在序列化之前首先按键对java.util.Map条目进行排序的功能：如果启用，则在必要时执行附加的排序步骤（对于java.util.SortedMaps不必要），如果禁用，则无需进行其他排序。默认情况下禁用此功能。||EAGER_SERIALIZER_FETCH|true|决定ObjectWriter是否应在可能的情况下热切获取必要的JsonSerializer的功能。 如果多次使用类似配置的ObjectWriter实例，则可以提高性能。 并且不会对一次性使用案例产生重大影响。请注意，通常不需要禁用此功能：仅在存在实际可察觉问题的情况下考虑。默认情况下启用此功能。||USE_EQUALITY_FOR_OBJECT_ID|false|确定是否使用对象的真实JVM级别标识（false）比较对象标识的功能； 或equals（）方法。 当使用ORM库（例如Hibernate）处理数据库绑定的对象时，后期有时会很有用。 注意对象本身是实际比较的，不是对象ID。 此功能的命名有些令人困惑，因此重要的是，要为其保留身份的对象在id之上和之外都被认为是相等的（无论如何，它们总是使用相等性进行比较）。注意：由于实现功能的方式，非常重要的是，除了覆盖Object.equals以使对象匹配（被视为“相同”）之外，还必须确保Object.hashCode（）被覆盖以产生 相等实例的值完全相同。默认情况下禁用此功能； 表示使用严格的身份，而不是equals（）| 3.2、创建自定义的序列化/反序列化器ObjectMapper类的另一个基本功能是能够注册自定义序列化器和反序列化器。 在输入或输出JSON响应的结构不同且必须对其进行序列化或反序列化的Java类的结构时，自定义序列化器和反序列化器非常有用。以下是自定义JSON序列化程序的示例： 1234567891011121314151617181920212223242526272829package com.yiyi.advanced;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.databind.SerializerProvider;import com.fasterxml.jackson.databind.ser.std.StdSerializer;import java.io.IOException;/** * @author wuxuan.chai * @date 2020/6/8 4:49 下午 */public class CustomCarSerializer extends StdSerializer&lt;Car&gt; &#123; protected CustomCarSerializer(Class&lt;Car&gt; t) &#123; super(t); &#125; public CustomCarSerializer() &#123; this(null); &#125; @Override public void serialize(Car car, JsonGenerator gen, SerializerProvider provider) throws IOException &#123; gen.writeStartObject(); gen.writeStringField(&quot;car_brand&quot;, car.getType()); gen.writeEndObject(); &#125;&#125; 此自定义序列化器可以这样调用： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.yiyi.advanced;import com.fasterxml.jackson.core.Version;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 3:59 下午 */@Data@ToString@EqualsAndHashCodepublic class Car &#123; private String type; private String color; public Car(String type, String color) &#123; this.type = type; this.color = color; &#125; @SneakyThrows public static void main(String[] args) &#123; Car car = new Car(&quot;BMW&quot;, &quot;Red&quot;); String json = new ObjectMapper() .registerModule( new SimpleModule( &quot;CustomCarSerializer&quot;, new Version(1, 0, 0, null, null, null) ).addSerializer(Car.class, new CustomCarSerializer())) .writeValueAsString(car); System.out.println(json); //result:&#123;&quot;car_brand&quot;:&quot;BMW&quot;&#125; &#125;&#125; 这是自定义JSON反序列化的示例： 1234567891011121314151617181920212223242526272829303132333435363738package com.yiyi.advanced;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.core.ObjectCodec;import com.fasterxml.jackson.core.TreeNode;import com.fasterxml.jackson.databind.DeserializationContext;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.deser.std.StdDeserializer;import java.io.IOException;/** * @author wuxuan.chai * @date 2020/6/8 4:59 下午 */public class CustomCarDeserializer extends StdDeserializer&lt;Car&gt; &#123; protected CustomCarDeserializer(Class&lt;?&gt; vc) &#123; super(vc); &#125; public CustomCarDeserializer()&#123; this(null); &#125; @Override public Car deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException &#123; Car car = new Car(); ObjectCodec codec = p.getCodec(); JsonNode treeNode = codec.readTree(p); JsonNode colorNode = treeNode.get(&quot;color&quot;); String color = colorNode.asText(); car.setColor(color); return car; &#125;&#125; 此自定义反序列化器可以这样调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.advanced;import com.fasterxml.jackson.core.Version;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 3:59 下午 */@Data@ToString@EqualsAndHashCodepublic class Car &#123; private String type; private String color; public Car(String type, String color) &#123; this.type = type; this.color = color; &#125; public Car() &#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;color\\&quot;: \\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;BMW\\&quot;&quot;+ &quot; &#125;&quot;; Car car = new ObjectMapper() .registerModule( new SimpleModule( &quot;CustomCarDeserializer&quot;, new Version(1, 0, 0, null, null, null) ).addDeserializer(Car.class, new CustomCarDeserializer())) .readValue(json, Car.class); System.out.println(car); //result: Car(type=null, color=Red) &#125;&#125; 3.3、Date 格式化的处理方式java.util.Date的默认序列化产生一个数字，即纪元时间戳（自1970年1月1日起，以UTC为单位的毫秒数）。 但这不是人类可读的，并且需要进一步转换以人类可读的格式显示。 让我们使用datePurchased属性将到目前为止使用的Car实例包装在Request类中： 12345678910111213141516package com.yiyi.advanced;import lombok.Data;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 5:12 下午 */@Datapublic class Request &#123; private Car car; private Date createDate;&#125; 控制日期的字符串格式，并将其设置为例如 yyyy-MM-dd HH:mm a z，请考虑以下代码段： 12345678910111213141516171819202122232425262728293031323334353637383940package com.yiyi.advanced;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import java.text.SimpleDateFormat;import java.util.Date;/** * @author wuxuan.chai * @date 2020/6/8 5:12 下午 */@Datapublic class Request &#123; private Car car; private Date createDate; public Request() &#123; &#125; public Request(Car car, Date createDate) &#123; this.car = car; this.createDate = createDate; &#125; @SneakyThrows public static void main(StrinDeserializationFeatureg[] args) &#123; Car car = new Car(&quot;BMW&quot;, &quot;Red&quot;); Request request = new Request(car,new Date()); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm a z&quot;); ObjectMapper objectMapper = new ObjectMapper().setDateFormat(simpleDateFormat); String json = objectMapper.writeValueAsString(request); System.out.println(json); //result: &#123;&quot;car&quot;:&#123;&quot;type&quot;:&quot;BMW&quot;,&quot;color&quot;:&quot;Red&quot;&#125;,&quot;createDate&quot;:&quot;2020-06-08 17:16 下午 CST&quot;&#125; &#125;&#125; 更多的时间格式化的方式参考：深入学习日期格式化 3.4、集合的处理方式DeserializationFeature类提供的另一个小而有用的功能是能够根据JSON数组响应生成所需类型的集合的功能。例如，我们可以将结果生成为数组： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.yiyi.advanced;import com.fasterxml.jackson.core.Version;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 3:59 下午 */@Data@ToString@EqualsAndHashCodepublic class Car &#123; private String type; private String color; public Car(String type, String color) &#123; this.type = type; this.color = color; &#125; public Car() &#123; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;[\\n&quot; + &quot; &#123;\\n&quot; + &quot; \\&quot;color\\&quot;:\\&quot;Red\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;:\\&quot;BMW\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; &#123;\\n&quot; + &quot; \\&quot;color\\&quot;:\\&quot;Black\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;:\\&quot;audi\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;]&quot;; //也可以写成： objectMapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true); ObjectMapper objectMapper = new ObjectMapper().enable(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY); Car[] cars = objectMapper.readValue(json, Car[].class); List&lt;Car&gt; carList = objectMapper.readValue(json,new TypeReference&lt;List&lt;Car&gt;&gt;()&#123;&#125;); &#125;&#125; 四、Jackson序列化是忽略属性4.1、简介本章将展示在使用Jackson 2.x将对象序列化为JSON时如何忽略某些字段。当Jackson默认值还不够，并且我们需要精确控制要序列化为JSON的内容时，这非常有用-并且有几种方法可以忽略属性。 4.2、在类级别上忽略字段我们可以使用@JsonIgnoreProperties批注并按名称指定字段，从而在类级别忽略特定字段： 123456789101112131415161718192021222324252627282930313233package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 5:32 下午 */@Data@JsonIgnoreProperties(&#123;&quot;intValue&quot;&#125;)public class MyDto &#123; private String stringValue; private int intValue; private Boolean booleanValue; public MyDto(String stringValue, int intValue, Boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDto myDto = new MyDto(&quot;wuxuan&quot;, 12, false); String json = new ObjectMapper().writeValueAsString(myDto); System.out.println(json); //result: &#123;&quot;stringValue&quot;:&quot;wuxuan&quot;,&quot;booleanValue&quot;:false&#125; &#125;&#125; 要毫无例外地忽略JSON输入中的任何未知属性，我们可以设置@JsonIgnoreProperties批注的ignoreUnknown = true。 4.3、在字段级别上忽略字段我们也可以直接通过@JsonIgnore批注直接忽略该字段： 1234567891011121314151617181920212223242526272829303132333435package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonIgnore;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 5:32 下午 */@Datapublic class MyDto &#123; private String stringValue; private int intValue; @JsonIgnore private Boolean booleanValue; public MyDto(String stringValue, int intValue, Boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDto myDto = new MyDto(&quot;wuxuan&quot;, 12, false); String json = new ObjectMapper().writeValueAsString(myDto); System.out.println(json); //result：&#123;&quot;stringValue&quot;:&quot;wuxuan&quot;,&quot;intValue&quot;:12&#125; &#125;&#125; 4.4、通过类型忽略所有字段最后，我们可以使用@JsonIgnoreType批注忽略指定类型的所有字段。 如果我们控制类型，那么我们可以直接注解类： 12345678910111213141516171819202122232425262728293031package com.yiyi.ignoreField;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 5:42 下午 */@Datapublic class SomeType &#123; private String type; private MyDto myDto; public SomeType(String type, MyDto myDto) &#123; this.type = type; this.myDto = myDto; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDto wuxuan = new MyDto(&quot;wuxuan&quot;, 1, false); SomeType type = new SomeType(&quot;www&quot;, wuxuan); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(type); System.out.println(json); //result:&#123;&quot;type&quot;:&quot;www&quot;&#125; &#125;&#125; 但是，我们常常无法控制类本身； 在这种情况下，我们可以充分利用Jackson的混入注解。首先，我们为要忽略的类型定义一个MixIn，然后使用@JsonIgnoreType对其进行注解： 123456789101112package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonIgnoreType;/** * @author wuxuan.chai * @date 2020/6/8 5:47 下午 */@JsonIgnoreTypepublic class MyMixinForIgnoreType &#123;&#125; 然后，我们在编组期间注册该mixin来替换（并忽略）所有String[]类型： 123456789101112package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonIgnoreType;/** * @author wuxuan.chai * @date 2020/6/8 5:47 下午 */@JsonIgnoreTypepublic class MyMixinForIgnoreType &#123;&#125; 123456789101112131415161718192021222324252627282930313233package com.yiyi.ignoreField;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 5:57 下午 */@Datapublic class MyDtoWithSpecialField &#123; private String[] stringValue; private int intValue; private boolean booleanValue; public MyDtoWithSpecialField(String[] stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDtoWithSpecialField myDtoWithSpecialField = new MyDtoWithSpecialField(new String[]&#123;&quot;1&quot;, &quot;2&quot;&#125;, 1, false); ObjectMapper objectMapper = new ObjectMapper().addMixIn(String[].class, MyMixinForIgnoreType.class); String json = objectMapper.writeValueAsString(myDtoWithSpecialField); System.out.println(json); //result: &#123;&quot;intValue&quot;:1,&quot;booleanValue&quot;:false&#125; &#125;&#125; 4.5、通过过滤器忽略字段最后，我们还可以使用过滤器来忽略Jackson中的特定字段。 首先，我们需要在Java对象上定义过滤器,去除掉name属性： 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.ignoreField;import com.fasterxml.jackson.annotation.JsonFilter;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 6:03 下午 */@JsonFilter(&quot;myFilter&quot;)@Datapublic class MyDtoFilter &#123; private String type; private String name; public MyDtoFilter(String type, String name) &#123; this.type = type; this.name = name; &#125; public MyDtoFilter() &#123; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDtoFilter myDtoFilter = new MyDtoFilter(&quot;BMW&quot;, &quot;x5&quot;); SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeAllExcept(&quot;name&quot;); SimpleFilterProvider myFilter = new SimpleFilterProvider().addFilter(&quot;myFilter&quot;, filter); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writer(myFilter).writeValueAsString(myDtoFilter); System.out.println(json); //result:&#123;&quot;type&quot;:&quot;BMW&quot;&#125; &#125;&#125; 五、在Jackson中忽略值为NULL的字段5.1、简介本快速章节将介绍如何在序列化Java类时设置Jackson以忽略空字段。 5.2、在类上忽略NULL字段12@JsonInclude(Include.NON_NULL)public class MyDto &#123; ... &#125; 或者-更细粒度上讲-在字段级级： 12345public class MyDto&#123; @JsonInclude(Include.NON_NULL) private String value; private int number;&#125; 4.3. 全局忽略NULL的字段Jackson还允许在ObjectMapper上全局配置此行为： 12345678public class MyDtoTest&#123; @Test public void testNullField() &#123; ObjectMapper mapper = new ObjectMapper().setSerializationInclusion(Include.NON_NULL); ... &#125; &#125; 忽略空字段是一种常见的Jackson配置，因为通常情况下，我们需要更好地控制JSON输出。 本章说明如何对类进行此操作。 但是，还有更高级的用例，例如在序列化Map时忽略空值。 六、Jackson更改字段的名称6.1、简介本快速章节说明了如何更改字段名称以在序列化时映射到另一个JSON属性。 6.2、更改要序列化的字段名称以MyDto类为例： 123456789101112131415161718192021222324252627282930313233343536373839package com.yiyi.changeFieldName;import com.fasterxml.jackson.annotation.JsonProperty;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 6:18 下午 */@Datapublic class MyDto &#123; private String value; private String name; public MyDto(String value, String name) &#123; this.value = value; this.name = name; &#125; public MyDto() &#123; &#125; @JsonProperty(&quot;value_fact&quot;) public String getValue()&#123; return value; &#125; @SneakyThrows public static void main(String[] args) &#123; MyDto myDto = new MyDto(&quot;sfsd&quot;, &quot;www&quot;); String json = new ObjectMapper().writeValueAsString(myDto); System.out.println(json); //result: &#123;&quot;name&quot;:&quot;www&quot;,&quot;value_fact&quot;:&quot;sfsd&quot;&#125; &#125;&#125; 七、Jackson用未知属性反序列化JSON7.1、简介在本章中，我们将研究Jackson 2.x的解组过程，特别是如何处理具有未知属性的JSON内容。 7.2、使用其他/未知字段反序列化JSONJSON输入有各种形态和大小-在大多数情况下，我们需要将其映射到具有一定数量字段的预定义Java对象。 目标是简单地忽略所有无法映射到现有Java字段的JSON属性。例如，假设我们需要将JSON解组到以下Java实体： 123456789101112131415161718192021222324package com.yiyi.unmarshall;import lombok.Data;/** * @author wuxuan.chai * @date 2020/6/8 6:25 下午 */@Datapublic class MyDto &#123; private String stringValue; private int intValue; private boolean booleanValue; public MyDto() &#123; &#125; public MyDto(String stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125;&#125; 7.3、未知字段上的UnrecognizedPropertyException尝试将具有未知属性的JSON反序列化到此简单Java实体将导致com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yiyi.unmarshall;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;/** * @author wuxuan.chai * @date 2020/6/8 6:25 下午 */@Datapublic class MyDto &#123; private String stringValue; private int intValue; private boolean booleanValue; public MyDto() &#123; &#125; public MyDto(String stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;stringValue\\&quot;: \\&quot;wuxuan\\&quot;,\\n&quot; + &quot; \\&quot;intValue\\&quot;: 1,\\n&quot; + &quot; \\&quot;booleanValue111\\&quot;: false\\n&quot; + &quot;&#125;&quot;; ObjectMapper objectMapper = new ObjectMapper(); MyDto myDto = objectMapper.readValue(json, MyDto.class); //throw UnrecognizedPropertyException 异常 /** * Unrecognized field &quot;booleanValue111&quot; (class com.yiyi.unmarshall.MyDto), not marked as ignorable (3 known properties: &quot;stringValue&quot;, &quot;booleanValue&quot;, &quot;intValue&quot;]) * at [Source: (String)&quot;&#123; * &quot;stringValue&quot;: &quot;wuxuan&quot;, * &quot;intValue&quot;: 1, * &quot;booleanValue111&quot;: false * &#125;&quot;; line: 4, column: 29] (through reference chain: com.yiyi.unmarshall.MyDto[&quot;booleanValue111&quot;]) */ &#125;&#125; 7.4、通过设置ObjectMapper处理未知字段的异常现在，我们可以配置完整的ObjectMapper以忽略JSON中的未知属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.yiyi.unmarshall;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 6:25 下午 */@Data@ToStringpublic class MyDto &#123; private String stringValue; private int intValue; private boolean booleanValue; public MyDto() &#123; &#125; public MyDto(String stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;stringValue\\&quot;: \\&quot;wuxuan\\&quot;,\\n&quot; + &quot; \\&quot;intValue\\&quot;: 1,\\n&quot; + &quot; \\&quot;booleanValue111\\&quot;: true\\n&quot; + &quot;&#125;&quot;; ObjectMapper objectMapper = new ObjectMapper(); //也可以写成：objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false); objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); MyDto myDto = objectMapper.readValue(json, MyDto.class); System.out.println(myDto); //result: MyDto(stringValue=wuxuan, intValue=1, booleanValue=false) // booleanValue=false 是对象的属性的默认值，因为booleanValue 是基本类型，不是包装类型，默认值为false &#125;&#125; 7.5、通过类上注解处理未知字段我们还可以将单个类标记为接受未知字段，而不是整个Jackson对象映射器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.yiyi.unmarshall;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import lombok.SneakyThrows;import lombok.ToString;/** * @author wuxuan.chai * @date 2020/6/8 6:25 下午 */@Data@ToString@JsonIgnoreProperties(ignoreUnknown = true)public class MyDto &#123; private String stringValue; private int intValue; private boolean booleanValue; public MyDto() &#123; &#125; public MyDto(String stringValue, int intValue, boolean booleanValue) &#123; this.stringValue = stringValue; this.intValue = intValue; this.booleanValue = booleanValue; &#125; @SneakyThrows public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;stringValue\\&quot;: \\&quot;wuxuan\\&quot;,\\n&quot; + &quot; \\&quot;intValue\\&quot;: 1,\\n&quot; + &quot; \\&quot;booleanValue111\\&quot;: true\\n&quot; + &quot;&#125;&quot;; ObjectMapper objectMapper = new ObjectMapper(); MyDto myDto = objectMapper.readValue(json, MyDto.class); System.out.println(myDto); //result: MyDto(stringValue=wuxuan, intValue=1, booleanValue=false) // booleanValue=false 是对象的属性的默认值，因为booleanValue 是基本类型，不是包装类型，默认值为false &#125;&#125; 八、总结初次系统的学习Jackson的使用方式，感受到了Jackson特别灵活，定制化强的特点，针对于日常的业务需求，已经足够了。更让人惊讶的是自定义的Jackson注解，更是让Jackson如虎添翼。","categories":[{"name":"详细教程","slug":"详细教程","permalink":"https://cha1yi.github.io/dist/categories/%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cha1yi.github.io/dist/tags/Java/"}],"author":"wuxuan.chai"},{"title":"SQL语句概念简单整理","slug":"SQL语句概念简单整理","date":"2021-01-17T15:44:30.693Z","updated":"2021-01-17T16:16:10.261Z","comments":true,"path":"2021/01/17/SQL语句概念简单整理/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/SQL%E8%AF%AD%E5%8F%A5%E6%A6%82%E5%BF%B5%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/","excerpt":"","text":"一、SQL语言共分为四大类 数据查询语言DQL 数据操纵语言DML 数据定义语言DDL 数据控制语言DCL。 二、简要描述这四类1、数据查询语言DQL数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：SELECT &lt;字段名表&gt;FROM &lt;表或视图名&gt;WHERE &lt;查询条件&gt; 2、数据操纵语言DML数据操纵语言DML主要有三种形式： 插入：INSERT 更新：UPDATE 删除：DELETE（删除表中的数据不删除表结构，可以回滚） 3、数据定义语言DDL CREATE：创建 ALTER：修改表结构 RENAME：修改表名或列名 DROP：删除表中的数据和结构，删除后不能回滚 TRUNCATE：删除表中的数据不删除表结构，删除后不能回滚，效率比DELETE高 4、数据控制语言DCL GRANT：授权 REVOKE ：回收权限 还有事务控制语句TCL： SAVEPOINT：保存点 ROLLBACK：回退到某点 COMMIT：提交事务","categories":[{"name":"数据库","slug":"数据库","permalink":"https://cha1yi.github.io/dist/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://cha1yi.github.io/dist/tags/SQL/"}],"author":"wuxuan.chai"},{"title":"设计模式之----工厂模式","slug":"设计模式之----工厂模式","date":"2021-01-17T15:37:18.288Z","updated":"2021-01-17T16:16:10.259Z","comments":true,"path":"2021/01/17/设计模式之----工厂模式/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B----%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式之—-工厂模式工厂模式（Factory Pattern）是java中最常用的设计模式之一，这种类型设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象是不会对客户暴露创建逻辑，并且是通过使用一个共同的接口，以此来达到解耦的目的。 下面的例子以造车为例来说明三种模式。 分类1、简单工厂模式 (Simple Factory)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class Car &#123;&#125;public enum CarType &#123; BMW, AUDI, DAZHONG;&#125;public class BmwCar extends Car&#123; public BmwCar()&#123; System.out.println(&quot;这是宝马车&quot;); &#125;&#125;public class AudiCar extends Car&#123; public AudiCar()&#123; System.out.println(&quot;这是奥迪车&quot;); &#125;&#125;public class DaZhongCar extends Car &#123; public DaZhongCar() &#123; System.out.println(&quot;这是大众车&quot;); &#125;&#125;public class CarFactory &#123; /** * 静态工厂方法 * * @param carType 车的类型 * @return 车的对象 */ public static Car createCar(CarType carType) &#123; switch (carType) &#123; case BMW: return new BmwCar(); case AUDI: return new AudiCar(); case DAZHONG: return new DaZhongCar(); default: return null; &#125; &#125; public static void main(String[] args) &#123; CarFactory.createCar(CarType.AUDI); &#125;&#125; 输出： 123这是奥迪车Process finished with exit code 0 这种工厂模式，已经完成了我们工厂模式的基本的需求，创建对象和解耦缺点：1、用户调用需要知道自己要创建的对象在工厂中的类型2、拓展很麻烦，如果新增一个产品，需要在产品的具体创建对象的实现，还需使工厂支持创建这种产品，这显然是违背开闭原则的 2、工厂方法模式（Factory Method）123456789101112131415161718192021222324252627282930313233public interface Factory &#123; /** * 生产车的方法 * @return 车的对象 */ Car createCar();&#125;public class AudiFactory implements Factory&#123; @Override public Car createCar() &#123; return new AudiCar(); &#125;&#125;public class BmwFactory implements Factory&#123; @Override public Car createCar() &#123; return new BmwCar(); &#125;&#125;public class DaZhongFactory implements Factory&#123; @Override public Car createCar() &#123; return new DaZhongCar(); &#125;&#125;//客户使用public class ConsumerTest &#123; public static void main(String[] args) &#123; final BmwFactory bmwFactory = new BmwFactory(); bmwFactory.createCar(); &#125;&#125; 输出： 123这是宝马车Process finished with exit code 0 工厂方法模式组成： 1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 方法工厂模式和简单工厂模式最大的不同，就是将实现交给了具体的工厂，核心工厂只提供产品线，具体的实现工厂只需要去实现对应的需求即可。如果新增产，只需要去实现对应的产品工厂即可，显然这种方式是符合开闭原则的 3、抽象工厂模式 (Abstract Factory)个人觉得抽象工厂模式和工厂方法模式区别不是很大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface Factory &#123; /** * 生产车的方法 * * @return 车的对象 */ Car createCar(); /** * 获取价钱 * * @return 价钱 */ double pricing();&#125;public class AudiFactory implements Factory &#123; @Override public Car createCar() &#123; return new AudiCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：20_0000&quot;); return 20_0000; &#125;&#125;public class BmwFactory implements Factory &#123; @Override public Car createCar() &#123; return new BmwCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：25_0000&quot;); return 25_0000; &#125;&#125;public class DaZhongFactory implements Factory &#123; @Override public Car createCar() &#123; return new DaZhongCar(); &#125; @Override public double pricing() &#123; System.out.println(&quot;定价：18_0000&quot;); return 18_0000; &#125;&#125;//客户使用public class ConsumerTest &#123; public static void main(String[] args) &#123; final BmwFactory bmwFactory = new BmwFactory(); bmwFactory.createCar(); bmwFactory.pricing(); &#125;&#125; 总结：无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"wuxuan.chai"},{"title":"DO、DTO、BO、VO、POJO的定义","slug":"DO、DTO、BO、VO、POJO的定义","date":"2021-01-17T15:33:00.411Z","updated":"2021-01-17T16:16:10.255Z","comments":true,"path":"2021/01/17/DO、DTO、BO、VO、POJO的定义/","link":"","permalink":"https://cha1yi.github.io/dist/2021/01/17/DO%E3%80%81DTO%E3%80%81BO%E3%80%81VO%E3%80%81POJO%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"DO、DTO、BO、VO、POJO的定义分层领域模型规约DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。AO（ Application Object）：应用对象。 在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。POJO（ Plain Ordinary Java Object）：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。Query：数据查询对象，各层接收上层的查询请求。 注意超过2个参数的查询封装，禁止使用Map类来传输。 领域模型命名规约数据对象：xxxDO，xxx即为数据表名。数据传输对象：xxxDTO，xxx为业务领域相关的名称。展示对象：xxxVO，xxx一般为网页名称。POJO: 专指只有 setter / getter / toString的简单类，包括DO/DTO/BO/VO等,禁止命名成 xxxPOJO","categories":[{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"author":"wuxuan.chai"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://cha1yi.github.io/dist/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"开发总结","slug":"开发总结","permalink":"https://cha1yi.github.io/dist/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/categories/Spring/"},{"name":"详细教程","slug":"详细教程","permalink":"https://cha1yi.github.io/dist/categories/%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"},{"name":"数据库","slug":"数据库","permalink":"https://cha1yi.github.io/dist/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://cha1yi.github.io/dist/tags/kafka/"},{"name":"CentOS","slug":"CentOS","permalink":"https://cha1yi.github.io/dist/tags/CentOS/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://cha1yi.github.io/dist/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","permalink":"https://cha1yi.github.io/dist/tags/Spring/"},{"name":"Spring test","slug":"Spring-test","permalink":"https://cha1yi.github.io/dist/tags/Spring-test/"},{"name":"事件驱动","slug":"事件驱动","permalink":"https://cha1yi.github.io/dist/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://cha1yi.github.io/dist/tags/SpringCache/"},{"name":"VM","slug":"VM","permalink":"https://cha1yi.github.io/dist/tags/VM/"},{"name":"SkyWalking","slug":"SkyWalking","permalink":"https://cha1yi.github.io/dist/tags/SkyWalking/"},{"name":"系统监控","slug":"系统监控","permalink":"https://cha1yi.github.io/dist/tags/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"},{"name":"maven","slug":"maven","permalink":"https://cha1yi.github.io/dist/tags/maven/"},{"name":"Arthas","slug":"Arthas","permalink":"https://cha1yi.github.io/dist/tags/Arthas/"},{"name":"Java","slug":"Java","permalink":"https://cha1yi.github.io/dist/tags/Java/"},{"name":"SQL","slug":"SQL","permalink":"https://cha1yi.github.io/dist/tags/SQL/"},{"name":"设计模式","slug":"设计模式","permalink":"https://cha1yi.github.io/dist/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代码规范","slug":"代码规范","permalink":"https://cha1yi.github.io/dist/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]}